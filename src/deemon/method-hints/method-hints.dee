/* Copyright (c) 2018-2026 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2018-2026 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

/* TODO: Detect aliases between default implementations:
 *       When 2 functions share binary-compatible prototypes, and identical bodies,
 *       those 2 functions can alias each other.
 *       example: `default__seq_locate__empty' and `default__seq_rlocate__empty' */

/* TODO: Don't generate "tdefault__size_fast__with__" (typed variants without dependencies). */

import * from deemon;
import posix;

global _SpecParser;

#undef GENERATE_PP_LINE_DIRECTIVES
//#define GENERATE_PP_LINE_DIRECTIVES

#if 1
global final _printedPrefixBlocks: {string...} = HashSet();
#define RESET_PREFIX()     _printedPrefixBlocks.clear()
#define BEGIN_PREFIX(text) _printedPrefixBlocks.insert(text)
#else
#define RESET_PREFIX()     none
#define BEGIN_PREFIX(text) true
#endif

global getAllMethodHintAttributes;

function encode_DeeRT_ErrUnboundAttr(tpSelfExpr: string, self: string, encodedName: string): string {
	local decodedName = encodedName.decode("c-escape");
	local isKnownAttribute = decodedName in getAllMethodHintAttributes();
	local requiresType = tpSelfExpr != f"Dee_TYPE({self})";
	if (requiresType) {
		return isKnownAttribute
			? f"DeeRT_ErrTUnboundAttr({tpSelfExpr}, {self}, &str_{decodedName})"
			: f"DeeRT_ErrTUnboundAttrCStr({tpSelfExpr}, {self}, {encodedName})";
	} else {
		return isKnownAttribute
			? f"DeeRT_ErrUnboundAttr({self}, &str_{decodedName})"
			: f"DeeRT_ErrUnboundAttrCStr({self}, {encodedName})";
	}
}

function encode_DeeRT_ErrTUnboundAttr(decl: string, self: string, encodedName: string): string {
	local decodedName = encodedName.decode("c-escape");
	local isKnownAttribute = decodedName in getAllMethodHintAttributes();
	return isKnownAttribute
		? f"DeeRT_ErrTUnboundAttr({decl}, {self}, &str_{decodedName})"
		: f"DeeRT_ErrTUnboundAttrCStr({decl}, {self}, {encodedName})";
}



class PPCondPrinter {
	this = default;
	private member ppCond = "1";

	public setPPCond(cond: string = "1") {
		if (ppCond == cond)
			return;
		if (ppCond != "1") {
			local simpleCond = ppCond;
			if (simpleCond.startswith("defined(") && simpleCond.endswith(")")) {
				simpleCond = simpleCond[8:-1];
			} else if (simpleCond.startswith("!defined(") && simpleCond.endswith(")")) {
				simpleCond = f"!{simpleCond[9:-1]}";
			}
			print(f"#endif /* {simpleCond} */");
		}
		ppCond = cond;
		if (cond != "1") {
			if (cond.startswith("defined(") && cond.endswith(")")) {
				print(f"#ifdef {cond[8:-1]}");
			} else if (cond.startswith("!defined(") && cond.endswith(")")) {
				print(f"#ifndef !{cond[8:-1]}");
			} else {
				print(f"#if {cond}");
			}
		}
	}
}

global final USING_JOINER: string = "with__"; /* TODO: Replace with using__ */

global final CTYPE_FORMAT_REPR_CODES: {string: string} = {
	"DeeObject*":   "%r",
	"int":          "%d",
	"unsigned int": "%u",
	"Dee_ssize_t":  "%\" PRFdSIZ \"",
	"size_t":       "%\" PRFuSIZ \"",
};

function getCTypeSimplified(typ: string, after: string = ""): string {
	typ = typ.rereplace(r"\b(__restrict|const|volatile)\b", "");
	typ = typ.rereplace(r"\s*\*\s*", "*");
	typ = typ.rereplace(r"\b  +\b", " ");
	if (after)
		typ += "*";
	return typ;
}

function getCTypeFormatReprCode(typ: string, after: string): string {
	return CTYPE_FORMAT_REPR_CODES[getCTypeSimplified(typ, after)];
}


@@expansion macros defined by "%[define(foo = bar)]"
global MACROS: {string: string} = Dict();


@@Print @text to stdout, replacing $-prefixes in identifiers with @dollarName,
@@while also calling function-style macros from @formatMacros when encountered
function formatUserText(text: string, dollarName: string,
                        formatMacros: {string: Callable | string} = none)
		: string {
	File.Writer result;
	local i = 0, end = #text, flushStart = 0;
	while (i < end) {
		local ch = text[i];
		++i;
		switch (ch) {

		case "'":
		case '"': {
			while (i < end) {
				local ch2 = text[i];
				++i;
				if (ch2 == ch) {
					break;
				} else if (ch2 == '\\') {
					++i;
				}
			}
		}	break;

		case "/":
			if (text.startswith("*", i)) {
				local commentEnd = text.find("*/", i + 1);
				if (commentEnd < 0)
					break;
				i = commentEnd + 2;
				continue;
			} else if (text.startswith("/", i)) {
				local commentEnd = text.find("\n", i + 1);
				if (commentEnd < 0)
					break;
				i = commentEnd + 1;
				continue;
			}
			break;
		default:
			if (ch.issymstrt()) {
				local symStart = i - 1;
				local symEnd = i;
				while (symEnd < end && text.issymcont(symEnd))
					++symEnd;
				local symbol = text[symStart:symEnd];
				if (symbol.startswith("$")) {
					/* TODO: Replace "${using foo}" with "$" + USING_JOINER + "foo" */
					print result: text[flushStart:symStart],;
					print result: dollarName,;
					print result: symbol[1:],;
					flushStart = i = symEnd;
					continue;
				} else {
					local formatMacro: Callable | string | none = formatMacros.get(symbol);
					if (formatMacro is string) {
						print result: text[flushStart:symStart],;
						print result: formatMacro,;
						flushStart = i = symEnd;
						continue;
					} else if (formatMacro !is none) {
						print result: text[flushStart:symStart],;
						final local parser = _SpecParser(
							data: text,
							dataLen: end,
							filename: f"<body-related-to-{dollarName}>",
							tokEnd: symEnd);
						local args: {string...} = [];
						parser.next();
						parser.skip("(");
						while (parser.tok != ")") {
							local argStart = parser.tokStart;
							while (parser.tok && parser.tok !in [",", ")"]) {
								if (parser.tok == "(") {
									local recursion = 1;
									while (parser.tok) {
										parser.next();
										if (parser.tok == "(") {
											++recursion;
										} else if (parser.tok == ")") {
											--recursion;
											if (!recursion) {
												parser.next();
												break;
											}
										}
									}
								} else {
									parser.next();
								}
							}
							local argEnd = parser.tokStart;
							args.append(text[argStart:argEnd].strip());
							if (parser.tok != ",")
								break;
							parser.next();
						}
						parser.require(")");
						try {
							print result: formatMacro(args...),;
						} catch (...) {
							print File.stderr: "While expanding", repr symbol;
							throw;
						}
						flushStart = i = parser.tokEnd;
						continue;
					} else {
						local userMacro: string | none = MACROS.get(symbol);
						if (userMacro !is none) {
							print result: text[flushStart:symStart],;
							print result: formatUserText(userMacro, dollarName, formatMacros),;
							flushStart = i = symEnd;
							continue;
						}
					}
				}
				i = symEnd;
			}
			break;
		}
	}
	print result: text[flushStart:],;
	return result.string;
}


final class NativeMethodParam {
	this = default;
	public member typ: string;  /* "DeeObject *__restrict" */
	public member name: string; /* "self" */
	public member nonnull: bool = false;
	public member typAfter: string = "";  /* "[2]" */

	public property cTypeSimplified: string = {
		get(): string -> getCTypeSimplified(typ, typAfter);
	};

	public property fullTyp: string = {
		get(): string {
		return typAfter ? typ + "*" : typ;
		}
	}

	public property typWithoutRestrict: string = {
		get(): string {
			return typ
				.rereplace(r"\b__restrict\b", "")
				.rereplace(r"\b  +\b", " ");
		}
	};

	public property fullTypWithoutRestrict: string = {
		get(): string {
			return fullTyp
				.rereplace(r"\b__restrict\b", "")
				.rereplace(r"\b  +\b", " ");
		}
	};

	public _withoutRestrict(): NativeMethodParam {
		return NativeMethodParam(
				typ: typWithoutRestrict,
				name: name,
				nonnull: nonnull,
				typAfter: typAfter);
	}

	public function CstrForBody(body: string) {
		return body.recontains(f"\\b{name}\\b") ? Cstr : Cstr_UNUSED;
	}

	public property Cstr: string = {
		get(): string {
			if (typ.endswith("*"))
				return typ + name + typAfter;
			return f"{typ} {name}{typAfter}";
		}
	};

	public property Cstr_UNUSED: string = {
		get(): string {
			local UNUSED_name = typAfter
				? f"UNUSED2({name}, {typAfter})"
				: f"UNUSED({name})";
			if (typ.endswith("*"))
				return typ + UNUSED_name;
			return f"{typ} {UNUSED_name}";
		}
	};
};

function detectConstantReturnValue(body: string): string | int | none {
	local parser = _SpecParser(data: body, dataLen: #body, filename: "<inline>");
	parser.next();
	for (;;) {
		switch (parser.tok) {
		case "{":
		case "}":
		case ";":
			break;
		case "(":
			if (parser.next() != "void")
				goto nope;
			if (parser.next() != ")")
				goto nope;
			parser.next();
			parser.next();
			break;
		case "return_none":
		case "Dee_return_none":
			return "DeeNone_NewRef";
		case "return": {
			local returnExpr = parser.next();
			if (returnExpr == "(") {
				/* Cast expression, as in "(size_t)-1" */
				parser.next();
				if (parser.next() != ")")
					goto nope;
				returnExpr = parser.next();
			}
			if (returnExpr == "-") {
				returnExpr = parser.next();
				return try -int(returnExpr) catch (...) none;
			} else {
				switch (returnExpr) {
				case "DeeNone_NewRef":
					/* Special case for: "return DeeNone_NewRef()" */
					if (parser.next() == "(" && parser.next() == ")")
						return "DeeNone_NewRef";
					break;
				default: break;
				}
			}
			switch (returnExpr) {
			case "NULL":
			case "Dee_HASHOF_EMPTY_SEQUENCE":
			case "Dee_HASHOF_UNBOUND_ITEM":
			case "Dee_HASHOF_RECURSIVE_ITEM":
				return 0;
			case "ITER_DONE":
				return -1;
			case "Dee_BOUND_YES":
				return 1;
			case "Dee_BOUND_MISSING":
				return 0;
			case "Dee_BOUND_NO":
				return 2;
			case "Dee_COMPARE_ERR":
				return -2;
			case "Dee_COMPARE_EQ":
				return 0;
			case "Dee_COMPARE_NE":
				return 1; /* or "-1" */
			case "Dee_COMPARE_LO":
				return -1;
			case "Dee_COMPARE_GR":
				return 1;
			}
			return try int(returnExpr) catch (...) none;
		}	break;
		default:
			goto nope;
		}
		parser.next();
	}
nope:
	return none;
}

global NativeMethod;
global NativeOperator;
final class NativeMethodImpl {
	this = default;
	public member impl: string | none = none;      /* Implementation body */
	public member alias: string | none = none;     /* Name of a function to alias */
	public member implPrefix: {string...} = ();    /* Extra code to emit before the function body */
	public member origImpl: string | none = none;  /* Implementation body */
	public member inheritAs: string | none = none; /* Impl name that must be used when inherited as a native operator */

	public member ppLineFile: string | none = none;

	@@Line at the start of the impl (probably of the leading "{")
	public member ppLineLine: int | none = none;

#ifdef GENERATE_PP_LINE_DIRECTIVES
	private addEmbeddedLineDirectives() {
		if (ppLineLine is none)
			return;
		if (impl.startswith("{\n")) {
			impl = f'\{\n#line {ppLineLine + 1} "{ppLineFile}"\n{impl[2:]}';
		} else {
			impl = f'\n#line {ppLineLine} "{ppLineFile}"\n{impl}';
		}
	}
#endif /* GENERATE_PP_LINE_DIRECTIVES */

	@@Returns true if this impl accepts a @Super object as its "self"-argument
	public property acceptsSuperAsSelf: bool = {
		get(): bool {
			/* Might not always be true, but any impl that doesn't need to be replaced
			 * with another during inheritance is probably able to deal with "Super". */
			return inheritAs is none;
		}
	}

	function formatImpl(dollarName: string, formatMacros: {string: Callable | string} = none): string {
		return formatUserText(impl, dollarName, formatMacros);
	}

	function _makeTyped(): NativeMethodImpl {
		local result = copy this;
		if (result.alias !is none)
			result.alias = "t" + alias;
		return result;
	}

	@@Try to detect "simple" impls when linked against
	@@"method", and replace them with none-operators.
	public optimize(method: NativeMethod | NativeOperator) {
		if (inheritAs !is none && inheritAs.startswith("$"))
			inheritAs = method.normalizeSymbolName(inheritAs);
		if (impl is none)
			return;
		origImpl = impl;
		local constReturnVal: int | string = detectConstantReturnValue(impl);
		if (constReturnVal !is none) {
			@@true:  returns int
			@@false: returns size_t/pointer
			local returnType: string = method.returnType;
			local returnClass: string;
			if (returnType.startswith("DREF")) {
				returnClass = "DREF";
			} else if (returnType in ["int", "unsigned int"]) {
				returnClass = "int";
			} else if (returnType in ["Dee_ssize_t", "size_t", "Dee_hash_t"] || returnType.endswith("*")) {
				returnClass = "size_t";
			} else {
				goto done;
			}
			final local KNOWN_ALIASES: {(string, int | string, int): string} = {
				("int", 0, 1): "_DeeNone_reti0_1",
				("int", 0, 2): "_DeeNone_reti0_2",
				("int", 0, 3): "_DeeNone_reti0_3",
				("int", 0, 4): "_DeeNone_reti0_4",
				("int", 0, 5): "_DeeNone_reti0_5",
				("int", 0, 6): "_DeeNone_reti0_6",
				("size_t", 0, 1): "_DeeNone_rets0_1",
				("size_t", 0, 2): "_DeeNone_rets0_2",
				("size_t", 0, 3): "_DeeNone_rets0_3",
				("size_t", 0, 4): "_DeeNone_rets0_4",
				("size_t", 0, 5): "_DeeNone_rets0_5",
				("size_t", 0, 6): "_DeeNone_rets0_6",
				("size_t", -1, 1): "_DeeNone_retsm1_1",
				("size_t", -1, 2): "_DeeNone_retsm1_2",
				("size_t", -1, 3): "_DeeNone_retsm1_3",
				("size_t", -1, 4): "_DeeNone_retsm1_4",
				("size_t", -1, 5): "_DeeNone_retsm1_5",
				("int", 1, 1): "_DeeNone_reti1_1",
				("int", 1, 2): "_DeeNone_reti1_2",
				("int", 1, 3): "_DeeNone_reti1_3",
				("int", 1, 4): "_DeeNone_reti1_4",
				("DREF", "DeeNone_NewRef", 0): "DeeNone_NewRef",
				("DREF", "DeeNone_NewRef", 1): "_DeeNone_NewRef1",
				("DREF", "DeeNone_NewRef", 2): "_DeeNone_NewRef2",
				("DREF", "DeeNone_NewRef", 3): "_DeeNone_NewRef3",
				("DREF", "DeeNone_NewRef", 4): "_DeeNone_NewRef4",
				("DREF", "DeeNone_NewRef", 5): "_DeeNone_NewRef5",
				("DREF", "DeeNone_NewRef", 6): "_DeeNone_NewRef6",
				("DREF", "DeeNone_NewRef", 7): "_DeeNone_NewRef7",
			};
			local key: (string, int | string, int) = (returnClass, constReturnVal, #method.params);
			local knownAlias = KNOWN_ALIASES.get(key);
			if (knownAlias is none && returnClass == "DREF")
				knownAlias = KNOWN_ALIASES.get(("size_t", constReturnVal, #method.params));
			if (knownAlias !is none) {
				alias = knownAlias;
				impl = none;
			}
		}
done:;
#ifdef GENERATE_PP_LINE_DIRECTIVES
		addEmbeddedLineDirectives();
#endif /* GENERATE_PP_LINE_DIRECTIVES */
	}
}

final class OperatorSpec {
	this = default;
	@@Required base-class for this operator to be linkable
	public member baseClass: string | none;
	@@tp_seq (@none if part of the root DeeTypeObject)
	public member operatorTable: string | none = none;
	@@tp_iter
	public member operatorField: string;
	@@When true, accept any base class when loading operators
	@@into method hints, but still require @baseClass when
	@@loading method hints into operatorts.
	public member acceptAnyBaseClassForMethodHint: bool = false;
}


global MethodHint;
final class NativeMethod {
	this = default;
	public member wunused: bool;      /* true */
	public member returnType: string; /* "int" */
	public member cc: string;         /* "DCALL" */
	public member name: string;       /* "seq_any" */
	public member params: {NativeMethodParam...} = [];

	@@Implementation for calling an attribute (if available)
	public member callAttrImpl: NativeMethodImpl | none;

	@@Implementation used when this attribute isn't available
	public member unsupportedImpl: NativeMethodImpl | none = none;

	@@Implementation selection code (or "none" if only linkable against attributes)
	public member selectImpl: NativeMethodImpl | none = none;

	@@Extra impls that are linked implicitly (analogous to operator hints's "using")
	@@Keys in this dict are the names of method hints that must be available for the
	@@associated body to be usable.
	public member usingImpls: {{string...}: NativeMethodImpl} = Dict();

	@@Extra custom impls by name
	public member customImpls: {string: NativeMethodImpl} = Dict();

	@@Which part of a getset this method implements ("get", "del", "set")
	public member getsetMember: string = "";

	@@When true, @defineSelfInvocationWrapper is always false
	public member noSelfInvocationWrapper: bool = false;

	@@Descriptor for a location within "DeeTypeObject" where a binary-compatible
	@@callback can be found that may be used to implement this native method, too.
	public member operatorSpecs: {OperatorSpec...} = ();

	public member _methodHint: WeakRef with MethodHint | none = none;
	public property methodHint: MethodHint | none = { get() -> _methodHint.value; }

	public member _extraMethodHints: {(WeakRef with MethodHint)...} = ({});
	public property extraMethodHints: {MethodHint...} = {
		get(): {MethodHint...} {
			for (local ref: _extraMethodHints) {
				local val: MethodHint | none = ref.lock(none);
				if (val !is none)
					yield val;
			}
		}
	}

	public property allMethodHints: {MethodHint...} = {
		get(): {MethodHint...} {
			yield methodHint;
			yield extraMethodHints...;
		}
	}

	@@True if this method needs something like `tdefault__map_enumerate__with_callobjectcache___map_enumerate__`
	public property hasTypedCallAttrCacheImpl: bool = {
		get(): bool {
			return unsupportedImpl !is none &&
			       callAttrImpl.alias is none &&
			       methodHint.allAttributes;
		}
	}

	public member _tCallAttrImpl: NativeMethod | none = none;
	@@Typed variant of this native method, for the purpose of defining
	@@methods such as `tdefault__map_enumerate__with_callobjectcache___map_enumerate__`
	public property tCallAttrImpl: NativeMethod = {
		get(): NativeMethod {
			if (_tCallAttrImpl is none) {
				_tCallAttrImpl = NativeMethod(
						wunused: wunused,
						returnType: returnType,
						cc: cc,
						name: name,
						params: {
							NativeMethodParam(
									typ: "DeeTypeObject *",
									name: "tp_self",
									nonnull: true),
							params.each._withoutRestrict()...
						},
						callAttrImpl: callAttrImpl.alias is none
								? callAttrImpl
								: NativeMethodImpl(alias: f"t{callAttrImpl.alias}"),
						getsetMember: getsetMember,
						noSelfInvocationWrapper: noSelfInvocationWrapper,
						operatorSpecs: operatorSpecs,
				);
			}
			return _tCallAttrImpl;
		}
	}

	@@Enumerate all impls as the name by which they get declared, and the actual impl
	public property allImpls: {(string, NativeMethodImpl)...} = {
		get(): {(string, NativeMethodImpl)...} {
			if (defineSelfInvocationWrapper)
				yield (f"default__{name}", selfInvocationWrapperImpl);
			for (local attr: methodHint.allAttributes.distinct())
				yield (f"default__{name}__with_callattr_{attr}", callAttrImpl);
			if (unsupportedImpl !is none)
				yield (f"default__{name}__unsupported", unsupportedImpl);
			for (local dependencies, impl: usingImpls)
				yield (getUsingImplName(dependencies), impl);
			for (local name, impl: customImpls)
				yield (name, impl);
		}
	}

	public property tpSelfExpr: string = {
		get(): string {
			local firstParam = params.first;
			local n = firstParam.typ.count("*") - 1;
			if (firstParam.typAfter)
				++n;
			return f"Dee_TYPE({"*" * n}{firstParam.name})";
		}
	};

	public getReturnAttrib(_T: string = ""): string {
		local attributes: {string...} = [];
		if (wunused)
			attributes.append(f"WUNUSED{_T}");
		local nonnullIndices = ", ".join(params.enumerate()
			.filter(e -> e.last.nonnull)
			.map(e -> e.first + 1));
		if (nonnullIndices)
			attributes.append(f"NONNULL{_T}(({nonnullIndices}))");
		return " ".join(attributes);
	}

	public normalizeSymbolName(name: string): string {
		if (name.startswith("$"))
			return f"default__{this.name}__{name[1:]}";
		return name;
	}

	function getUsingImplName(dependencies: {string...}): string {
		return f"default__{name}__{USING_JOINER}{"__and__".join(dependencies)}";
	}

	public optimize() {
		callAttrImpl.optimize(this);
		unsupportedImpl.optimize(this);
		for (local none, impl: usingImpls)
			impl.optimize(this);
		for (local none, impl: customImpls)
			impl.optimize(this);
	}

	public printDecl(name: string, lineFeedBeforeName: bool = false,
	                 bodyHint: string | none = none,
	                 parenAroundName: bool = false) {
		local attrib = getReturnAttrib();
		if (attrib)
			print(attrib, " "),;
		print returnType,;
		if (lineFeedBeforeName) {
			if (parenAroundName) {
				print;
				print("("),;
				if (cc)
					print(cc, " "),;
			} else {
				if (cc) {
					if (!returnType.endswith("*"))
						print " ",;
					print cc,;
				}
				print;
			}
		} else {
			if (!returnType.endswith("*"))
				print " ",;
			if (parenAroundName)
				print("("),;
			if (cc)
				print(cc, " "),;
		}
		print(name),;
		if (parenAroundName)
			print(")"),;
		print("(", ", ".join(bodyHint !is none
			? params.each.CstrForBody(bodyHint)
			: params.each.Cstr), ")"),;
	}

	public printFunctionPointerType(name: string = "") {
		print returnType,;
		if (!returnType.endswith("*"))
			print " ",;
		print("("),;
		if (cc)
			print(cc, " "),;
		print("*", name, ")", "("),;
		print(", ".join(params.each.fullTyp)),;
		print(")"),;
	}

	@@True if this method has `default__{name}__with_callobjectcache_{hintAttr}` variants.
	public property hasWithCallCacheDefaultImpls: bool = {
		get() -> methodHint.allAttributes && callAttrImpl.alias is none;
	};

	public printIntdefDeclOrAlias(name: string, impl: NativeMethodImpl | none) {
		if (impl.alias !is none) {
			print(f"#define {name} (*("),;
			printFunctionPointerType();
			print(f")&{impl.alias})");
		} else {
			print("INTDEF "),;
			printDecl(name);
			print(";");
		}
	}

	@@@param functionMacros Custom callbacks for macro replacement.
	public printInternImpl(name: string, impl: NativeMethodImpl,
	                       formatMacros: {string: Callable} = none) {
		assert impl.alias is none;
		local dollarName = f"default__{this.name}__";
		for (local prefix: impl.implPrefix) {
			if (BEGIN_PREFIX(prefix))
				print formatUserText(prefix, dollarName, formatMacros);
		}
		print("INTERN "),;
		local body = impl.formatImpl(dollarName, formatMacros);
		printDecl(name, lineFeedBeforeName: true, bodyHint: body);
		print(" "),;
		print(body);
	}

	public printMHTypedef() {
		print("typedef "),;
		local attrib = getReturnAttrib("_T");
		if (attrib)
			print(attrib, " "),;
		print returnType,;
		if (!returnType.endswith("*"))
			print " ",;
		print("("),;
		if (cc)
			print(cc, " "),;
		print("*DeeMH_", name, "_t)", "("),;
		print(", ".join(params.each.Cstr)),;
		print(");");
	}

	@@When true, define an impl @f"default__{name}"
	public property defineSelfInvocationWrapper: bool = {
		get(): bool {
			return (operatorSpecs || getsetMember) && !noSelfInvocationWrapper;
		}
	}

	public property selfInvocationWrapperImpl: NativeMethodImpl = {
		get(): NativeMethodImpl {
			return NativeMethodImpl(impl:
				f"\{\n"
				f"\treturn (*DeeType_RequireMethodHint({tpSelfExpr}, {
						name}))({", ".join(params.each.name)});\n"
				f"\}");
		}
	}


	public printDefaultImplDecls() {
		print(f"/* {name} */");
		if (defineSelfInvocationWrapper)
			printIntdefDeclOrAlias(f"default__{name}", none);
		local methodHint = this.methodHint;
		for (local attr: methodHint.allAttributes.distinct()) {
			if (callAttrImpl is none)
				throw Error(f"Native method {repr name} is missing impl for callattr({repr attr})");
			printIntdefDeclOrAlias(f"default__{name}__with_callattr_{attr}", callAttrImpl);
		}
		if (methodHint.allAttributes) {
			local hintAttr = methodHint.attr;
			printIntdefDeclOrAlias(f"default__{name}__with_callobjectcache_{hintAttr}", callAttrImpl);
			if (hasTypedCallAttrCacheImpl) {
				local tMethod = tCallAttrImpl;
				tMethod.printIntdefDeclOrAlias(
						f"tdefault__{name}__with_callobjectcache_{hintAttr}",
						tMethod.callAttrImpl);
			}
		}
		if (unsupportedImpl !is none)
			printIntdefDeclOrAlias(f"default__{name}__unsupported", unsupportedImpl);
		for (local dependencies, impl: usingImpls)
			printIntdefDeclOrAlias(getUsingImplName(dependencies), impl);
		for (local name, impl: customImpls)
			printIntdefDeclOrAlias(name, impl);
		print;
	}

	public printDefaultImpls() {
		print(f"/* {name} */");
		local methodHint = this.methodHint;
		if (defineSelfInvocationWrapper) {
			printInternImpl(f"default__{name}", selfInvocationWrapperImpl);
			print;
		}
		for (local attr: methodHint.allAttributes.distinct()) {
			if (callAttrImpl is none)
				throw Error(f"Native method {repr name} is missing impl for callattr({repr attr})");
			if (callAttrImpl.alias !is none)
				continue;
			printInternImpl(f"default__{name}__with_callattr_{attr}", callAttrImpl, {
				"LOCAL_str_attr": () -> f"Dee_AsObject(&str_{attr})",
				"LOCAL_STR_attr": () -> f"STR_{attr}",
				"LOCAL_GETATTR": (self) ->
					f"DeeObject_GetAttr({self}, Dee_AsObject(&str_{attr}))",
				"LOCAL_BOUNDATTR": (self) ->
					f"DeeObject_BoundAttr({self}, Dee_AsObject(&str_{attr}))",
				"LOCAL_DELATTR": (self) ->
					f"DeeObject_DelAttr({self}, Dee_AsObject(&str_{attr}))",
				"LOCAL_SETATTR": (self, value) ->
					f"DeeObject_SetAttr({self}, Dee_AsObject(&str_{attr}), {value})",
				"LOCAL_CALLATTR": (self, argc, argv) ->
					f"DeeObject_CallAttr({self}, Dee_AsObject(&str_{attr}), {argc}, {argv})",
				"LOCAL_CALLATTRF": (self, args...) ->
					f"DeeObject_CallAttrf({self}, Dee_AsObject(&str_{attr}), {", ".join(args)})",
			});
			print;
		}
		if (hasWithCallCacheDefaultImpls) {
			local hintAttr = methodHint.attr;
			local usedCallAttrImpl: NativeMethodImpl = callAttrImpl;
			local callCacheName = f"default__{name}__with_callobjectcache_{hintAttr}";
			local selfExpr = params.first.name;
			local selfExprInd = params.first.typ.count("*");
			if (selfExprInd >= 2)
				selfExpr = f"{"*" * (selfExprInd - 1)}{selfExpr}";
			local tpSelfExpr = f"Dee_TYPE({selfExpr})";
			if (hasTypedCallAttrCacheImpl) {
				usedCallAttrImpl = copy usedCallAttrImpl;
				usedCallAttrImpl.impl =
					f"\{\n"
					f"#ifdef __OPTIMIZE_SIZE__\n"
					f"	return t{callCacheName}({tpSelfExpr}{"".join(
						for (local x: params) f", {x.name}"
					)});\n"
					f"#else /* __OPTIMIZE_SIZE__ */\n"
					f"	{usedCallAttrImpl.impl.strip().strip("{}").strip()}\n"
					f"#endif /* !__OPTIMIZE_SIZE__ */\n"
					f"\}";
			}
			printInternImpl(callCacheName, usedCallAttrImpl,
					getCallAttrMacros(tpSelfExpr, hintAttr, methodHint.getset));
			print;
		}
		if (unsupportedImpl !is none && unsupportedImpl.alias is none) {
			printInternImpl(f"default__{name}__unsupported", unsupportedImpl);
			print;
		}
		function makeImplBodyMacros(): {string: string | Callable} {
			local preloadedDependencies: {string...} = HashSet();
			return {
				"THIS_TYPE": tpSelfExpr,
				"CALL_DEPENDENCY": (dep, args...) -> {
					if (dep in preloadedDependencies)
						return f"(*cached_{dep})({", ".join(args)})";
					return f"(*DeeType_RequireMethodHint({
						tpSelfExpr}, {dep}))({", ".join(args)})";
				},
				"REQUIRE_DEPENDENCY": (dep) -> {
					if (dep in preloadedDependencies)
						return f"cached_{dep}";
					return f"DeeType_RequireMethodHint({tpSelfExpr}, {dep})";
				},
				"PRELOAD_DEPENDENCY": (dep) -> {
					preloadedDependencies.insert(dep);
					return f"DeeMH_{dep}_t cached_{dep} = DeeType_RequireMethodHint({
							tpSelfExpr}, {dep});";
				},
				"DeeRT_ErrUnboundAttrCStr": (self, name) ->
					encode_DeeRT_ErrUnboundAttr(tpSelfExpr, self, name),
				"DeeRT_ErrTUnboundAttrCStr": (decl, self, name) ->
					encode_DeeRT_ErrTUnboundAttr(decl, self, name),
			};
		}
		for (local dependencies, impl: usingImpls) {
			if (impl.alias is none) {
				printInternImpl(getUsingImplName(dependencies), impl, makeImplBodyMacros());
				print;
			}
		}
		for (local name, impl: customImpls) {
			if (impl.alias is none) {
				printInternImpl(name, impl, makeImplBodyMacros());
				print;
			}
		}
		print;
	}

	function getCallAttrMacros(tpSelfExpr: string,
	                           hintAttr: string,
	                           getset: bool)
			: {string: string | Callable} {
		if (getset) {
			return {
				"LOCAL_GETATTR": (self) ->
					f"mhcache_call({tpSelfExpr}, {
							tpSelfExpr}->tp_mhcache->mhc_get_{hintAttr}, 1, (DeeObject *const *)&{self})",
				"LOCAL_BOUNDATTR": (self) ->
					f"mhcache_call_bound({tpSelfExpr}, {
							tpSelfExpr}->tp_mhcache->mhc_get_{hintAttr}, 1, (DeeObject *const *)&{self})",
				"LOCAL_DELATTR": (self) ->
					f"mhcache_call_int({tpSelfExpr}, {
							tpSelfExpr}->tp_mhcache->mhc_del_{hintAttr}, 1, (DeeObject *const *)&{self})",
				"LOCAL_SETATTR": (self, value) ->
					f"mhcache_thiscall_int({tpSelfExpr}, {
							tpSelfExpr}->tp_mhcache->mhc_set_{hintAttr}, {self}, 1, (DeeObject *const *)&{value})",
				"LOCAL_CALLATTR": (self, argc, argv) ->
					f"mhcache_thiscall_result({tpSelfExpr}, {
							tpSelfExpr}->tp_mhcache->mhc_get_{
							hintAttr}, 1, (DeeObject *const *)&{self}, {argc}, {argv})",
				"LOCAL_CALLATTRF": (self, args...) ->
					f"mhcache_thiscall_resultf({tpSelfExpr}, {
							tpSelfExpr}->tp_mhcache->mhc_get_{
							hintAttr}, 1, (DeeObject *const *)&{self}, {", ".join(args)})",
			};
		} else {
			return {
				"LOCAL_GETATTR": (self) ->
					f"mhcache_instancemethod({tpSelfExpr}, {
							tpSelfExpr}->tp_mhcache->mhc_{hintAttr}, {self})",
				"LOCAL_BOUNDATTR": (self) -> f"Dee_BOUND_YES",
				"LOCAL_CALLATTR": (self, argc, argv) -> {
					if (argc == "0") {
						return f"mhcache_call({tpSelfExpr}, {
								tpSelfExpr}->tp_mhcache->mhc_{hintAttr}, 1, (DeeObject *const *)&{self})";
					}
					return f"mhcache_thiscall({tpSelfExpr}, {
							tpSelfExpr}->tp_mhcache->mhc_{hintAttr}, {
							self}, {argc}, {argv})";
				},
				"LOCAL_CALLATTRF": (self, args...) ->
					f"mhcache_thiscallf({tpSelfExpr}, {
							tpSelfExpr}->tp_mhcache->mhc_{
							hintAttr}, {self}, {", ".join(args)})",
			};
		}
	}

	public printTypedDefaultImpls() {
		if (!hasTypedCallAttrCacheImpl)
			return;
		print(f"/* {name} */");
		local methodHint = this.methodHint;
		local hintAttr = methodHint.attr;
		local tMethod = tCallAttrImpl;
		local tpSelfExpr = tMethod.params.first.name;
		local callCacheName = f"tdefault__{name}__with_callobjectcache_{hintAttr}";
		tMethod.printInternImpl(callCacheName, tMethod.callAttrImpl,
				tMethod.getCallAttrMacros(tpSelfExpr, hintAttr, methodHint.getset));
		print;
	}

	public printMhCacheNativeMember() {
		print(f"	DeeMH_{name}_t mh_{name};");
	}

	public printMhInitSelectImpl() {
		assert selectImpl !is none;
		local body = selectImpl.formatImpl(f"default__{name}__", {
			"THIS_TYPE": "self",
			"ORIG_TYPE": "orig_type",
			"SEQ_CLASS": "DeeType_GetSeqClass(self)",
			"REQUIRE": (mhName) ->
				f"(DeeMH_{mhName}_t)DeeType_GetPrivateMethodHint(self, orig_type, Dee_TMH_{mhName})",
			"REQUIRE_NODEFAULT": (mhName) ->
				f"(DeeMH_{mhName}_t)DeeType_GetPrivateMethodHintNoDefault(self, orig_type, Dee_TMH_{mhName})",
			"HAS_TRAIT": (trait) ->
				f"DeeType_HasPrivateTrait(self, orig_type, DeeType_TRAIT_{trait})",
			"HAS_TRAIT_NODEFAULT": (trait) ->
				f"DeeType_HasExplicitTrait(self, DeeType_TRAIT_{trait})",
			"REQUIRE_ANY": (mhName) ->
				f"(DeeMH_{mhName}_t)DeeType_GetMethodHint(orig_type, Dee_TMH_{mhName})",
			"Dee_type_seq_has_custom_tp_size":
				(x) -> f"{x}->tp_size && !DeeType_IsDefaultSize({x}->tp_size)",
			"Dee_type_seq_has_custom_tp_sizeob":
				(x) -> f"{x}->tp_sizeob && !DeeType_IsDefaultSizeOb({x}->tp_sizeob)",
			"Dee_type_seq_has_custom_tp_foreach":
				(x) -> f"{x}->tp_foreach && !DeeType_IsDefaultForeach({x}->tp_foreach)",
		});
		if (body.startswith("{") && body.endswith("}"))
			body = body[1:-1];
		print(f"INTERN ATTR_PURE WUNUSED NONNULL((1, 2)) DeeMH_{name}_t DCALL");
		print(f"mh_select_{name}(DeeTypeObject *{
				body.recontains(r"\bself\b") ? "self" : ""}, DeeTypeObject *{
				body.recontains(r"\borig_type\b") ? "orig_type" : ""}) \{"),;
		print(body),;
		print("	return NULL;");
		print("}");
		print;
	}
}

global final PRETTY_BASE_CLASS_NAMES: {string: string} = {
	"DeeSeq_Type": "Sequence",
	"DeeSet_Type": "Set",
	"DeeMapping_Type": "Mapping",
	"DeeNumeric_Type": "Numeric",
	"DeeIterator_Type": "Iterator",
};

global final BASE_CLASS_ALIASES: {string: string} = Dict.Frozen(
	for (local nativeName, prettyName: PRETTY_BASE_CLASS_NAMES)
		(prettyName, nativeName));

final class MethodHintAlias {
	this = default;
	public member baseClass: string | none; /* "DeeSeq_Type" */
	public member attr: string;             /* "any" */
	public member nameAliases: {string...} = ();
	public property name: string = {
		get() {
			if (baseClass is none)
				return attr;
			return f"{PRETTY_BASE_CLASS_NAMES.get(baseClass, baseClass)}_{attr}";
		}
	}
}

final class MethodHint: WeakRefAble {
	this = default;
	public member name: string; /* "__seq_any__" */
	public member declNameAliases: {string...} = []; /* Some more aliases for "name" (for backwards compat) */
	public member attr: string; /* "__seq_any__" */
	public member doc: string;  /* "(start=!0,end=!-1,key:?DCallable=!N)->?Dbool" */
	public member aliases: {MethodHintAlias...};
	public member call2native: NativeMethod | none; /* Implementation for "DeeMH___seq_any__" (or "none" for getsets) */
	public member kw: bool = false; /* True if `call2nativeImpl' has a "kw" argument */
	public member getset: bool = false; /* True if this is a getset (meaning it has 3 mhcache slots) */
	public member getsetCallbacks: {string...} = []; /* Set of getset callbacks defined in @nativeHints (s.a. @NativeMethod.getsetMember) */
	public member nativeHints: {string: NativeMethod} = Dict();
	@@Used to store the call2native implementations of custom properties
	@@Keys here are one of @{"get", "del", "set", "bound"}
	public member propertyCall2native: {string: NativeMethod} = Dict();

	public property nameComment: string = {
		get(): string {
			return ", ".join(allNames);
		}
	};

	public property typeMethodFlags: string = {
		get(): string {
			return kw ? "Dee_TYPE_METHOD_FKWDS" : "Dee_TYPE_METHOD_FNORMAL";
		}
	};

	public property allNames: {string...} = {
		get(): {string...} {
			for (local alias: aliases) {
				yield alias.name;
				yield alias.nameAliases...;
			}
			yield name;
			yield declNameAliases...;
		}
	};

	public property allAttributes: {string...} = {
		get(): {string...} {
			for (local alias: aliases)
				yield alias.attr;
			yield attr;
		}
	};

	public function guessSeqClass(): string | none {
		if (aliases.some.baseClass == "DeeSeq_Type")
			return "seq";
		if (aliases.some.baseClass == "DeeSet_Type")
			return "set";
		if (aliases.some.baseClass == "DeeMapping_Type")
			return "map";
		if (attr.startswith("__seq_"))
			return "seq";
		if (attr.startswith("__set_"))
			return "set";
		if (attr.startswith("__map_"))
			return "map";
		return none;
	}

	function getMhCacheAttributeMembers(): {string...} {
		if (getset) {
			if ("get" in getsetCallbacks || "bound" in getsetCallbacks)
				yield f"mhc_get_{attr}";
			if ("del" in getsetCallbacks)
				yield f"mhc_del_{attr}";
			if ("set" in getsetCallbacks)
				yield f"mhc_set_{attr}";
		} else {
			yield f"mhc_{attr}";
		}
	}

	private getNativeMethodAttributeImpls(): {(string, NativeMethod)...} {
		if (call2native !is none)
			return {{"", call2native}};
		if (propertyCall2native) {
			return propertyCall2native.map(e -> {
				local k, v = e...;
				return {"_" + k, v};
			});
		}
		return {};
	}

	public printMethodAttributeDecls() {
		local didSomething = false;
		local allAliases = [];
		for (local nameSuffix, call2native: getNativeMethodAttributeImpls()) {
			if (!didSomething) {
				print("#define DeeMA_", name, "_flags ", typeMethodFlags);
				print("#define DeeMA_", name, "_name  _DeeMA_ATTRSTR(", attr, ")");
				print("#define DeeMA_", name, "_doc   ", repr doc);
			}
			Set.insert(allAliases, name);
			local name = this.name + nameSuffix;
			print("DFUNDEF "),;
			call2native.printDecl(f"DeeMA_{name}");
			print(";");
			for (local alias: aliases) {
				if (!didSomething) {
					print("#define DeeMA_", alias.name, "_flags DeeMA_", this.name, "_flags");
					print("#define DeeMA_", alias.name, "_name  _DeeMA_ATTRSTR(", alias.attr, ")");
					print("#define DeeMA_", alias.name, "_doc   DeeMA_", this.name, "_doc");
				}
				print("#define DeeMA_", alias.name, nameSuffix, "       DeeMA_", name);
				Set.insert(allAliases, alias.name);
				for (local nameAlias: alias.nameAliases) {
					if (!didSomething) {
						print("#define DeeMA_", nameAlias, "_flags DeeMA_", alias.name, "_flags");
						print("#define DeeMA_", nameAlias, "_name  DeeMA_", alias.name, "_name");
						print("#define DeeMA_", nameAlias, "_doc   DeeMA_", alias.name, "_doc");
					}
					print("#define DeeMA_", nameAlias, nameSuffix, "       DeeMA_", alias.name, nameSuffix);
					Set.insert(allAliases, nameAlias);
				}
			}
			for (local declAlias: declNameAliases) {
				if (!didSomething) {
					print("#define DeeMA_", declAlias, "_flags DeeMA_", name, "_flags");
					print("#define DeeMA_", declAlias, "_name  DeeMA_", name, "_name");
					print("#define DeeMA_", declAlias, "_doc   DeeMA_", name, "_doc");
				}
				print("#define DeeMA_", declAlias, nameSuffix, "       DeeMA_", name);
				Set.insert(allAliases, declAlias);
			}
			didSomething = true;
		}
		if (didSomething) {
			if (propertyCall2native) {
				local supportedMethods = propertyCall2native.keys;
				for (local name: allAliases) {
					/* TODO: Optimizations for always-bound */
					if (supportedMethods == {"get"}) {
						print("#define _DeeMA_TYPE_GETSET_HINTREF_", name, "(doc) Dee_TYPE_GETTER_F("
						      "DeeMA_", name, "_name, &DeeMA_", name, "_get, DeeMA_", name, "_flags, doc)");
					} else if ("bound" in supportedMethods) {
						print("#define _DeeMA_TYPE_GETSET_HINTREF_", name, "(doc) Dee_TYPE_GETSET_BOUND_F("
						      "DeeMA_", name, "_name, ",
						      ("get" in supportedMethods ? f"&DeeMA_{name}_get" : "NULL"), ", ",
						      ("del" in supportedMethods ? f"&DeeMA_{name}_del" : "NULL"), ", ",
						      ("set" in supportedMethods ? f"&DeeMA_{name}_set" : "NULL"), ", ",
						      ("bound" in supportedMethods ? f"&DeeMA_{name}_bound" : "NULL"), ", "
						      "DeeMA_", name, "_flags, doc)");
					} else {
						print("#define _DeeMA_TYPE_GETSET_HINTREF_", name, "(doc) Dee_TYPE_GETSET_F("
						      "DeeMA_", name, "_name, ",
						      ("get" in supportedMethods ? f"&DeeMA_{name}_get" : "NULL"), ", ",
						      ("del" in supportedMethods ? f"&DeeMA_{name}_del" : "NULL"), ", ",
						      ("set" in supportedMethods ? f"&DeeMA_{name}_set" : "NULL"), ", "
						      "DeeMA_", name, "_flags, doc)");
					}
				}
			}
			print;
		}
	}

	public printMethodAttributeImpls() {
		for (local nameSuffix, call2native: getNativeMethodAttributeImpls()) {
			local tpSelfExpr = call2native.tpSelfExpr;
			local preloadedDependencies: {string...} = HashSet();
			local body = call2native.callAttrImpl.formatImpl("$", {
				"THIS_TYPE": tpSelfExpr,
				"CALL_DEPENDENCY": (dep, args...) -> {
					if (dep in preloadedDependencies)
						return f"(*cached_{dep})({", ".join(args)})";
					return f"(*DeeType_RequireMethodHint({
						tpSelfExpr}, {dep}))({", ".join(args)})";
				},
				"REQUIRE_DEPENDENCY": (dep) -> {
					if (dep in preloadedDependencies)
						return f"cached_{dep}";
					return f"DeeType_RequireMethodHint({tpSelfExpr}, {dep})";
				},
				"PRELOAD_DEPENDENCY": (dep) -> {
					preloadedDependencies.insert(dep);
					return f"DeeMH_{dep}_t cached_{dep} = DeeType_RequireMethodHint({
							tpSelfExpr}, {dep});";
				},
				"DeeRT_ErrUnboundAttrCStr": (self, name) ->
					encode_DeeRT_ErrUnboundAttr(tpSelfExpr, self, name),
				"DeeRT_ErrTUnboundAttrCStr": (decl, self, name) ->
					encode_DeeRT_ErrTUnboundAttr(decl, self, name),
			});
			print("PUBLIC "),;
			call2native.printDecl(f"DeeMA_{name}{nameSuffix}",
					lineFeedBeforeName: true,
					bodyHint: body);
			print(" ", body);
			print;
		}
	}
}



function simplifyNativeOperatorNamePart(part: string): string {
	return part.rpartition(".").last
			.lsstrip("tp_")
			.lsstrip("Dee_CLASS_")
			.lsstrip("OPERATOR_")
			.replace(".", "_");
}

final class NativeOperatorName {
	this = default;
	public member table: string | none = none; /* tp_seq */
	public member field: string;               /* tp_foreach */

	public property tableStruct: string = {
		get(): string {
			return table is none
				? "DeeTypeObject"
				: f"struct type_{table.lstrip("tp_")}";
		}
	}

	public property TNO_id: string = {
		get(): string {
			return f"Dee_TNO_{name}";
		}
	}

	public property OPERATOR_name: string = {
		get(): string {
			assert table is none, f"Expected '{locExpr}' to be an operator name";
			return field;
		}
	}

	public property name: string = {
		get(): string {
#if 1
			return simplifyNativeOperatorNamePart(field);
#else
			if (table is none)
				return simplifyNativeOperatorNamePart(field);
			return f"{
				simplifyNativeOperatorNamePart(table)
			}_{
				simplifyNativeOperatorNamePart(field)
			}";
#endif
		}
	}

	public property locExpr: string = {
		get(): string {
			if (table !is none)
				return f"{table}->{field}";
			return field;
		}
	}

	operator str() -> locExpr;
}



final class NativeOperatorImpl {
	this = default;
	@@Operators that must be provided for this one to function
	public member dependencies: {NativeOperatorName...} = [];
	public member impl: NativeMethodImpl;

	@@When true, encode this impl as disliked
	public member disliked: bool = false;

	public optimize(method: NativeOperator) {
		impl.optimize(method);
	}

	public _makeTyped(): NativeOperatorImpl {
		return NativeOperatorImpl(
				dependencies: dependencies,
				impl: impl._makeTyped(),
				disliked: disliked);
	}
}

global NATIVE_OPERATORS;
final class NativeOperator {
	this = default;
	public member wunused: bool;                       /* true */
	public member returnType: string;                  /* "int" */
	public member cc: string;                          /* "DCALL" */
	public member name: NativeOperatorName;            /* tp_seq->tp_foreach */
	public member params: {NativeMethodParam...} = []; /* { ... } */
	public member tpSelfExpr: string;                  /* "Dee_TYPE(self)" */
	public member exportPrecheck: string;              /* ... */
	public member impls: {NativeOperatorImpl...} = []; /* { ... } */
	public member usrtypeImpls: {NativeOperatorImpl...} = [];
	public member typed: NativeOperator | none = none;
	public member namePrefix: string = "";
	public member operatorName: string = ""; /* OPERATOR_ITER (empty string if not assigned) */
	public member customUnsupportedImplName: string = "";
	public member customBadAllocImplName: string = "";
	public member ppCond: string = "1";

	@@Names of public API functions: @("DeeObject_Foreach", "DeeObject_TForeach")
	public member operatorExportNames: (string, string) | none = none;

	@@Returns the name of the high-level `*__unsupported` symbol (if there is one)
	public property unsupportedImplName: string | none = {
		get(): string | none {
			if (customUnsupportedImplName)
				return customUnsupportedImplName;
			if (operatorName)
				return f"default__{name.name}__unsupported";
			return none;
		}
	}

	public _makeTyped() {
		typed = NativeOperator(
			wunused: wunused,
			returnType: returnType,
			cc: cc,
			name: name,
			params: (
				NativeMethodParam(
					typ: "DeeTypeObject *",
					name: "tp_self",
					nonnull: true),
				params.each._withoutRestrict()...),
			operatorName: operatorName,
			tpSelfExpr: "tp_self",
			exportPrecheck: exportPrecheck,
			impls: Tuple(impls.each._makeTyped()),
			usrtypeImpls: Tuple(usrtypeImpls.each._makeTyped()),
			namePrefix: "t"
		);
	}

	public getReturnAttrib(_T: string = ""): string {
		local attributes: {string...} = [];
		if (wunused)
			attributes.append(f"WUNUSED{_T}");
		local nonnullIndices = params.enumerate()
			.filter(e -> e.last.nonnull)
			.map(e -> e.first + 1);
		nonnullIndices = nonnullIndices.cached;
		if (nonnullIndices)
			attributes.append(f"NONNULL{_T}(({", ".join(nonnullIndices)}))");
		return " ".join(attributes);
	}

	public optimize() {
		if (!tpSelfExpr)
			tpSelfExpr = f"Dee_TYPE({params.first.name})";
		for (local impl: impls)
			impl.optimize(this);
		typed.optimize();
	}

	public printNativeOperatorTypedef() {
		print("typedef "),;
		local attrib = getReturnAttrib("_T");
		if (attrib)
			print(attrib, " "),;
		print returnType,;
		if (!returnType.endswith("*"))
			print " ",;
		print("("),;
		if (cc)
			print(cc, " "),;
		print("*DeeNO_", name.name, "_t)", "("),;
		print(", ".join(params.each.Cstr)),;
		print(");");
	}

	public printDecl(name: string, lineFeedBeforeName: bool = false,
	                 bodyHint: string | none = none,
	                 parenAroundName: bool = false) {
		local attrib = getReturnAttrib();
		if (attrib)
			print(attrib, " "),;
		print returnType,;
		if (lineFeedBeforeName) {
			if (parenAroundName) {
				print;
				print("("),;
				if (cc)
					print(cc, " "),;
			} else {
				if (cc) {
					if (!returnType.endswith("*"))
						print " ",;
					print cc,;
				}
				print;
			}
		} else {
			if (!returnType.endswith("*"))
				print " ",;
			if (parenAroundName)
				print("("),;
			if (cc)
				print(cc, " "),;
		}
		print(name),;
		if (parenAroundName)
			print(")"),;
		print("(", ", ".join(bodyHint !is none
			? params.each.CstrForBody(bodyHint)
			: params.each.Cstr), ")"),;
	}

	public printFunctionPointerType(name: string = "") {
		print returnType,;
		if (!returnType.endswith("*"))
			print " ",;
		print("("),;
		if (cc)
			print(cc, " "),;
		print("*", name, ")(", ", ".join(params.each.typ), ")"),;
	}

	public printIntdefDeclOrAlias(name: string, impl: NativeMethodImpl | none) {
		if (impl.alias !is none) {
			print(f"#define {name} (*("),;
			printFunctionPointerType();
			print(f")&{impl.alias})");
		} else {
			print("INTDEF "),;
			printDecl(name);
			print(";");
		}
	}

	function nativeSymbolNameForUrstypeImpl(impl: NativeOperatorImpl): string {
		return f"{namePrefix}usrtype__{name.name}__with__{
			"__and__".join(impl.dependencies.each.name)
		}";
	}

	function nativeSymbolNameForImpl(impl: NativeOperatorImpl): string {
		return f"{namePrefix}default__{name.name}__with__{
			"__and__".join(impl.dependencies.each.name)
		}";
	}

	function enumerateNamesAndImpls(): {(string, NativeOperatorImpl)...} {
		for (local impl: usrtypeImpls) {
			yield (nativeSymbolNameForUrstypeImpl(impl), impl);
		}
		for (local impl: impls) {
			yield (nativeSymbolNameForImpl(impl), impl);
		}
	}

	public property hasMakeTypedMacro: bool = {
		get(): bool {
			return !!doPrintNativeOperatorHintDecl(true);
		}
	}

	@@Should the default typed-wrapper be generated (e.g. @"tdefault__size")
	public property hasGenericTypedImpl: bool = {
		get(): bool {
			/* Default wrapper is only needed if there are impls that need
			 * to be mapped, where it then represents the fallback mapping. */
			return hasMakeTypedMacro;
		}
	}

	@@Returns symbol names of impls that must appear in `maketyped__*`
	function doPrintNativeOperatorHintDecl(skipPrint: bool = false): {string...} {
		local result: {string...} = [];
		for (local symName, impl: enumerateNamesAndImpls()) {
			if (!skipPrint)
				printIntdefDeclOrAlias(symName, impl.impl);
			local coreImpl: NativeMethodImpl = impl.impl;
			if (coreImpl.origImpl is none ||
			    coreImpl.origImpl.recontains(r"\b(CALL_DEPENDENCY|REQUIRE_DEPENDENCY)\b")) {
				result.append(symName);
			}
		}
		return result;
	}

	function printNativeOperatorHintDecl() {
		print("/* ", name.locExpr, " */");
		local typedNames = typed.doPrintNativeOperatorHintDecl();
		if (hasGenericTypedImpl)
			typed.printIntdefDeclOrAlias(f"{typed.namePrefix}default__{name.name}", none);
		local normalNames = doPrintNativeOperatorHintDecl();
		assert #normalNames == #typedNames;
		local nameFieldBase = name.field.rpartition(".").last;
		if (usrtypeImpls) {
			print(f"#define isusrtype__{name.name}({nameFieldBase}) ({
				" || ".join(
					for (local impl: usrtypeImpls)
						f"({nameFieldBase}) == &{nativeSymbolNameForUrstypeImpl(impl)}"
				)
			})");
		}
		if (impls) {
			print(f"#define isdefault__{name.name}({nameFieldBase}) ({
				" || ".join(
					for (local impl: impls)
						f"({nameFieldBase}) == &{nativeSymbolNameForImpl(impl)}"
				)
			})");
		}
		if (normalNames) {
			print(f"#define maketyped__{name.name}({nameFieldBase}) ({"".join(
				for (local i, symbolName: normalNames.enumerate())
					f"({nameFieldBase}) == &{symbolName} ? &{typedNames[i]} : "
			)}&tdefault__{name.name})");
		}
		print;
	}

	@@@param functionMacros Custom callbacks for macro replacement.
	public printInternImpl(name: string, impl: NativeMethodImpl,
	                       formatMacros: {string: Callable} = none) {
		assert impl.alias is none;
		for (local prefix: impl.implPrefix) {
			if (BEGIN_PREFIX(prefix))
				print(formatUserText(prefix, "$", formatMacros));
		}
		local body = impl.formatImpl("$", formatMacros);
		print("INTERN "),;
		printDecl(name, lineFeedBeforeName: true, bodyHint: body);
		print(" "),;
		print(body);
		print;
	}

	function enumerateNamesAndImplsForImpl(): {(string, NativeOperatorImpl)...} {
		for (local name, impl: enumerateNamesAndImpls()) {
			if (impl.impl.alias is none)
				yield (name, impl);
		}
	}

	@@Return default impls that must be mapped for @dep
	@@e.g. @(getDependencyMappings("tp_seq->tp_iter") == {("usrtype__iter", "tdefault__iter")})
	function getDependencyMappings(currentImpl: NativeOperatorImpl,
	                               dep: string): none | (string, {(string, string)...}) {
		local depTable, none, depField = dep.partition("->")...;
		local depName: NativeOperatorName = NativeOperatorName(
				table: depField ? depTable : none,
				field: depField ? depField : depTable);
		local natOp = NATIVE_OPERATORS.get(depName);
		if (natOp !is none) {
			@@Dependencies that we can assume to be present in the current context
			@@Any mapping of @dep that depends on only a sub-set of these doesn't
			@@have to be mapped
			local availableDependencies: {NativeOperatorName...} =
					List(currentImpl.dependencies);
			availableDependencies.append(name);
			local mappings: {(string, string)...} = [];
			for (local depName, depImpl/*: NativeOperatorImpl*/:
					natOp.enumerateNamesAndImpls()) {
				if (depImpl.impl.origImpl is none ||
				    depImpl.impl.origImpl.recontains(r"\bCALL_DEPENDENCY\b")) {
				}
				local missingDependencies = depImpl.dependencies
					.filter(e -> e !in availableDependencies);
				if (missingDependencies) {
					mappings.append((depName, natOp.typed.namePrefix + depName));
				}
			}
			local typedNatOp = natOp.typed;
			return (f"{typedNatOp.namePrefix}default__{typedNatOp.name.name}", mappings);
		}
		return none;
	}

	function doPrintNativeOperatorHintImpl(
			typedSymNames: {string...} | none = none): {string...} {
		local result = [];
		for (local i, symNameAndImpl: enumerateNamesAndImplsForImpl().enumerate()) {
			local symName, impl = symNameAndImpl...;
			local typedName: string | none = typedSymNames[i];
			local usedImpl: NativeMethodImpl = impl.impl;
			if (typedName !is none) {
				usedImpl = copy usedImpl;
				local baseImplRaw: string = usedImpl.impl.strip();
				if (baseImplRaw.startswith("{") && baseImplRaw.endswith("}"))
					baseImplRaw = baseImplRaw[1:-1].strip();
				usedImpl.impl = f"\{\n"
					f"#ifdef __OPTIMIZE_SIZE__\n"
					f"	return {typedName}({tpSelfExpr}, {", ".join(params.each.name)});\n"
					f"#else /* __OPTIMIZE_SIZE__ */\n"
					f"{baseImplRaw.startswith("#") ? "" : "\t"}{baseImplRaw}\n"
					f"#endif /* __OPTIMIZE_SIZE__ */\n"
					f"\}";
			}
			function callDependency(dep: string, args...): string {
				if (typedName !is none)
					return f"(*{tpSelfExpr}->{dep})({", ".join(args)})";
				local fallbackName, mustMap = getDependencyMappings(impl, dep)...;
				if (!mustMap)
					return f"(*{tpSelfExpr}->{dep})({", ".join(args)})";
				return f"(*({"".join(
					for (local src, dst: mustMap)
						f"{tpSelfExpr}->{dep} == &{src} ? &{dst} : "
				)}&{fallbackName}))({tpSelfExpr}, {", ".join(args)})";
			}
			printInternImpl(symName, usedImpl, {
				"THIS_TYPE": tpSelfExpr,
				"CALL_DEPENDENCY": callDependency,
				"PRELOAD_DEPENDENCY": (dep) -> "", // TODO
				"IF_TYPED_ELSE": (ifTyped, ifNotTyped) ->
					typedName is none ? ifTyped : ifNotTyped,
				"DeeRT_ErrUnboundAttrCStr": (self, name) ->
					encode_DeeRT_ErrUnboundAttr(tpSelfExpr, self, name),
				"DeeRT_ErrTUnboundAttrCStr": (decl, self, name) ->
					encode_DeeRT_ErrTUnboundAttr(decl, self, name),
			});
			result.append(symName);
		}
		return result;
	}

	function printDefaultTypedCallforward(typelessParams: {NativeMethodParam...}) {
		printInternImpl(f"{namePrefix}default__{name.name}", NativeMethodImpl(
			f"\{\n\treturn (*{tpSelfExpr}->{name})({
				", ".join(typelessParams.each.name)
			});\n\}"
		));
	}

	function printNativeOperatorHintImpl() {
		print("/* ", name.locExpr, " */");
		local typedNames = typed.doPrintNativeOperatorHintImpl();
		if (hasGenericTypedImpl)
			typed.printDefaultTypedCallforward(params);
		doPrintNativeOperatorHintImpl(typedNames);
	}
}


@@All known method-hints
global METHOD_HINTS: {string: MethodHint} = Dict();
global NATIVE_METHOD_HINTS: {string: NativeMethod} = Dict();
global ANONYMOUS_METHOD_HINTS: {string: NativeMethod} = Dict();

@@Native (non-method-hint) operators
global NATIVE_OPERATORS: {NativeOperatorName: NativeOperator} = Dict();


function getAllMethodHintAttributesUncached(): {string...} {
	local result = [];
	for (local none, hint: METHOD_HINTS) {
		result.extend(hint.allAttributes);
	}
	return result;
}

function getAllMethodHintAttributes(): {string...} {
	static local result = getAllMethodHintAttributesUncached();
	return result;
}


function print_Dee_tmh_id() {
	RESET_PREFIX();
	print("/* !!! CAUTION !!! Method hint IDs are prone to arbitrarily change !!!");
	print(" *");
	print(" * Do not make use of these IDs if you're developing a DEX module and");
	print(" * wish to remain compatible with the deemon core across many version.");
	print(" * If that's what you're trying to accomplish, you should instead define");
	print(" * regular `tp_methods' with names recognized as method hints. */");
	print("enum Dee_tmh_id {");
	for (local none, hint: NATIVE_METHOD_HINTS) {
		print("	Dee_TMH_", hint.name, ",");
	}
	print("	Dee_TMH_COUNT");
	print("};");
}

function print_TMH_BYNAME() {
	local id = 0;
	for (local none, hint: NATIVE_METHOD_HINTS) {
		print("	", repr hint.name, ": ", id, ",");
		++id;
	}
}

function print_TNO_BYNAME() {
	RESET_PREFIX();
	local id = 0;
	local delta = "";
	local ppCond = "1";
	local ppCondCount = 0;
	for (local none, method: NATIVE_OPERATORS) {
		if (method.ppCond != ppCond) {
			if (method.ppCond == "1") {
				local desc = ppCond
						.replace(" ", "")
						.replace("(", "_")
						.replace(")", "_")
						.replace("&&", "_and_")
						.replace("|", "_or_")
						.replace("!", "n");
				if (desc.startswith("n")) {
					desc = desc[1:];
				} else {
					desc = "n" + desc;
				}
				delta += f" - if__{desc}__then__{ppCondCount}";
			}
			ppCond = method.ppCond;
			ppCondCount = 0;
		}
		print("	", repr method.name.name, ": ", id, delta, ","),;
		if (method.ppCond != "1")
			print(" /* #if ", method.ppCond, " */"),;
		print;
		++id;
		++ppCondCount;
	}
}

function printMHTypedefs() {
	RESET_PREFIX();
	for (local none, hintAttr: METHOD_HINTS) {
		if (hintAttr.nativeHints) {
			print(f"/* {hintAttr.nameComment} */");
			for (local none, native: hintAttr.nativeHints)
				native.printMHTypedef();
			print;
		}
	}

	if (ANONYMOUS_METHOD_HINTS) {
		print("/* Anonymous method hints */");
		for (local none, hint: ANONYMOUS_METHOD_HINTS)
			hint.printMHTypedef();
	}
}

function printMethodAttributeDecls() {
	RESET_PREFIX();
	for (local none, hint: METHOD_HINTS)
		hint.printMethodAttributeDecls();
}

function printMethodAttributeImpls() {
	RESET_PREFIX();
	for (local none, hint: METHOD_HINTS)
		hint.printMethodAttributeImpls();
}

function printMethodHintDefs() {
	RESET_PREFIX();
	for (local none, hint: METHOD_HINTS) {
		print(f"Dee_DEFINE_TYPE_METHOD_HINT_{hint.kw ? "KW" : ""}METHOD({hint.name}, {repr hint.attr}, {repr hint.doc})");
		for (local alias: hint.aliases)
			print(f"Dee_DEFINE_TYPE_METHOD_HINT_ALIAS({alias.name}, {repr alias.attr}, {hint.name})");
		for (local none, native: hint.nativeHints) {
			print(f"Dee_DEFINE_TYPE_METHOD_HINT_FUNC({
				native.getReturnAttrib("_T")
			}, {native.returnType}, {native.cc}, {native.name}, ({
				", ".join(native.params.each.Cstr)
			}))");
		}
		print;
	}

	if (ANONYMOUS_METHOD_HINTS) {
		print("/* Anonymous method hints */");
		for (local none, native: ANONYMOUS_METHOD_HINTS) {
			print(f"Dee_DEFINE_TYPE_METHOD_HINT_FUNC({
				native.getReturnAttrib("_T")
			}, {native.returnType}, {native.cc}, {native.name}, ({
				", ".join(native.params.each.Cstr)
			}))");
		}
	}
}

function printDefaultImplDecls() {
	RESET_PREFIX();
	for (local none, native: NATIVE_METHOD_HINTS)
		native.printDefaultImplDecls();
}

function printDefaultImpls() {
	RESET_PREFIX();
	for (local none, native: NATIVE_METHOD_HINTS)
		native.printDefaultImpls();
}

function printTypedDefaultImpls() {
	RESET_PREFIX();
	for (local none, native: NATIVE_METHOD_HINTS)
		native.printTypedDefaultImpls();
}

function printMhCacheNativeMembers() {
	RESET_PREFIX();
	for (local none, native: NATIVE_METHOD_HINTS)
		native.printMhCacheNativeMember();
}

function getAllMhCacheAttributeMembers(): {string...} {
	for (local none, hint: METHOD_HINTS)
		yield hint.getMhCacheAttributeMembers()...;
}

function printMhCacheAttributeMembers() {
	RESET_PREFIX();
	local all = List(getAllMhCacheAttributeMembers());
	print("#define MHC_COUNT ", #all);
	if (all) {
		for (local name: all) {
			if (name == all.first)
				print("#define MHC_FIRST ", name);
			print("\tDee_mhc_slot_t ", name, ";");
			if (name == all.last)
				print("#define MHC_LAST ", name);
		}
	}
}

@@Generate prototypes for use with `mh_init_select_t`
function printMhInitSelectDecls() {
	RESET_PREFIX();
	for (local none, native: NATIVE_METHOD_HINTS) {
		if (native.selectImpl is none)
			continue;
		print(f"INTDEF ATTR_PURE WUNUSED NONNULL((1, 2)) DeeMH_{native.name}_t DCALL mh_select_{
				native.name}(DeeTypeObject *self, DeeTypeObject *orig_type);");
	}
}

function printMhInitSelectImpls() {
	RESET_PREFIX();
	for (local none, native: NATIVE_METHOD_HINTS) {
		if (native.selectImpl !is none)
			native.printMhInitSelectImpl();
	}
}

function printMhInitSpecs() {
	RESET_PREFIX();
	/* Start by printing secondary-attribute specs. */
	for (local none, native: NATIVE_METHOD_HINTS) {
		local methodHint: MethodHint | none = native.methodHint;
		if (methodHint.aliases) {
			print(f"PRIVATE struct mh_init_spec_secondary_attrib tpconst mh_secondary_{
					native.name}[{#methodHint.aliases + 1}] = \{");
			for (local alias: methodHint.aliases) {
				print("	MH_INIT_SPEC_SECONDARY_ATTRIB_INIT("),;
				print("&str_", alias.attr, ", "),;
				if (alias.baseClass is none) {
					print("NULL, Dee_SEQCLASS_UNKNOWN, "),;
				} else if (alias.baseClass == "DeeSeq_Type") {
					print("NULL, Dee_SEQCLASS_SEQ, "),;
				} else if (alias.baseClass == "DeeSet_Type") {
					print("NULL, Dee_SEQCLASS_SET, "),;
				} else if (alias.baseClass == "DeeMapping_Type") {
					print("NULL, Dee_SEQCLASS_MAP, "),;
				} else {
					print("&", alias.baseClass, ", Dee_SEQCLASS_UNKNOWN, "),;
				}
				print(f"&default__{native.name}__with_callattr_{alias.attr}),",);
			}
			print("	MH_INIT_SPEC_SECONDARY_ATTRIB_END");
			print(f"\};");
		}
		if (native.usingImpls) {
			print(f"PRIVATE struct mh_init_using tpconst mh_using_{
					native.name}[{#native.usingImpls + 1}] = \{");
			for (local dependencies, none: native.usingImpls) {
				local name = native.getUsingImplName(dependencies);
				local deps = Tuple(for (local x: dependencies) f"Dee_TMH_{x}");
				local dep1 = #deps >= 1 ? deps[0] : "Dee_TMH_COUNT";
				local dep2 = #deps >= 2 ? deps[1] : "Dee_TMH_COUNT";
				if (#deps >= 3) {
					throw Error(f"Max 2 dependencies are supported for using-method-hints, but {
							repr name} has {#deps}");
				}
				print(f"	MH_INIT_USING_INIT(&{name}, {dep1}, {dep2}),");
			}
			print("	MH_INIT_USING_END");
			print("};");
		}
		if (native.operatorSpecs) {
			local ops: {(OperatorSpec, NativeOperator)...} = (
				for (local spec: native.operatorSpecs)
					(spec, NATIVE_OPERATORS[NativeOperatorName(
						table: spec.operatorTable,
						field: spec.operatorField)])
			).cached;
			local lines: {string...} = [];
			local linePpCond: {string: string} = Dict();
			for (local spec, op: ops) {
				local seqClass;
				if (spec.baseClass is none || spec.acceptAnyBaseClassForMethodHint) {
					seqClass = "NULL, Dee_SEQCLASS_UNKNOWN";
				} else if (spec.baseClass == "DeeSeq_Type") {
					seqClass = "NULL, Dee_SEQCLASS_SEQ";
				} else if (spec.baseClass == "DeeSet_Type") {
					seqClass = "NULL, Dee_SEQCLASS_SET";
				} else if (spec.baseClass == "DeeMapping_Type") {
					seqClass = "NULL, Dee_SEQCLASS_MAP";
				} else {
					seqClass = f"&{spec.baseClass}, Dee_SEQCLASS_UNKNOWN";
				}
				local line = f"MH_INIT_SPEC_OPERATOR_INIT({op.name.TNO_id}, {seqClass})";
				if (op.ppCond != "1") {
					local oldCond = linePpCond.get(line);
					local newCond = oldCond is none ? op.ppCond : f"{oldCond} || {op.ppCond}";
					linePpCond[line] = newCond;
				}
				if (line !in lines)
					lines.append(line);
			}
			print(f"PRIVATE struct mh_init_spec_operator tpconst mh_operators_{
					native.name}[{linePpCond ? "" : (#ops + 1)}] = \{");
			local ppCondPrinter = PPCondPrinter();
			for (local line: lines) {
				ppCondPrinter.setPPCond(linePpCond.get(line, "1"));
				print("\t", line, ",");
			}
			ppCondPrinter.setPPCond();
			print("	MH_INIT_SPEC_OPERATOR_END");
			print("};");
		}
	}
	print(f"INTERN_TPCONST struct mh_init_spec tpconst mh_init_specs[{#NATIVE_METHOD_HINTS}] = \{");
	for (local none, native: NATIVE_METHOD_HINTS) {
		local methodHint: MethodHint | none = native.methodHint;
		print("	MH_INIT_SPEC_INIT("),;
		print(methodHint is none ? "NULL" : f"&str_{methodHint.attr}"),;
		print(", ", !methodHint.aliases ? "NULL" : f"mh_secondary_{native.name}"),;
		print(", ", !native.usingImpls ? "NULL" : f"mh_using_{native.name}"),;
		print(", ", !native.operatorSpecs ? "NULL" : f"mh_operators_{native.name}"),;
		print(", ", methodHint is none ? "NULL" :
			f"&default__{native.name}__with_callattr_{methodHint.attr}"),;
		print(", ", methodHint is none ? "0" : f"offsetof(struct Dee_type_mh_cache, mhc_{
			!methodHint.getset ? methodHint.attr :
				f"{native.getsetMember in ["bound", "tryget", ""] ? "get" : native.getsetMember}_{methodHint.attr}"
		})"),;
		print(", "),;
		if (!methodHint.getset || !native.getsetMember) {
			print("MH_KIND_METHOD"),;
		} else {
			local getsetType = native.getsetMember in ["get", "tryget", ""]
				? native.returnType
				: native.getsetMember == "set"
					? native.params.last.cTypeSimplified
					: "DeeObject*";
			if (getsetType.endswith("*")) {
				print(f"MH_KIND_GETSET_{native.getsetMember.upper()}"),;
			} else if (getsetType in ["size_t"]) {
				print(f"MH_KIND_GETSET_SZ_{native.getsetMember.upper()}"),;
			} else {
				throw Error(f"Unsupported getset return type {repr getsetType}");
			}
		}
		print(", ", methodHint is none ? "NULL" : f"&default__{
				native.name}__with_callobjectcache_{methodHint.attr}"),;
		print(", ", native.selectImpl is none ? "NULL" : f"&mh_select_{native.name}"),;
		print("),");
	}
	print("};");

}

function printMhUnsupportedArrayMembers() {
	RESET_PREFIX();
	for (local none, native: NATIVE_METHOD_HINTS) {
		if (native.unsupportedImpl !is none) {
			print(f"	(Dee_funptr_t)&default__{native.name}__unsupported,");
		} else {
			print(f"	NULL,");
		}
	}
}

function printNativeOperatorIds() {
	RESET_PREFIX();
	local ppCondPrinter = PPCondPrinter();
	for (local none, method: NATIVE_OPERATORS) {
		ppCondPrinter.setPPCond(method.ppCond);
		print("	", method.name.TNO_id, ",");
	}
	ppCondPrinter.setPPCond();
}

function printNativeOperatorTypes() {
	RESET_PREFIX();
	local ppCondPrinter = PPCondPrinter();
	for (local none, method: NATIVE_OPERATORS) {
		ppCondPrinter.setPPCond(method.ppCond);
		method.printNativeOperatorTypedef();
	}
	ppCondPrinter.setPPCond();
}

function printNativeOperatorHintDecls() {
	RESET_PREFIX();
	local ppCondPrinter = PPCondPrinter();
	for (local none, method: NATIVE_OPERATORS) {
		ppCondPrinter.setPPCond(method.ppCond);
		method.printNativeOperatorHintDecl();
	}
	ppCondPrinter.setPPCond();
}

function printNativeOperatorHintImpls() {
	RESET_PREFIX();
	local ppCondPrinter = PPCondPrinter();
	for (local none, method: NATIVE_OPERATORS) {
		ppCondPrinter.setPPCond(method.ppCond);
		method.printNativeOperatorHintImpl();
	}
	ppCondPrinter.setPPCond();
}

function printNativeOperatorPathMacros() {
	RESET_PREFIX();
	local longestNameLength = NATIVE_OPERATORS.values.each.name.name.length > ...;
	local ppCondPrinter = PPCondPrinter();
	for (local none, method: NATIVE_OPERATORS) {
		ppCondPrinter.setPPCond(method.ppCond);
		local name = method.name;
		print("#define _Dee_TNO_PATH_", (name.name + "(_)").ljust(longestNameLength + 3), " ",
			name.table is none
				? f"PATH1(_, {name.field})"
				: f"PATH2(_, {name.table}, {name.field})");
	}
	ppCondPrinter.setPPCond();
}

function printNativeOperatorHintSpecs() {
	RESET_PREFIX();
	@@Native methods (from method hints) that have a bi-directional link to native operators
	local nativeMethodsByOperatorName:
			{NativeOperatorName: {(OperatorSpec, NativeMethod)...}} = Dict();
	for (local none, nativeMethod: NATIVE_METHOD_HINTS) {
		for (local operatorSpec/*: OperatorSpec*/: nativeMethod.operatorSpecs) {
			local operatorName = NativeOperatorName(
					table: operatorSpec.operatorTable,
					field: operatorSpec.operatorField);
			local impls: {(OperatorSpec, NativeMethod)...} =
					nativeMethodsByOperatorName.setdefault(operatorName, []);
			impls.append((operatorSpec, nativeMethod));
		}
	}
	function getInheritAsMappings(name: NativeOperatorName): {(string, string)...} {
		local methods: {(OperatorSpec, NativeMethod)...} | none =
			nativeMethodsByOperatorName.get(name);
		if (methods !is none) {
			local mapped: {string...} = HashSet();
			for (local none, method /*: NativeMethod*/: methods) {
				for (local dependencies, customImpl /*: NativeMethodImpl*/: method.usingImpls) {
					local customImplInheritAs: string | none = customImpl.inheritAs;
					if (customImplInheritAs !is none) {
						local customImplName = method.getUsingImplName(dependencies);
						if (mapped.insert(customImplName))
							yield (customImplName, customImplInheritAs);
					}
				}
				for (local customImplName, customImpl /*: NativeMethodImpl*/: method.customImpls) {
					local customImplInheritAs: string | none = customImpl.inheritAs;
					if (customImplInheritAs !is none && mapped.insert(customImplName))
						yield (customImplName, customImplInheritAs);
				}
			}
		}
	}


	local ppCondPrinter = PPCondPrinter();
	for (local name, method: NATIVE_OPERATORS) {
		if (method.usrtypeImpls) {
			ppCondPrinter.setPPCond(method.ppCond);
			print(f"PRIVATE struct oh_init_spec_class tpconst oh_class_{
					name.name}[{#method.usrtypeImpls + 1}] = \{");
			for (local impl/*: NativeOperatorImpl*/: method.usrtypeImpls) {
				local deps = Tuple(impl.dependencies.each.OPERATOR_name);
				local dep1 = #deps >= 1 ? deps[0] : "OPERATOR_USERCOUNT";
				local dep2 = #deps >= 2 ? deps[1] : "OPERATOR_USERCOUNT";
				local symName = method.nativeSymbolNameForUrstypeImpl(impl);
				if (#deps >= 3) {
					throw Error(f"Max 2 dependencies are supported for default operators, but {
							repr symName} has {#deps}");
				}
				print(f"	OH_INIT_SPEC_CLASS_INIT(&{symName}, {dep1}, {dep2}),");
			}
			print(f"	OH_INIT_SPEC_CLASS_END");
			print(f"\};");
		}
		if (method.impls) {
			ppCondPrinter.setPPCond(method.ppCond);
			print(f"PRIVATE struct oh_init_spec_impl tpconst oh_impls_{
					name.name}[{#method.impls + 1}] = \{");
			for (local impl/*: NativeOperatorImpl*/: method.impls) {
				local symName = method.nativeSymbolNameForImpl(impl);
				local deps = Tuple(impl.dependencies.each.TNO_id);
				local dep1 = #deps >= 1 ? deps[0] : "Dee_TNO_COUNT";
				local dep2 = #deps >= 2 ? deps[1] : "Dee_TNO_COUNT";
				if (#deps >= 3) {
					throw Error(f"Max 2 dependencies are supported for default operators, but {
							repr symName} has {#deps}");
				}
				if (dep2 == dep1)
					dep2 = "Dee_TNO_COUNT";
				if (impl.disliked) {
					if (dep2 != "Dee_TNO_COUNT") {
						throw Error(f"[[disliked]] impls can have at most 1 dependency, but {
								repr symName} has 2");
					}
					dep2 = dep1;
				}
				print(f"	OH_INIT_SPEC_IMPL_INIT(&{symName}, {dep1}, {dep2}),");
			}
			print(f"	OH_INIT_SPEC_IMPL_END");
			print(f"\};");
		}
		local nativeMethods: {(OperatorSpec, NativeMethod)...} | none =
				nativeMethodsByOperatorName.get(name);
		if (nativeMethods) {
			ppCondPrinter.setPPCond(method.ppCond);
			print(f"PRIVATE struct oh_init_spec_mhint tpconst oh_mhints_{
					name.name}[{#nativeMethods + 1}] = \{");
			for (local operatorSpec, nativeMethod: nativeMethods) {
				print("	OH_INIT_SPEC_MHINT_INIT(Dee_TMH_", nativeMethod.name, ", "),;
				if (operatorSpec.baseClass is none) {
					print("NULL, Dee_SEQCLASS_UNKNOWN"),;
				} else if (operatorSpec.baseClass == "DeeSeq_Type") {
					print("NULL, Dee_SEQCLASS_SEQ"),;
				} else if (operatorSpec.baseClass == "DeeSet_Type") {
					print("NULL, Dee_SEQCLASS_SET"),;
				} else if (operatorSpec.baseClass == "DeeMapping_Type") {
					print("NULL, Dee_SEQCLASS_MAP"),;
				} else {
					print("&", operatorSpec.baseClass, ", Dee_SEQCLASS_UNKNOWN"),;
				}
				print("),");
			}
			print("	OH_INIT_SPEC_MHINT_END");
			print("};");
			local inheritAsMappings: {(string, string)...} = getInheritAsMappings(name).cached;
			if (inheritAsMappings) {
				print(f"PRIVATE struct oh_init_inherit_as tpconst oh_inherit_{
						name.name}[{#inheritAsMappings + 1}] = \{");
				for (local optr, nptr: inheritAsMappings) {
					print("	OH_INIT_INHERIT_AS_INIT(&", optr, ", &", nptr, "),");
				}
				print("	OH_INIT_INHERIT_AS_END");
				print("};");
			}
		}
	}
	ppCondPrinter.setPPCond();
	print("INTERN_TPCONST struct oh_init_spec tpconst oh_init_specs[] = {");
	local longestNameLength = NATIVE_OPERATORS.keys.each.locExpr.length > ...;
	for (local name, method /*: NativeOperator*/: NATIVE_OPERATORS) {
		ppCondPrinter.setPPCond(method.ppCond);
		local nativeMethods: {(OperatorSpec, NativeMethod)...} | none =
				nativeMethodsByOperatorName.get(name);
		print("	/* ", name.locExpr.ljust(longestNameLength), " */ OH_INIT_SPEC_INIT("),;
		print(name.table is none ? "0" : f"offsetof(DeeTypeObject, {name.table})"),;
		print(f", offsetof({name.tableStruct}, {name.field}), "),;
		print(method.usrtypeImpls ? f"oh_class_{name.name}" : "NULL", ", "),;
		print(method.impls ? f"oh_impls_{name.name}" : "NULL", ", "),;
		print(nativeMethods ? f"oh_mhints_{name.name}" : "NULL", ", "),;
		print(getInheritAsMappings(name) ? f"oh_inherit_{name.name}" : "NULL"),;
		print("),");
	}
	ppCondPrinter.setPPCond();
	print("};");
}


function printTypeTnoSizeofTableCases() {
	RESET_PREFIX();
	local usedSubTables: {(string, string)...} = [];
	for (local name, none /*: NativeOperator*/: NATIVE_OPERATORS) {
		if (name.table !is none) {
			local pair = (name.table, name.tableStruct);
			if (pair !in usedSubTables)
				usedSubTables.append(pair);
		}
	}
	for (local table, tableStruct: usedSubTables) {
		print(f"	case offsetof(DeeTypeObject, {table}):");
		print(f"		return sizeof({tableStruct});");
	}
}


function printFreeAllocatedOperatorTables(self: string) {
	RESET_PREFIX();
	local usedSubTables: {(string, string)...} = [];
	for (local name, none /*: NativeOperator*/: NATIVE_OPERATORS) {
		if (name.table !is none) {
			local pair = (name.table, name.tableStruct);
			if (pair !in usedSubTables)
				usedSubTables.append(pair);
		}
	}
	for (local table, tableStruct: usedSubTables)
		print(f"	Dee_Free({self}->{table});");
}


function getCTypeMediumSimplified(typ: string, after: string = ""): string {
	local result = getCTypeSimplified(typ, after);
	if (result.endswith("*"))
		return "void*";
	return {
		"Dee_foreach_t": "void*",
		"Dee_foreach_pair_t": "void*",
		"Dee_hash_t": "Dee_ssize_t",
		"size_t": "Dee_ssize_t",
		"unsigned int": "int",
	}.get(result, result);
}

function getCTypeSuperSimplified(typ: string, after: string = ""): string {
	local result = getCTypeMediumSimplified(typ, after);
	return {
		"Dee_foreach_t": "void*",
		"Dee_foreach_pair_t": "void*",
		"Dee_ssize_t": "void*",
	}.get(result, result);
}



final class ErrorMethodKey {
	this = default;
	@@Return type, as per @getCTypeSimplified
	public member returnType: string;
	public member cc: string;
	@@Argument types, as per @getCTypeSimplified
	public member paramTypes: {string...};
	@@Expression to get the type of the "self"-argument
	@@(assuming that argument's name to be "self", and being the first argument)
	public member tpSelfExpr: string;
	@@Function body
	public member body: string;

	public printIntdefDecl(name: string) {
		print("INTDEF ", returnType),;
		if (!returnType.endswith("*"))
			print(" "),;
		print(cc, " ", name, "(", ", ".join(paramTypes), ");");
	}

	public printInternImpl(name: string) {
		print("INTERN ", returnType),;
		if (!returnType.endswith("*"))
			print(" "),;
		local firstParam = paramTypes.first;
		print(cc, " ", name, "(", firstParam),;
		if (!firstParam.endswith("*"))
			print(" "),;
		print(body.recontains(r"\bself\b") ? "self" : "UNUSED(self)"),;
		print("".join(
			for (local i, x: paramTypes.enumerate()[1:])
				f", {x}{x.endswith("*") ? "" : " "}UNUSED(arg{i})"
		), ") ", body),;
		print;
	}

	public printIntdefDeclAndAliases(ppCondPrinter: PPCondPrinter, impl: bool,
	                                 namesAndPPCond: {(string, string)...}) {
		if (!namesAndPPCond)
			return;
		local primary = none;
		local primaryPPCond = "1";
		for (local alias, ppCond: namesAndPPCond) {
			if (ppCond == "1") {
				primary = alias;
				break;
			}
		}
		if (primary is none) {
			primaryPPCond = " || ".join(Sequence
					.distinct(namesAndPPCond.each.last)
					.frozen
					.filter(e -> e != "1")
					.sorted());
			primary = namesAndPPCond.first.first;
		}
		ppCondPrinter.setPPCond(primaryPPCond);
		if (impl) {
			printInternImpl(primary);
		} else {
			printIntdefDecl(primary);
			for (local alias, ppCond: namesAndPPCond) {
				if (alias != primary) {
					ppCondPrinter.setPPCond(ppCond);
					print("#define ", alias, " ", primary);
				}
			}
		}
	}
}

@@param decls: When true, print decls (and aliases) for error functions; else, print their impls
function printNativeOperatorHintErrorImpls(decls: bool) {
	RESET_PREFIX();
	@@Mapping of required functions, to the names under which they must be provided
	local requiredFunctions: {ErrorMethodKey: {(string, string)...}} = Dict();
	function addKey(key: ErrorMethodKey, name: string, ppCond: string = "1") {
		requiredFunctions.setdefault(key, []).append((name, ppCond));
	}
	function makeBodyWithMinus1Expr(key: ErrorMethodKey, expr: string): string {
		if (key.returnType.endswith("*")) {
			return
				f"\{\n"
				f"	{expr};\n"
				f"	return NULL;\n"
				f"\}";
		} else if (key.returnType in ["Dee_ssize_t", "int"]) {
			return
				f"\{\n"
				f"	return {expr};\n"
				f"\}";
		} else {
			return
				f"\{\n"
				f"	return ({key.returnType}){expr};\n"
				f"\}";
		}
	}
	for (local none, nativeOperator /*: NativeOperator*/: NATIVE_OPERATORS) {
		function makeKey(includeTpSelfExpr: bool): ErrorMethodKey {
			return ErrorMethodKey(
					returnType: getCTypeMediumSimplified(nativeOperator.returnType),
					cc: nativeOperator.cc,
					paramTypes: includeTpSelfExpr ? Tuple({
						nativeOperator.params.first.cTypeSimplified,
						(
							for (local x: nativeOperator.params[1:])
								getCTypeSuperSimplified(x.typ, x.typAfter)
						)...
					}) : (
						for (local x: nativeOperator.params)
								getCTypeSuperSimplified(x.typ, x.typAfter)
					).frozen,
					tpSelfExpr: includeTpSelfExpr
						? nativeOperator.tpSelfExpr.rereplace(
							f"\\b{nativeOperator.params.first.name}\\b", "self")
						: "");
		}
		if (nativeOperator.name.table && !nativeOperator.customBadAllocImplName) {
			local sizeofExpr = f"sizeof({nativeOperator.name.tableStruct})";
			local key: ErrorMethodKey = makeKey(false);
			key.body = makeBodyWithMinus1Expr(key, f"Dee_BadAlloc({sizeofExpr})");
			addKey(key, f"default__{nativeOperator.name.name}__badalloc", nativeOperator.ppCond);
		}
		if (nativeOperator.operatorName && !nativeOperator.customUnsupportedImplName) {
			/* Need a fallback for "_DeeType_GetNativeOperatorUnsupported" */
			local key: ErrorMethodKey = makeKey(true);
			key.body = makeBodyWithMinus1Expr(key, f"err_unimplemented_operator({
					key.tpSelfExpr}, {nativeOperator.operatorName})");
			addKey(key, f"_default__{nativeOperator.name.name}__unsupported", nativeOperator.ppCond);
		}
	}

	// TODO: More functions can be re-used under "#ifdef DCALL_CALLER_CLEANUP"
	local ppCondPrinter = PPCondPrinter();
	if (decls) {
		for (local key, namesAndPPCond: requiredFunctions)
			key.printIntdefDeclAndAliases(ppCondPrinter, false, namesAndPPCond);
		local longestNameLength = NATIVE_OPERATORS.values.each.name.name.length > ...;
		for (local none, nativeOperator /*: NativeOperator*/: NATIVE_OPERATORS) {
			if (nativeOperator.operatorName && !nativeOperator.customUnsupportedImplName) {
				ppCondPrinter.setPPCond(nativeOperator.ppCond);
				print("#define default__", (nativeOperator.name.name + "__unsupported").ljust(
					longestNameLength + #"__unsupported"),
					" (*(DeeNO_", nativeOperator.name.name, "_t)&"
					"_default__", nativeOperator.name.name, "__unsupported)");
			}
		}
	} else {
		for (local key, namesAndPPCond: requiredFunctions)
			key.printIntdefDeclAndAliases(ppCondPrinter, true, namesAndPPCond);
	}
	ppCondPrinter.setPPCond();
}

function printNativeOperatorHintBadAllocTable() {
	RESET_PREFIX();
	local longestNameLength = NATIVE_OPERATORS.values.each.name.name.length > ...;
	local ppCondPrinter = PPCondPrinter();
	for (local none, nativeOperator /*: NativeOperator*/: NATIVE_OPERATORS) {
		ppCondPrinter.setPPCond(nativeOperator.ppCond);
		print(f"	/* {f"[Dee_TNO_{nativeOperator.name.name}]".ljust(longestNameLength + 10)} = */ "),;
		if (nativeOperator.customBadAllocImplName) {
			print(f"(Dee_funptr_t)&{nativeOperator.customBadAllocImplName},");
		} else if (nativeOperator.name.table) {
			print(f"(Dee_funptr_t)&default__{nativeOperator.name.name}__badalloc,");
		} else {
			print(f"NULL,");
		}
	}
	ppCondPrinter.setPPCond();
}

function printNativeOperatorHintUnsupportedTable() {
	RESET_PREFIX();
	local longestNameLength = NATIVE_OPERATORS.values.each.name.name.length > ...;
	local ppCondPrinter = PPCondPrinter();
	for (local none, nativeOperator /*: NativeOperator*/: NATIVE_OPERATORS) {
		ppCondPrinter.setPPCond(nativeOperator.ppCond);
		print(f"	/* {f"[Dee_TNO_{nativeOperator.name.name}]".ljust(longestNameLength + 10)} = */ "),;
		if (nativeOperator.customUnsupportedImplName) {
			if (nativeOperator.customUnsupportedImplName == "NULL") {
				print(f"NULL,");
			} else {
				print(f"(Dee_funptr_t)&{nativeOperator.customUnsupportedImplName},");
			}
		} else if (nativeOperator.operatorName) {
			print(f"(Dee_funptr_t)&default__{nativeOperator.name.name}__unsupported,");
		} else {
			print(f"NULL,");
		}
	}
	ppCondPrinter.setPPCond();
}

@@Call like @printProxyObjectMethodHintWrapper("seq_operator_bool")
@@
@@prints:
@@> INTDEF WUNUSED NONNULL((1)) int DCALL generic_proxy__seq_operator_bool(ProxyObject *__restrict self); /* DeeObject_InvokeMethodHint(self->po_obj, seq_operator_bool) */
function printProxyObjectMethodHintWrapper(hintName: string, impl: bool = false) {
	local wrapperName = f"generic_proxy__{hintName}";
	RESET_PREFIX();
	local nativeMethod: NativeMethod = NATIVE_METHOD_HINTS[hintName];
	print(impl ? "INTERN" : "INTDEF", " "),;
	local attrib = nativeMethod.getReturnAttrib();
	if (attrib)
		print(attrib, " "),;
	print nativeMethod.returnType,;
	if (impl) {
		if (nativeMethod.cc) {
			if (!nativeMethod.returnType.endswith("*"))
				print " ",;
			print nativeMethod.cc,;
		}
		print;
	} else {
		if (!nativeMethod.returnType.endswith("*"))
			print " ",;
		if (nativeMethod.cc)
			print(nativeMethod.cc, " "),;
	}
	print(wrapperName, "("),;
	local firstParam: NativeMethodParam = nativeMethod.params.first;
	print("ProxyObject *",
		"__restrict" in firstParam.typ ? "__restrict " : "",
		firstParam.name),;
	print("".join(
		for (local x: nativeMethod.params[1:].each.Cstr)
			f", {x}"
	)),;
	print(")"),;
	local implBody = f"DeeObject_InvokeMethodHint({hintName}, {firstParam.name}->po_obj{"".join(
		for (local x: nativeMethod.params[1:].each.name)
			f", {x}"
	)})";
	if (impl) {
		print("{");
		print(f"	return {implBody};");
		print("}");
	} else {
		print(f"; /* {implBody} */");
	}
}

function printNativeOperatorExportedApi() {
	RESET_PREFIX();
	local ppCondPrinter = PPCondPrinter();
	for (local isTyped: {false, true}) {
		for (local none, nativeOperator /*: NativeOperator*/: NATIVE_OPERATORS) {
			local name = nativeOperator.operatorExportNames[isTyped];
			if (name is none)
				continue;
			ppCondPrinter.setPPCond(nativeOperator.ppCond);
			local usedOperator = isTyped ? nativeOperator.typed : nativeOperator;
			print("PUBLIC "),;
			if (!isTyped)
				print("ATTR_HOT "),;
			usedOperator.printDecl(name, lineFeedBeforeName: true, parenAroundName: true);
			local opName = usedOperator.name.name;
			local opVarName = f"tp_{opName}";
//			local opVarName = opName in {"bool", "int", "double"} ? f"{opName}_" : opName;
			local oomImplName: string | none = !isTyped ? none :
				nativeOperator.customBadAllocImplName
				? f"(DeeNO_{opName}_t)&{nativeOperator.customBadAllocImplName}"
				: usedOperator.name.table !is none
					? f"(DeeNO_{opName}_t)&default__{usedOperator.name.name}__badalloc"
					: none;
			local unsupImplName: string | none = !isTyped ? none :
				nativeOperator.customUnsupportedImplName
				? f"(DeeNO_{opName}_t)&{nativeOperator.customUnsupportedImplName}"
				: usedOperator.operatorName
					? f"(DeeNO_{opName}_t)&default__{usedOperator.name.name}__unsupported"
					: none;
			local fastForwardImpls = {oomImplName, unsupImplName}
				.filter(e -> e !is none)
				.distinct()
				.sorted()
				.frozen;
			local mustMapFunptr = isTyped && nativeOperator.hasMakeTypedMacro;
			if (!mustMapFunptr)
				fastForwardImpls = ();
			print(f" \{");
			print(f"	__register DeeNO_{opName}_t {opVarName};");
			local tpSelfExpr = usedOperator.tpSelfExpr;
			if (tpSelfExpr.startswith("Dee_TYPE(") && tpSelfExpr.endswith(")")) {
				print(f"	__register DeeTypeObject *tp_self = {tpSelfExpr};");
				tpSelfExpr = "tp_self";
			}
			if (usedOperator.exportPrecheck)
				print(usedOperator.exportPrecheck);
			print(f"	if unlikely("),;
			if (usedOperator.name.table !is none)
				print(f"!{tpSelfExpr}->{usedOperator.name.table} || "),;
			print(f"({opVarName} = {tpSelfExpr}->{usedOperator.name.locExpr}) == NULL)"),;
			print(fastForwardImpls ? f" \{" : "");
			print(f"		{opVarName} = _DeeType_RequireNativeOperator({tpSelfExpr}, {opName});");
			if (fastForwardImpls) {
				/* vvv these checks are needed because `maketyped__{xxx}'
				 *     can't handle signaling (badalloc / unsupported) impls */
				print(f"		if unlikely({
					" ||\n\t\t            ".join(
						fastForwardImpls.map(e -> f"{opVarName} == {e}"))
				})");
				local usedFunPtr = opVarName;
				/* vvv doing this would be totally fine, but it creates an unsuppressable warning
				 *     when compiling using GCC: "function called through a non-compatible type"
				 *     Obviously, this is total garbage, since the types *ARE* binary-compatible,
				 *     but what do I know... */
				//if (#fastForwardImpls == 1)
				//	usedFunPtr = fastForwardImpls.first;
				print(f"			return (*{usedFunPtr})({
					", ".join(nativeOperator.params.each.name)
				});");
				print(f"	\}");
			}
			print(f"	return (*{mustMapFunptr
				? f"maketyped__{opName}({opVarName})"
				: opVarName
			})({
				", ".join((mustMapFunptr ? usedOperator : nativeOperator).params.each.name)
			});");
			print(f"\}");
			print;
		}
	}
	ppCondPrinter.setPPCond();
}


@@Print the initializer of a "struct Dee_type_mh_cache" where all
@@hints are implemented using their @("$" + impl) variant. Method
@@hints that don't have such a variant are intialized to `NULL`
function printSpecialTypeMhCacheBody(impl: string | {string...}) {
	if (impl is string)
		impl = {impl};
	RESET_PREFIX();
	local longestNameLength = NATIVE_METHOD_HINTS.keys.each.length > ...;
	for (local name, nativeMethod /*: NativeMethod*/: NATIVE_METHOD_HINTS) {
		local customImplName: string | none = none;
		for (local implName: impl) {
			implName = nativeMethod.normalizeSymbolName(implName);
			local customImpl: NativeMethodImpl | none = nativeMethod.customImpls.get(implName);
			if (customImpl !is none) {
				customImplName = implName;
				break;
			}
		}
		print(f"	/* .mh_{name.ljust(longestNameLength)} = */ ",
			customImplName is none ? "NULL" : f"&{customImplName}",
			",");
	}
}


@@Print decls/impls of method hint impls for the built-in "Super" type
function printSuperMethodHintWrappers(impl: bool) {
	for (local name, nativeMethod /*: NativeMethod*/: NATIVE_METHOD_HINTS) {
		if (nativeMethod.unsupportedImpl is none)
			continue; /* Only possible for methods with an "%{unsupported}" impl */
		local attrib = nativeMethod.getReturnAttrib();
		print(impl ? "INTERN" : "INTDEF", " "),;
		if (attrib)
			print(attrib, " "),;
		print nativeMethod.returnType,;
		if (impl) {
			if (nativeMethod.cc) {
				if (!nativeMethod.returnType.endswith("*"))
					print " ",;
				print nativeMethod.cc,;
			}
			print;
		} else {
			if (!nativeMethod.returnType.endswith("*"))
				print " ",;
			if (nativeMethod.cc)
				print(nativeMethod.cc, " "),;
		}
		local firstParam: NativeMethodParam = copy nativeMethod.params.first;
		firstParam.typ = firstParam.typ.replace("DeeObject", "DeeSuperObject");
		local usedParams: {NativeMethodParam...} = { firstParam, nativeMethod.params[1:]... }.frozen;
		print("super_mh__", name, "(", ", ".join(usedParams.each.Cstr), ")"),;
		if (!impl) {
			print(";");
		} else {

			/* Check if the database is able to return "Dee_SUPER_METHOD_HINT_CC_WITH_SUPER" */
			local needWithSuper = false;
			for (local none, impl/*: NativeMethodImpl*/: nativeMethod.allImpls) {
				if (impl.acceptsSuperAsSelf) {
					needWithSuper = true;
					break;
				}
			}

			/* Check if the database is able to return "Dee_SUPER_METHOD_HINT_CC_WITH_TYPE" */
			local needWithTyped = nativeMethod.hasTypedCallAttrCacheImpl;
			if (!needWithTyped) {
				for (local operatorSpec/*: OperatorSpec*/: nativeMethod.operatorSpecs) {
					local operatorName: NativeOperatorName = NativeOperatorName(
							table: operatorSpec.operatorTable,
							field: operatorSpec.operatorField);
					local nativeOperator: NativeOperator | none =
							NATIVE_OPERATORS.get(operatorName);
					if (nativeOperator !is none && nativeOperator.hasMakeTypedMacro) {
						needWithTyped = true;
						break;
					}
				}
			}

			local selfArg = firstParam.name;
			local selfArgNInd = firstParam.typ.count("*");
			if (selfArgNInd >= 2)
				selfArg = f"({"*" * (selfArgNInd - 1)}{selfArg})";
			print(f" \{");
			print(f"	struct Dee_super_method_hint specs;");
			print(f"	DeeType_GetMethodHintForSuper({selfArg}, Dee_TMH_{name}, &specs);");
			print(f"	switch (specs.smh_cc) \{");
			if (selfArgNInd >= 2) {
				/* Inplace operator wrapper */
				print(f"	case Dee_SUPER_METHOD_HINT_CC_WITH_SELF: \{");
				print(f"		{nativeMethod.returnType} _res;");
				print(f"		DREF DeeObject *_self = {selfArg}->s_self;");
				print(f"		Dee_Incref(_self);");
				print(f"		_res = (*(DeeMH_{name}_t)specs.smh_cb)(&_self{
						"".join(for (local x: usedParams[1:].each.name) f", {x}")});");
				print(f"		return repack_super_after_inplace_{
						nativeMethod.returnType}(_res, _self, {firstParam.name});");
				print(f"	\}	break;");
			} else {
				print(f"	case Dee_SUPER_METHOD_HINT_CC_WITH_SELF:");
				print(f"		return (*(DeeMH_{name}_t)specs.smh_cb)({selfArg}->s_self{
						"".join(for (local x: usedParams[1:].each.name) f", {x}")});");
			}
			if (needWithSuper) {
				print(f"	case Dee_SUPER_METHOD_HINT_CC_WITH_SUPER:");
				local firstType = nativeMethod.params.first.fullTypWithoutRestrict;
				if (firstType == "DeeObject *") {
					print(f"		return (*(DeeMH_{name}_t)specs.smh_cb)(Dee_AsObject({
							usedParams.first.name}){
							"".join(for (local x: usedParams[1:]) ", " + x.name)});");
				} else {
					print(f"		return (*(DeeMH_{name}_t)specs.smh_cb)(({
							firstType}){", ".join(usedParams.each.name)});");
				}
			} else {
				print(f"/*	case Dee_SUPER_METHOD_HINT_CC_WITH_SUPER: // Unused */");
			}

			if (needWithTyped) {
				function printTypedCallbackPointer() {
					print("(*("),;
					print nativeMethod.returnType,;
					if (!nativeMethod.returnType.endswith("*"))
						print " ",;
					print("("),;
					if (nativeMethod.cc)
						print(nativeMethod.cc, " "),;
					print("*)(DeeTypeObject *"),;
					print("".join(for (local x: nativeMethod.params.each.fullTypWithoutRestrict) f", {x}")),;
					print(")"),;
					print(")specs.smh_cb)"),;
				}

				if (selfArgNInd >= 2) {
					/* Inplace operator wrapper */
					print(f"	case Dee_SUPER_METHOD_HINT_CC_WITH_TYPE: \{");
					print(f"		{nativeMethod.returnType} _res;");
					print(f"		DREF DeeObject *_self = {selfArg}->s_self;");
					print(f"		Dee_Incref(_self);");
					print(f"		_res = "),;
					printTypedCallbackPointer();
					print(f"({selfArg}->s_type, &_self{
							"".join(for (local x: usedParams[1:].each.name) f", {x}")});");
					print(f"		return repack_super_after_inplace_{
							nativeMethod.returnType}(_res, _self, {firstParam.name});");
					print(f"	\}	break;");
				} else {
					print(f"	case Dee_SUPER_METHOD_HINT_CC_WITH_TYPE:");
					print(f"		return "),;
					printTypedCallbackPointer();
					print(f"({selfArg}->s_type, {selfArg}->s_self{
							"".join(for (local x: usedParams[1:].each.name) f", {x}")});");
				}
			} else {
				print(f"/*	case Dee_SUPER_METHOD_HINT_CC_WITH_TYPE: // Unused */");
			}
			print(f"	default: __builtin_unreachable();");
			print(f"	\}");
			print(f"	__builtin_unreachable();");
			print(f"\}");
			print;
		}
	}
}


@@Print the initializer for `super_mhcache`
function printSuperMethodHintCacheInitializer() {
	local longestNativeMethodHintNameLength = NATIVE_METHOD_HINTS.keys.each.length > ...;
	for (local name, nativeMethod /*: NativeMethod*/: NATIVE_METHOD_HINTS) {
		print(f"	/* .mh_{name.ljust(longestNativeMethodHintNameLength)} = */ "),;
		if (nativeMethod.unsupportedImpl is none) {
			print("NULL,");
		} else {
			print("(DeeMH_", name, "_t)&super_mh__", name, ",");
		}
	}
}

@@Print the definition of `mh_super_map` (and related support structures)
function printMhSuperMap() {
	local nativeMethodsWith__msm_replace: {string...} = HashSet();
	local nativeMethodsWith__msm_with_super: {string...} = HashSet();
	local nativeMethodsWith__msm_with_type: {string...} = HashSet();
	for (local name, nativeMethod /*: NativeMethod*/: NATIVE_METHOD_HINTS) {
		if (nativeMethod.unsupportedImpl is none)
			continue; /* Not needed */
		local allImpls: {(string, NativeMethodImpl)...} = Tuple(nativeMethod.allImpls);
		local replaceImpls: {string: string} = Dict();
		for (local name, impl: allImpls) {
			if (impl.inheritAs !is none)
				replaceImpls[name] = impl.inheritAs;
		}
		if (replaceImpls) {
			nativeMethodsWith__msm_replace.insert(name);
			print(f"PRIVATE struct mh_super_map_replace tpconst msm_replace__{
					name}[{#replaceImpls + 1}] = \{");
			for (local oldImpl, newImpl: replaceImpls)
				print(f"	MH_SUPER_MAP_REPLACE_INIT(&{oldImpl}, &{newImpl}),");
			print(f"	MH_SUPER_MAP_REPLACE_END");
			print(f"\};");
		}
		local superAsSelfImpls: {string...} = [];
		for (local name, impl: allImpls) {
			if (impl.acceptsSuperAsSelf)
				superAsSelfImpls.append(name);
		}
		if (superAsSelfImpls) {
			nativeMethodsWith__msm_with_super.insert(name);
			// TODO: This listing here also includes "$none" and "$empty" callbacks,
			//       even though it really doesn't need to. I could simply exclude
			//       those impls here by-name, but that doesn't feel generic enough...
			print(f"PRIVATE Dee_funptr_t tpconst msm_with_super__{
					name}[{#superAsSelfImpls + 1}] = \{");
			for (local impl: superAsSelfImpls)
				print(f"	(Dee_funptr_t)&{impl},");
			print(f"	NULL");
			print(f"\};");
		}

		/* Figure out typed-mappings */
		local typedImpls: {string: string} = Dict();
		local typedImplsPPCond: {string: string} = Dict();
		if (nativeMethod.hasTypedCallAttrCacheImpl) {
			local callCacheName = f"default__{
					nativeMethod.name}__with_callobjectcache_{
					nativeMethod.methodHint.attr}";
			typedImpls[callCacheName] = f"t{callCacheName}";
		}
		for (local operatorSpec/*: OperatorSpec*/: nativeMethod.operatorSpecs) {
			local operatorName: NativeOperatorName = NativeOperatorName(
					table: operatorSpec.operatorTable,
					field: operatorSpec.operatorField);
			local nativeOperator: NativeOperator | none =
					NATIVE_OPERATORS.get(operatorName);
			if (nativeOperator !is none) {
				local typelessSymbols: {string...} = nativeOperator
						.doPrintNativeOperatorHintDecl(true);
				local typedSymbols: {string...} = nativeOperator
						.typed.doPrintNativeOperatorHintDecl(true);
				for (local i, typelessSymbol: typelessSymbols.enumerate()) {
					local typedSymbol = typedSymbols[i];
					typedImpls[typelessSymbol] = typedSymbol;
					if (nativeOperator.ppCond != "1")
						typedImplsPPCond[typedSymbol] = nativeOperator.ppCond;
				}
			}
		}

		if (typedImpls) {
			nativeMethodsWith__msm_with_type.insert(name);
			print(f"PRIVATE struct mh_super_map_typed tpconst msm_with_type__{
					name}[{typedImplsPPCond ? "" : (#typedImpls + 1)}] = \{");
			local ppCondPrinter = PPCondPrinter();
			for (local regularImpl, typedImpl: typedImpls) {
				ppCondPrinter.setPPCond(typedImplsPPCond.get(typedImpl, "1"));
				print(f"	MH_SUPER_MAP_TYPED_INIT(&{regularImpl}, &{typedImpl}),");
			}
			ppCondPrinter.setPPCond();
			print(f"	MH_SUPER_MAP_TYPED_END");
			print(f"\};");
		}
	}
	print("PRIVATE struct mh_super_map tpconst mh_super_maps[", #NATIVE_METHOD_HINTS, "] = {");
	for (local name, nativeMethod /*: NativeMethod*/: NATIVE_METHOD_HINTS) {
		print(f"	MH_SUPER_MAP_INIT({
			name in nativeMethodsWith__msm_replace ? f"msm_replace__{name}" : "NULL"
		}, {
			name in nativeMethodsWith__msm_with_super ? f"msm_with_super__{name}" : "NULL"
		}, {
			name in nativeMethodsWith__msm_with_type ? f"msm_with_type__{name}" : "NULL"
		}),");
	}
	print("};");
}




final class WrappedName {
	this = default;
	public member name: string;
}

final class DependencyChain {
	this = default;
	public member length: int;

	@@The operator being assigned
	public member name: NativeOperatorName | WrappedName;

	@@The method to assign
	public member method: string;

	operator copy(other: DependencyChain) {
		length = other.length;
		name = other.name;
		method = other.method;
		before = copy other.before;
	}

	operator == (rhs: DependencyChain): bool -> length == rhs.length;
	operator != (rhs: DependencyChain): bool -> length != rhs.length;
	operator <  (rhs: DependencyChain): bool -> length <  rhs.length;
	operator <= (rhs: DependencyChain): bool -> length <= rhs.length;
	operator >  (rhs: DependencyChain): bool -> length >  rhs.length;
	operator >= (rhs: DependencyChain): bool -> length >= rhs.length;

	public addBefore(chain: DependencyChain) {
		length += chain.length;
		before.append(chain);
	}

	public property assignments: {(string, string)...} = {
		get(): {(string, string)...} {
			for (local x: before)
				yield x.assignments...;
			yield (name.name, method);
		}
	}

	@@Same as @assignments, but removes duplicate assignments
	@@(s.a. blurb in @OperatorImplChain._getLongestChainLength)
	public property optimizedAssignments: {(string, string)...} = {
		get(): {(string, string)...} {
			local result = [];
			for (local ass: assignments) {
				if (ass !in result)
					result.append(ass);
			}
			return result;
		}
	}

	public printRepr(indent: string = "") {
		for (local x: before)
			x.printRepr(">" + indent);
		print("/* >", indent, " ", name, " = &", method, " // ", length, " */");
	}

	@@Assignments that happen before @name is assigned
	public member before: {DependencyChain...} = [];
}

final class OperatorImplChain {
	this = default;
	@@This operator (e.g. "tp_cmp->tp_compare")
	public member name: NativeOperatorName | WrappedName;

	@@Ways in which this operator can be implemented
	@@>	{
	@@>		HashSet.Frozen({
	@@>			OperatorImplChain(name: "tp_cmp->tp_eq", using: ...),
	@@>			OperatorImplChain(name: "tp_cmp->tp_lo", using: ...),
	@@>		})
	@@>	}
	public member using: {{OperatorImplChain...}...} = [];

	function getLongestChainLength(): DependencyChain | none {
		return _getLongestChainLength(HashSet({}));
	}

	private _savedLongestChain: {
		HashSet with NativeOperatorName | WrappedName: DependencyChain
	} = Dict();

	function _getLongestChainLength(
			encountered: HashSet with NativeOperatorName | WrappedName
	): DependencyChain | none {
		/* This impl produces slightly sub-optimal results (since the returned chain
		 * only accounts for assignments that happened earlier within the chain, but
		 * not within sub-branches from earlier in the chain).
		 *
		 * However, this also keeps the # of possible initial "encountered" values
		 * lower, to the point where if we were to including accounting for sub-branch
		 * assignments, there would be such a high number of possible assignments,
		 * that the "_savedLongestChain" cache would become basically useless, and
		 * this function would (once again) take around 10 seconds each time hints
		 * are generated. */
		if (!encountered.insert(name))
			return none;
		local result: DependencyChain | none = _savedLongestChain.get(encountered);
		if (result !is none)
			return result;
		local template: DependencyChain = DependencyChain(
				1, name, f"default__{name.name}__with__");
		for (local dependencies: using) {
			local item: DependencyChain = copy template;
			item.method += "__and__".join(dependencies.each.name.name);
			for (local dependency: dependencies) {
				local dependencyChain: DependencyChain | none;
				try {
					dependencyChain = dependency._getLongestChainLength(encountered);
				} @[interrupt] catch (...) {
					print File.stderr: "HERE", name, " -> ", dependency.name;
					throw;
				}
				if (dependencyChain is none) {
					// item.assumePresent(dependency)
				} else {
					item.addBefore(dependencyChain);
				}
			}
			if (result is none || result < item)
				result = item;
		}
		if (result !is none)
			_savedLongestChain[copy encountered] = result;
		encountered.remove(name);
		return result;
	}
}

@@Prints the "Dee_TMH_USING_MAXLEN" macro
function print_TMH_USING_MAXLEN() {
	local chains: {WrappedName: OperatorImplChain} = Dict();
	function _getOperatorImplChain(name: string): OperatorImplChain {
		local nameKey = WrappedName(name);
		local result: OperatorImplChain | none = chains.get(nameKey);
		if (result is none)
			chains[nameKey] = result = OperatorImplChain(name: nameKey);
		return result;
	}
	for (local name, nativeMethodHint: NATIVE_METHOD_HINTS) {
		local chain = _getOperatorImplChain(name);
		for (local dependencies, impl /*: NativeMethodImpl*/: nativeMethodHint.usingImpls) {
			local deps = Tuple(dependencies.map(_getOperatorImplChain));
			if (deps)
				chain.using.append(deps);
		}
	}
	local longestChain = chains.values.each.getLongestChainLength() > ...;
	local assignments = longestChain.optimizedAssignments.cached;
	local longestAssignmentNameLength = assignments.each.first.length > ...;
	local isFirst = true;
	for (local i, _data: assignments.reversed().enumerate()) {
		local name, cb = _data...;
		print(i ? " * " : "/* ", f"\{ Dee_TMH_{
			(name + ",").ljust(longestAssignmentNameLength + 1)
		} &{cb} \}", i == (#assignments - 1) ? " */" : "");
	}
	print("#define Dee_TMH_USING_MAXLEN ", #assignments, " /* ", longestChain.length, " with duplicates */");
}

@@Prints the "Dee_TNO_ASSIGN_MAXLEN" macro
function print_TNO_ASSIGN_MAXLEN() {
	local chains: {NativeOperatorName: OperatorImplChain} = Dict();
	function _getOperatorImplChain(name: NativeOperatorName): OperatorImplChain {
		local result: OperatorImplChain | none = chains.get(name);
		if (result is none)
			chains[name] = result = OperatorImplChain(name: name);
		return result;
	}
	for (local name, nativeOperator: NATIVE_OPERATORS) {
		local chain = _getOperatorImplChain(name);
		for (local impl /*: NativeOperatorImpl*/: nativeOperator.impls) {
			local deps = Tuple(impl.dependencies.map(_getOperatorImplChain));
			if (deps)
				chain.using.append(deps);
		}
	}
	local longestChain = chains.values.each.getLongestChainLength() > ...;
	local assignments = longestChain.optimizedAssignments.cached;
	local longestAssignmentNameLength = assignments.each.first.length > ...;
	local isFirst = true;
	for (local i, _data: assignments.reversed().enumerate()) {
		local name, cb = _data...;
		print(i ? " * " : "/* ", f"\{ Dee_TNO_{
			(name + ",").ljust(longestAssignmentNameLength + 1)
		} &{cb} \}", i == (#assignments - 1) ? " */" : "");
	}
	print("#define Dee_TNO_ASSIGN_MAXLEN ", #assignments, " /* ", longestChain.length, " with duplicates */");
}

@@Print the initializer of `_DeeType_GetOperatorOfTno`
function printGetOperatorOfTnoInit() {
	RESET_PREFIX();
	local longestNameLength = NATIVE_OPERATORS.keys.each.TNO_id.length > ...;
	local ppCondPrinter = PPCondPrinter();
	for (local name, nativeOperator: NATIVE_OPERATORS) {
		ppCondPrinter.setPPCond(nativeOperator.ppCond);
		print(f"	/* {f"[{name.TNO_id}]".ljust(longestNameLength + 2)} = */ ",
			nativeOperator.operatorName ?: "OPERATOR_USERCOUNT", ",");
	}
	ppCondPrinter.setPPCond();
}


function captureStdout(cb: Callable): string {
	local newStdout = File.Writer();
	local oldStdout = File.stdout;
	File.stdout = newStdout;
	try {
		cb();
	} finally {
		File.stdout = oldStdout;
	}
	return newStdout.string;
}


final class _SpecParserAttrib {
	this = default;
	public member kw: bool = false;
	public member wunused: bool = false;
	public member disliked: bool = false;
	public member tpSelfExpr: string = "";
	public member exportPrecheck: string = "";
	public member nonnull: bool = false;
	public member getset: bool = false;
	public member getsetMember: string = "";
	public member docstring: string = "";
	public member noSelfInvocationWrapper: bool = false;
	public member attr: string | none = none;
	public member cc: string = "DCALL";
	public member aliases: {MethodHintAlias...} = [];
	public member declNameAliases: {string...} = [];
	public member prefix: {string...} = [];
	public member operatorSpecs: {OperatorSpec...} = [];
	public member customUnsupportedImplName: string = "";
	public member customBadAllocImplName: string = "";
	public member operatorExportNames: (string, string) | none = none;
	public member inheritAs: string | none = none;
	public member acceptAnyBaseClassForMethodHint: bool = false;
	public member ppCond: string = "1";
	public member extraMethodHintContext: {string...} | none = none;
};

global final _C_TYPENAME_TOKENS = HashSet.Frozen({
	"*", "const", "volatile", "DREF", "__restrict" });

final class _SpecParserFile {
	this = default;
	public member data: string;
	public member dataLen: int;
	public member filename: string;
	public member tokEnd: int = 0;
};

global final _ReCache: {string...} = HashSet();
#define RECACHE(x) _ReCache.unify(x)

final class _SpecParser {
	this = default;
	public member data: string;
	public member dataLen: int;
	public member filename: string;
	public member tokStart: int = 0;
	public member tokEnd: int = 0;
	public member tok: string = "";

	public saveParserContext() {
		return (data, dataLen, filename, tokStart, tokEnd, tok);
	}

	public restoreParserContext(context) {
		data, dataLen, filename, tokStart, tokEnd, tok = context...;
	}

	public next(): string {
		local i = tokEnd;
		local result;
again:
		tokStart = i;
		if (i >= dataLen) {
			i = dataLen;
			result = "";
			goto done;
		}
		local ch = data[i];
		++i;
		switch (ch) {

		case '"':
		case "'": {
			while (i < dataLen) {
				local ch2 = data[i];
				++i;
				if (ch2 == ch) {
					break;
				} else if (ch2 == '\\') {
					++i;
				}
			}
		}	break;

		case "/":
			if (data.startswith("*", i)) {
				i = data.index("*/", i + 1) + 2;
				goto again;
			} else if (data.startswith("/", i)) {
				i = data.find("\n", i) + 1;
				if (i <= 0)
					i = dataLen;
				goto again;
			}
			break;

		case "[":
		case "]":
			if (data.startswith(ch, i))
				++i;
			break;

		case "-":
			if (data.startswith(">", i))
				++i;
			break;

		default:
			if (ch.isspace())
				goto again;
			if (ch.issymcont()) {
				while (i < dataLen && data.issymcont(i))
					++i;
			}
			break;
		}
		result = data[tokStart:i];
done:
		tokEnd = i;
		tok = result;
		return result;
	}

	public property filenameForPPLine: string = {
		get(): string {
			return f"../src/deemon/method-hints/{filename.replace(r"\", r"/").rpartition("/").last}";
		}
	}

	public lineAt(pos: int): int {
		return data.count("\n", 0, pos) + 1;
	}

	public lcAt(pos: int): (int, int) {
		local line = data.count("\n", 0, pos) + 1;
		local col = pos - data.rfind("\n", 0, pos);
		return (line, col);
	}

	public err(message: string) {
		local l, c = lcAt(tokStart)...;
		print(filename, "(", l, ", ", c, ") : ", message);
		throw Error(message);
	}

	public require(expected: string | {string...}) {
		if (expected is string ? tok != expected : tok !in expected)
			err(f"Unexpected token {repr tok}; expected {repr expected}");
	}

	public skip(expected: string | {string...}): string {
		require(expected);
		return next();
	}

	public requireSymbol(): string {
		if (!tok.issymbol())
			err(f"Expected a symbol-token, but got '{tok}'");
		return tok;
	}

	public parseSymbol(): string {
		local result = requireSymbol();
		next();
		return result;
	}

	public property isstring: bool = {
		get() -> tok.startswith("'") || tok.startswith('"');
	};

	public requireString(): string {
		if (!isstring)
			err(f"Expected string, but got '{tok}'");
		return tok[1:-1].decode("c-escape");
	}

	public parseString(): string {
		local result = requireString();
		next();
		while (isstring)
			result += parseString();
		return result;
	}

	public member attrib: _SpecParserAttrib = _SpecParserAttrib();

	public parseTypename(): string {
		local result = parseSymbol();
		return BASE_CLASS_ALIASES.get(result, result);
	}

	public parseMethodHintAlias(): MethodHintAlias {
		local result: MethodHintAlias = MethodHintAlias();
		result.baseClass = parseTypename();
		skip(".");
		result.attr = parseSymbol();
		if (tok == "->") {
			result.nameAliases = [];
			next();
			for (;;) {
				result.nameAliases.append(parseString());
				if (tok != ",")
					break;
				next();
			}
		}
		return result;
	}

	public parseNativeMethodParam(): NativeMethodParam {
		resetContext();
		parseAttribs();
		requireSymbol();
		local paramTypeStart = tokStart;
		while (tok in _C_TYPENAME_TOKENS)
			next();
		do {
			next();
		} while (tok in _C_TYPENAME_TOKENS);
		local paramTypeEnd = tokStart;
		local paramType = data[paramTypeStart:paramTypeEnd].strip();
		local paramName = parseSymbol();
		local typAfter = "";
		if (tok == "[") {
			local typAfterStart = tokStart;
			next();
			local recursion = 0;
			while (tok) {
				if (tok == "]") {
					if (!recursion)
						break;
					--recursion;
				} else if (tok == "[") {
					++recursion;
				}
				next();
			}
			typAfter = data[typAfterStart:tokEnd];
			skip("]");
		}
		return NativeMethodParam(
				typ: paramType,
				name: paramName,
				nonnull: attrib.nonnull,
				typAfter: typAfter);
	}

	public parseAttribs() {
		while (tok == "[[") {
			next();
			parseAttrib();
			skip("]]");
		}
	}

	public parseFieldDesc(): string {
		local result = parseSymbol();
		for (;;) {
			if (tok == ".") {
				next();
				result = f"{result}.{parseSymbol()}";
				continue;
			}
			break;
		}
		return result;
	}

	public parseBaseClassList(): {string...} {
		if (tok == "[") {
			next();
			while (tok !in ["", "]"]) {
				yield parseTypename();
				if (tok != ",")
					break;
				next();
			}
			skip("]");
		} else {
			yield parseTypename();
		}
	}

	public parseOperatorSpecs(): {OperatorSpec...} {
		local result = OperatorSpec();
		local baseClasses;
		if (tok == "*") {
			baseClasses = none;
			next();
		} else {
			baseClasses = parseBaseClassList().frozen;
		}
		skip(":");
		local field = parseFieldDesc();
		if (tok == "->") {
			next();
			result.operatorTable = field;
			result.operatorField = parseFieldDesc();
		} else {
			result.operatorField = field;
		}
		result.acceptAnyBaseClassForMethodHint = attrib.acceptAnyBaseClassForMethodHint;
		if (baseClasses is none) {
			result.baseClass = none;
			yield result;
		} else {
			for (local baseClass: baseClasses) {
				result.baseClass = baseClass;
				yield copy result;
			}
		}
	}

	public parseAttrib() {
		while (tok && tok != "]]") {
			switch (tok) {
			case "kw":
			case "wunused":
			case "disliked":
			case "nonnull":
			case "getset": {
				local key = tok;
				next();
				attrib.operator . (key) = true;
			}	break;

			case "getset_member": {
				next();
				skip("(");
				local name = parseString();
				if (name !in ["get", "del", "set", "bound", "tryget"])
					err(f"Invalid getset member name {repr name}");
				skip(")");
				attrib.getsetMember = name;
			}	break;

			case "extra_method_hint_context": {
				next();
				skip("(");
				local name = parseString();
				skip(")");
				if (attrib.extraMethodHintContext is none)
					attrib.extraMethodHintContext = [];
				attrib.extraMethodHintContext.append(name);
			}	break;

			case "cc":
			case "attr": {
				local key = tok;
				next();
				skip("(");
				attrib.operator . (key) = parseSymbol();
				skip(")");
			}	break;

			case "prefix": {
				next();
				skip("(");
				local prefixStart = tokStart;
				local prefixEnd = data.findmatch("(", ")", prefixStart);
				if (prefixEnd < 0)
					err("Missing end-of-prefix attribute body");
				attrib.prefix.append(data[prefixStart:prefixEnd].strip());
				tokEnd = prefixEnd;
				next();
				skip(")");
			}	break;

			case "tp_self": {
				next();
				skip("(");
				local prefixStart = tokStart;
				local prefixEnd = data.findmatch("(", ")", prefixStart);
				if (prefixEnd < 0)
					err("Missing end-of-tp_self attribute body");
				attrib.tpSelfExpr = data[prefixStart:prefixEnd].strip();
				tokEnd = prefixEnd;
				next();
				skip(")");
			}	break;

			case "export_precheck": {
				next();
				skip("(");
				local prefixStart = tokStart;
				local prefixEnd = data.findmatch("(", ")", prefixStart);
				if (prefixEnd < 0)
					err("Missing end-of-export_precheck attribute body");
				attrib.exportPrecheck = data[prefixStart:prefixEnd].strip();
				tokEnd = prefixEnd;
				next();
				skip(")");
			}	break;

			case "custom_unsupported_impl_name":
				next();
				skip("(");
				attrib.customUnsupportedImplName = parseSymbol();
				skip(")");
				break;

			case "custom_badalloc_impl_name":
				next();
				skip("(");
				attrib.customBadAllocImplName = parseSymbol();
				skip(")");
				break;

			case "docstring":
				next();
				skip("(");
				attrib.docstring = parseString();
				skip(")");
				break;

			case "export": {
				next();
				skip("(");
				local desc: string = parseString();
				skip(")");
				function parseDescPosition(desc: string, position: int): string {
					local result = File.Writer();
					local flushStart = 0, i = 0;
					while (i < #desc) {
						i = desc.find("{", i);
						if (i < 0)
							break;
						local end: int = desc.findmatch("{", "}", i + 1);
						if (end < 0)
							break;
						local blob: string = desc[i + 1:end];
						result << desc[flushStart:i]
							<< (try blob.split("|")[position] catch (...) "");
						i = flushStart = end + 1;
					}
					result << desc[flushStart:];
					return result.string;
				}
				attrib.operatorExportNames = (
					parseDescPosition(desc, 0),
					parseDescPosition(desc, 1),
				);
			}	break;

			case "operator": {
				next();
				skip("(");
				attrib.operatorSpecs.extend(parseOperatorSpecs());
				skip(")");
			}	break;

			case "inherit_as": {
				next();
				skip("(");
				attrib.inheritAs = parseSymbol();
				skip(")");
			}	break;

			case "accept_any_base_class_for_method_hint":
				next();
				attrib.acceptAnyBaseClassForMethodHint = true;
				break;

			case "if": {
				next();
				skip("(");
				local prefixStart = tokStart;
				local prefixEnd = data.findmatch("(", ")", prefixStart);
				if (prefixEnd < 0)
					err("Missing end-of-prefix attribute body");
				attrib.ppCond = data[prefixStart:prefixEnd].strip();
				tokEnd = prefixEnd;
				next();
				skip(")");
			}	break;

			case "no_self_invocation_wrapper":
				next();
				attrib.noSelfInvocationWrapper = true;
				break;

			case "decl_name_alias": { // Unused
				next();
				skip("(");
				do {
					attrib.declNameAliases.append(parseString());
					if (tok != ",")
						break;
					next();
				} while (tok && tok != ")");
				skip(")");
			}	break;

			case "alias": {
				next();
				skip("(");
				do {
					attrib.aliases.append(parseMethodHintAlias());
					if (tok != ",")
						break;
					next();
				} while (tok && tok != ")");
				skip(")");
			}	break;

			default:
				err(f"Unknown attribute: {repr tok}");
			}
			if (tok != ",")
				break;
			next();
		}
	}

	public parseNativeMethodAlias(method: NativeMethod | NativeOperator | none = none)
			: NativeMethodImpl {
		parseAttribs();
		local aliasName: string = isstring ? parseString() : parseSymbol();
		if (method is NativeMethod)
			aliasName = method.normalizeSymbolName(aliasName);
		local result: NativeMethodImpl = NativeMethodImpl(alias: aliasName);
		result.implPrefix = attrib.prefix;
		result.inheritAs = attrib.inheritAs;
		return result;
	}

	public parseNativeMethodImpl(method: NativeMethod | NativeOperator | none = none)
			: NativeMethodImpl {
		parseAttribs();
		local implStart = tokStart;
		local implEnd;
		if (tok == "{") {
			implEnd = data.findmatch("{", "}", implStart + 1);
			if (implEnd < 0)
				err("Missing '}' to terminate native method impl");
			++implEnd;
		} else {
			implEnd = data.findmatch("{", "}", implStart);
			if (implEnd < 0)
				err("Missing '}' to terminate native method impl");
		}
		local result: NativeMethodImpl = NativeMethodImpl(
				ppLineFile: filenameForPPLine,
				ppLineLine: lineAt(implStart));
		local implBody = data[implStart:implEnd];
		if (!implBody.startswith("{")) {
			if (implBody.startswith("return")) {
				implBody = f"\{\n\t{implBody.rstrip(";")};\n\}";
			} else {
				implBody = f"\{\n\treturn {implBody};\n\}";
			}
			++result.ppLineLine;
		}
		result.impl = implBody;
		result.implPrefix = attrib.prefix;
		result.inheritAs = attrib.inheritAs;
		tokEnd = implEnd;
		next();
		return result;
	}

	public parseNativeMethod(method: NativeMethod | NativeOperator | none = none)
			: NativeMethodImpl {
		parseAttribs();
		if (tok == "=") {
			next();
			return parseNativeMethodAlias(method);
		}
		skip(":");
		return parseNativeMethodImpl(method);
	}

	public parseNativeMethodSpecialImplementation(method: NativeMethod) {
		if (tok == "using") {
			resetContext();
			next();
			local dependencies: {string...} = [];
			if (tok == "[") {
				next();
				while (tok !in ["", "]"]) {
					dependencies.append(parseSymbol());
					if (tok != ",")
						break;
					next();
				}
				skip("]");
			} else {
				dependencies.append(parseSymbol());
			}
			parseAttribs();
			local impl: NativeMethodImpl;
			if (tok == "=") {
				impl = parseNativeMethodAlias(method);
			} else {
				skip(":");
				impl = parseNativeMethodImpl(method);
			}
			if (!method.usingImpls.setnew(dependencies, impl))
				err(f"Using impl for {repr dependencies} defined multiple times");
			return;
		}
		local tag = parseSymbol();
		if (tok == "=") {
			next();
			resetContext();
			parseAttribs();
			local impl: NativeMethodImpl;
			if (isstring) {
				impl = parseNativeMethodAlias(method);
			} else {
				impl = parseNativeMethodImpl(method);
			}
			tag = method.normalizeSymbolName(tag);
			if (!method.customImpls.setnew(tag, impl))
				err(f"Custom impl {repr tag} defined multiple times");
			return;
		}
		skip("(");
		local impl: string;
		if (tok == "auto") {
			next();
			local spec = none;
			if (tok == "(") {
				next();
				spec = parseString();
				skip(")");
			}
			switch (tag) {

			case "unsupported": {
				local methodHint: MethodHint = method.methodHint;
				local seqClass = methodHint.guessSeqClass();
				if (spec is none)
					spec = methodHint.name;
				if (seqClass is none)
					err(f"Unable to guess sequence class of {repr method.name}");
				impl = f"err_{seqClass}_unsupportedf({method.params.first.name}, \"{
					spec.encode("c-escape")
				}({", ".join(
					for (local x: method.params[1:])
						getCTypeFormatReprCode(x.typ, x.typAfter)
				)})\"{"".join(
					for (local x: method.params[1:])
						f", {x.name}"
				)})";
			}	break;

			default:
				err(f"Unknown implementation tag %\{{tag}(auto)\}");
				break;
			}
		} else if (isstring) {
			impl = parseString();
		} else {
			local implStart = tokStart;
			local implEnd = data.findmatch("(", ")", implStart + 1);
			if (implEnd < 0)
				err(f"Missing '\}' to terminate implementation of {repr method.name}");
			impl = data[implStart:implEnd].strip();
			tokEnd = implEnd;
			next();
		}

		/* Automatically wrap in statement if not already done. */
		if (tag.endswith("_alias")) {
			impl = method.normalizeSymbolName(impl);
		} else if (!impl.startswith("{")) {
			if (impl.restartswith(r"return\b")) {
				impl = f"\{\n\t{impl.rstrip(";")};\n\}";
			} else if (method.returnType.endswith("*")) {
				impl = f"\{\n\t{impl};\n\treturn NULL;\n\}";
			} else if (method.returnType in ["int", "Dee_ssize_t"]) {
				impl = f"\{\n\treturn {impl};\n\}";
			} else {
				impl = f"\{\n\treturn ({
					method.returnType.rereplace(r"\b__restrict\b", "")
				}){impl};\n\}";
			}
		}

		switch (tag) {
		case "callattr":
			method.callAttrImpl = NativeMethodImpl(impl);
			break;
		case "callattr_alias":
			method.callAttrImpl = NativeMethodImpl(alias: impl);
			break;
		case "unsupported":
			method.unsupportedImpl = NativeMethodImpl(impl);
			break;
		case "unsupported_alias":
			method.unsupportedImpl = NativeMethodImpl(alias: impl);
			break;
		default:
			err(f"Unknown implementation tag {repr tag}");
			break;
		}
		skip(")");
	}

	public resetContext() {
		attrib = _SpecParserAttrib();
	}

	public parsePercentDirectives() {
		for (;;) {
			parsePercentDirective();
			if (tok != ",")
				break;
			next();
		}
	}

	public parsePercentDirective() {
		switch (tok) {

		case "define": {
			next();
			skip("(");
			local name = parseSymbol();
			skip("=");
			local bodyStart = tokStart;
			local bodyEnd = data.findmatch("(", ")", bodyStart);
			if (bodyEnd < 0)
				err(f"Missing end-of-body for macro {repr name}");
			local body = data[bodyStart:bodyEnd].strip();
			if (!MACROS.setnew(name, body)) {
				if (MACROS[name] != body)
					err(f"Macro {repr name} re-defined with different body");
			}
			tokEnd = bodyEnd;
			next();
			skip(")");
		}	break;

		case "include": {
			next();
			skip("(");
			local filename = posix.joinpath(posix.headof(this.filename), parseString());
			skip(")");
			local data = File.open(filename, "rb").readall().unifylines().decode("utf-8");
			local ctx = saveParserContext();
			try {
				this.filename = filename;
				this.data = data;
				this.dataLen = #data;
				this.tokEnd = 0;
				this.next();
				loadMethodHints();
			} finally {
				restoreParserContext(ctx);
			}
		}	break;

		default:
			err(f"Unknown directive %[{tok} ...]");
			break;
		}
	}

	public parseNativeOperatorName(): NativeOperatorName {
		local result = NativeOperatorName();
		local field = parseFieldDesc();
		if (tok == "->") {
			next();
			result.table = field;
			result.field = parseFieldDesc();
		} else {
			result.field = field;
		}
		return result;
	}

	public parseNativeOperatorNames(): {NativeOperatorName...} {
		if (tok == "[") {
			next();
			 while (tok && tok != "]") {
				yield parseNativeOperatorName();
				if (tok != ",")
					break;
				next();
			}
			skip("]");
		} else {
			yield parseNativeOperatorName();
		}
	}

	@@Parses the `...` in contents in `%{...}` of a native operator definition
	public parseNativeOperatorImplementation(method: NativeOperator) {
		local isClass = false;
		if (tok == "class") {
			isClass = true;
			next();
		}
		skip("using");
		local impl: NativeOperatorImpl = NativeOperatorImpl(
				dependencies: parseNativeOperatorNames().frozen);
		if (tok == ":") {
			next();
			resetContext();
			impl.impl = parseNativeMethodImpl(method);
		} else if (tok == "=") {
			next();
			impl.impl = parseNativeMethodAlias(method);
		} else {
			err(f"Expected ':' or '=' after dependency in native operator implementation, but for {repr tok}");
		}
		impl.disliked = attrib.disliked;
		(isClass ? method.usrtypeImpls : method.impls).append(impl);
	}

	public parseNativeOperator() {
		for (;;) {
			switch (tok) {
			case "":
			case "}":
				return;

			case ";":
				next();
				resetContext();
				break;

			case "[[":
				next();
				parseAttrib();
				skip("]]");
				break;

			case "%":
				next();
				skip("[");
				parsePercentDirectives();
				skip("]");
				break;

			default: {
				if (!tok.issymbol())
					err(f"Unexpected top-level token: {repr tok}");
				local returnTypeStart = tokStart;
				while (tok in _C_TYPENAME_TOKENS)
					next();
				do {
					next();
				} while (tok in _C_TYPENAME_TOKENS);
				local returnTypeEnd = tokStart;
				local returnType = data[returnTypeStart:returnTypeEnd].strip();
				local operatorName: NativeOperatorName = parseNativeOperatorName();
				local method: NativeOperator = NativeOperator(
						returnType: returnType,
						wunused: attrib.wunused,
						cc: attrib.cc,
						tpSelfExpr: attrib.tpSelfExpr,
						exportPrecheck: attrib.exportPrecheck,
						name: operatorName,
						customUnsupportedImplName: attrib.customUnsupportedImplName,
						customBadAllocImplName: attrib.customBadAllocImplName,
						operatorExportNames: attrib.operatorExportNames,
						ppCond: attrib.ppCond);
				if (!NATIVE_OPERATORS.setnew(operatorName, method))
					err(f"Native operator '{operatorName.locExpr}' was already defined");
				skip("(");
				while (tok && tok != ")") {
					method.params.append(parseNativeMethodParam());
					if (tok != ",")
						break;
					next();
				}
				skip(")");
				while (tok == "%") {
					next();
					skip("{");
					parseNativeOperatorImplementation(method);
					skip("}");
				}
				if (tok == "=") {
					next();
					method.operatorName = parseSymbol();
				}
				skip(";");
				method._makeTyped();
				resetContext();
			}	break;

			}
		}
	}

	public loadMethodHints() {
		for (;;) {
			switch (tok) {

			case "":
				return;

			case "operator":
				next();
				skip("{");
				do {
					parseNativeOperator();
				} while (tok !in ["", "}"]);
				skip("}");
				break;

			case ";":
				next();
				resetContext();
				break;

			case "[[":
				next();
				parseAttrib();
				skip("]]");
				break;

			case "%":
				next();
				skip("[");
				parsePercentDirectives();
				skip("]");
				break;

			default: {
				if (!tok.issymbol())
					err(f"Unexpected top-level token: {repr tok}");
				local returnTypeStart = tokStart;
				while (tok in _C_TYPENAME_TOKENS)
					next();
				do {
					next();
				} while (tok in _C_TYPENAME_TOKENS);
				local returnTypeEnd = tokStart;
				local returnType = data[returnTypeStart:returnTypeEnd].strip();
				if (tok == "=" && returnType.issymbol()) {
					/* Define "selectImpl" of a NativeMethod */
					local nativeMethod: NativeMethod | none = NATIVE_METHOD_HINTS.get(returnType);
					if (nativeMethod is none)
						err(f"Unknown native method {repr returnType}");
					if (nativeMethod.selectImpl !is none)
						err(f"Native method {repr returnType} already has its select-impl defined");
					next();
					nativeMethod.selectImpl = parseNativeMethodImpl(nativeMethod);
					skip(";");
					continue;
				}
				if (tok in ["(", "->"] && returnType.issymbol()) {
					import CMethod, parseCMethodSpecEx from rt.gen.unpack;
					local docStart = tokStart;
					local cMethod, docEnd;
					try {
						cMethod, docEnd = parseCMethodSpecEx(data, returnTypeStart, #data)...;
					} catch (...) {
						local l, c = lcAt(docStart)...;
						print(filename, "(", l, ", ", c, ") : While parsing doc string...");
						throw;
					}
					while (docEnd < #data && data.isspace(docEnd))
						++docEnd;
					local methodHint: MethodHint = MethodHint(
							name: returnType,
							attr: attrib.attr ?? returnType,
							doc: attrib.docstring ?: cMethod.docstring,
							aliases: attrib.aliases,
							kw: attrib.kw,
							getset: attrib.getset,
							declNameAliases: attrib.declNameAliases,
					);
					if (data.startswith("{", docEnd)) {
						local nativeBodyStart = docEnd;
						local nativeBodyEnd = data.findmatch("{", "}", nativeBodyStart + 1);
						if (nativeBodyEnd < 0)
							err(f"Missing '\}' for body of call2native-impl of {repr methodHint.name}");
						++nativeBodyEnd;
						local nativeBody: string = data[nativeBodyStart:nativeBodyEnd];
						local nativeBodyLine = lineAt(nativeBodyStart);
						if (nativeBody.startswith("{\n") && nativeBody.endswith("\n}")) {
							/* Automatically embedd argument unpacking code */
							local unpackBody = captureStdout(() -> {
								if (attrib.kw) {
									cMethod.print_DeeArg_UnpackKw(
											argc: "argc",
											argv: "argv",
											kw: "kw",
											args: "args",
											err: "err",
											defineKwList: false);
								} else {
									cMethod.print_DeeArg_Unpack(
											argc: "argc",
											argv: "argv",
											args: "args",
											err: "err");
								}
							});
							nativeBodyLine -= (1 + unpackBody.count("\n"));
							local bodyWriter = File.Writer();
							for (local param: cMethod.params) {
								local argName = param.name;
								local outName = param.cOutNameEx("args");
								if (argName != outName) {
									nativeBody = nativeBody.rereplace(
										RECACHE(r"\b" + argName + r"\b"), outName);
								}
							}

							bodyWriter << "{\n" << unpackBody << nativeBody[:-2];
							if (!nativeBody.recontains(r"\berr:"))
								bodyWriter << "\nerr:\n\treturn NULL;";
							bodyWriter << "\n}}";
							nativeBody = bodyWriter.string;
						} else if (nativeBody.startswith("{{\n") && nativeBody.endswith("\n}}")) {
							/* Write the impl with double braces to suppress automatic unpacking */
							nativeBody = nativeBody[1:-1];
						}
						local call2native = NativeMethod(
							wunused: attrib.wunused,
							returnType: "DREF DeeObject *",
							cc: "DCALL",
							params: [
								NativeMethodParam("DeeObject *__restrict", "self", true),
								NativeMethodParam("size_t", "argc"),
								NativeMethodParam("DeeObject *const *", "argv"),
							],
							callAttrImpl: NativeMethodImpl(
									nativeBody,
									ppLineFile: filenameForPPLine,
									ppLineLine: nativeBodyLine),
							_methodHint: WeakRef(methodHint));
						if (attrib.kw)
							call2native.params.append(NativeMethodParam("DeeObject *", "kw"));
						methodHint.call2native = call2native;
						tokEnd = nativeBodyEnd;
						next();
					} else {
						if (!methodHint.getset)
							err(f"Method {repr methodHint.name} has no default body, and isn't a [[getset]]");
						if (methodHint.kw)
							err(f"Method {repr methodHint.name} is marked as [[getset]] and [[kw]]");
						methodHint.call2native = none;
						tokEnd = docEnd;
						if (next() == "=") {
							/* Custom property bindings... */
							next();
							skip("{");
							while (tok !in ["", "}"]) {
								if (!tok.issymbol())
									err(f"Expected keyword for property callback definition, but got {repr tok}");
								local propertyCallbackName: string = tok;
								if (propertyCallbackName in methodHint.propertyCall2native)
									err(f"Property callback {repr propertyCallbackName} already defined");
								next();
								skip("(");
								local paramNames = [];
								for (;;) {
									if (!tok.issymbol()) {
										err(f"Expected parameter name for property callback "
										    f"'{methodHint.name}.{propertyCallbackName}', but got {repr tok}");
									}
									paramNames.append(tok);
									if (next() != ",")
										break;
									if (next() in ["", ")"])
										break;
								}
								skip(")");
								if (tok != "{")
									err(f"Expected '\{' for body of '{methodHint.name}.{propertyCallbackName}', but got {repr tok}");
								local bodyStart = tokStart;
								local bodyEnd = data.findmatch("{", "}", bodyStart + 1);
								if (bodyEnd < 0)
									err(f"Missing '\}' to end body of '{methodHint.name}.{propertyCallbackName}'");
								++bodyEnd;
								tokEnd = bodyEnd;
								next();
								local body = data[bodyStart:bodyEnd];
								while (body.count("\n") == body.count("\n\t"))
									body = body.replace("\n\t", "\n");
								local call2native = NativeMethod(
									wunused: true,
									returnType: propertyCallbackName == "get" ? "DREF DeeObject *" : "int",
									cc: "DCALL",
									params: paramNames.map(n -> NativeMethodParam(
										(#paramNames <= 1) ? "DeeObject *__restrict" : "DeeObject *",
										n, true)).frozen,
									callAttrImpl: NativeMethodImpl(
											body,
											ppLineFile: filenameForPPLine,
											ppLineLine: lineAt(bodyStart)),
									_methodHint: WeakRef(methodHint));
								methodHint.propertyCall2native[propertyCallbackName] = call2native;
							}
							skip("}");
						} else {
							skip(";");
						}
					}
					if (!METHOD_HINTS.setnew(methodHint.name, methodHint))
						err(f"Method hint {repr methodHint.name} was already defined");
					resetContext();
					continue;
				}

				local method: NativeMethod = NativeMethod(
						returnType: returnType,
						wunused: attrib.wunused,
						cc: attrib.cc,
						getsetMember: attrib.getsetMember,
						noSelfInvocationWrapper: attrib.noSelfInvocationWrapper,
						operatorSpecs: attrib.operatorSpecs);
				local name1 = parseSymbol();
				if (tok == ".") {
					local methodHint: MethodHint = METHOD_HINTS.get(name1);
					if (methodHint is none)
						err(f"Unknown method hint {repr name1}");
					if (method.getsetMember) {
						if (!methodHint.getset) {
							err(f"getset_member attribute specified on method linked against {
									repr name1}, which isn't a getset");
						}
						if (method.getsetMember in methodHint.getsetCallbacks) {
							// Nah. This is OK because of getfirst + trygetfirst
							/*err(f"getset_member({repr method.getsetMember}) or {
								repr name1} was already defined");*/
						} else {
							methodHint.getsetCallbacks.append(method.getsetMember);
						}
					}
					next();
					method.name = parseSymbol();
					method._methodHint = WeakRef(methodHint);
					if (!methodHint.nativeHints.setnew(method.name, method))
						err(f"Method hint {repr methodHint.name} in {repr name1} was already defined");
					for (local extraName1: attrib.extraMethodHintContext) {
						local methodHint: MethodHint = METHOD_HINTS.get(extraName1);
						if (methodHint is none)
							err(f"Unknown method hint {repr extraName1}");
						//TODO: method._methodHint = WeakRef(methodHint);
						if (!methodHint.nativeHints.setnew(method.name, method))
							err(f"Method hint {repr methodHint.name} in {repr extraName1} was already defined");
					}
				} else {
					method.name = name1;
					if (!ANONYMOUS_METHOD_HINTS.setnew(name1, method))
						err(f"Anonymous method hint {repr name1} was already defined");
				}
				if (!NATIVE_METHOD_HINTS.setnew(method.name, method))
					err(f"Native method hint {repr method.name} was already defined");
				skip("(");
				while (tok && tok != ")") {
					method.params.append(parseNativeMethodParam());
					if (tok != ",")
						break;
					next();
				}
				skip(")");
				while (tok == "%") {
					next();
					skip("{");
					parseNativeMethodSpecialImplementation(method);
					skip("}");
				}
				resetContext();
				parseAttribs();
				if (tok == "=") {
					next();
					if (method.callAttrImpl is bound)
						err(f"Callattr implementation of {repr method.name} defined multiple times");
					method.callAttrImpl = parseNativeMethodAlias(method);
					if (method.unsupportedImpl is none)
						method.unsupportedImpl = method.callAttrImpl;
					skip(";");
				} else if (tok == "{") {
					if (method.callAttrImpl is bound)
						err(f"Callattr implementation of {repr method.name} defined multiple times");
					method.callAttrImpl = parseNativeMethodImpl(method);
				} else {
					if (method.callAttrImpl !is bound)
						method.callAttrImpl = none;
					skip(";");
				}
				resetContext();
			}	break;

			}
		}
	}
};

function loadMethodHints() {
	final local FILENAME = posix.joinpath(posix.headof(__FILE__), "method-hints.h");
	final local SPEC_DATA = File.open(FILENAME, "rb").readall().unifylines().decode("utf-8");
	final local parser = _SpecParser(
		data: SPEC_DATA,
		dataLen: #SPEC_DATA,
		filename: FILENAME);
	parser.next();
	parser.loadMethodHints();

	for (local none, native: NATIVE_METHOD_HINTS)
		native.optimize();
	for (local none, native: NATIVE_OPERATORS)
		native.optimize();
}

loadMethodHints();

#ifdef __MAIN__
//printMethodHintDefs();
//printDefaultImplDecls();
//printDefaultImpls();
//printMhCacheNativeMembers();
//printMhCacheAttributeMembers();
//printMethodAttributeImpls();
print_TNO_ASSIGN_MAXLEN();
#endif /* __MAIN__ */
