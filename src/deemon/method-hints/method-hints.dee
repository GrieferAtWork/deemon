/* Copyright (c) 2018-2025 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2018-2025 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

import * from deemon;
import posix;

global _SpecParser;


global final CTYPE_FORMAT_REPR_CODES: {string: string} = {
	"DeeObject*":   "%r",
	"int":          "%d",
	"unsigned int": "%u",
	"Dee_ssize_t":  "%\" PRFdSIZ \"",
	"size_t":       "%\" PRFuSIZ \"",
};

function getCTypeFormatReprCode(typ: string): string {
	typ = typ.rereplace(r"\s*\*\s*", "*");
	typ = typ.rereplace(r"\b(__restrict|const|volatile)\b", "");
	return CTYPE_FORMAT_REPR_CODES[typ];
}


@@expansion macros defined by "%[define(foo = bar)]"
global MACROS: {string: string} = Dict();


class NativeMethodParam {
	this = default;
	public member typ: string;  /* "DeeObject *__restrict" */
	public member name: string; /* "self" */
	public member nonnull: bool = false;

	public property Cstr: string = {
		get(): string {
			if (typ.endswith("*"))
				return typ + name;
			return f"{typ} {name}";
		}
	};
};

function detectConstantReturnValue(body: string): int | none {
	local parser = _SpecParser(data: body, dataLen: #body, filename: "<inline>");
	parser.next();
	for (;;) {
		switch (parser.tok) {
		case "{":
		case "}":
		case ";":
			break;
		case "(":
			if (parser.next() != "void")
				goto nope;
			if (parser.next() != ")")
				goto nope;
			parser.next();
			parser.next();
			break;
		case "return": {
			local returnExpr = parser.next();
			if (returnExpr == "-") {
				returnExpr = parser.next();
				return try -int(returnExpr) catch (...) none;
			}
			if (returnExpr == "NULL")
				return 0;
			return try int(returnExpr) catch (...) none;
		}	break;
		default:
			goto nope;
		}
		parser.next();
	}
nope:
	return none;
}

global NativeMethod;
class NativeMethodImpl {
	this = default;
	public member impl: string | none = none;   /* Implementation body */
	public member alias: string | none = none;  /* Name of a function to alias */
	public member implPrefix: {string...} = (); /* Extra code to emit before the function body */

	@@Try to detect "simple" impls when linked against
	@@"method", and replace them with none-operators.
	public optimize(method: NativeMethod) {
		if (impl is none)
			return;
		local constReturnVal: int = detectConstantReturnValue(impl);
		if (constReturnVal is none)
			return;
		@@true:  returns int
		@@false: returns size_t/pointer
		local returnsInt: bool;
		local returnType: string = method.returnType;
		if (returnType in ["int", "unsigned int"]) {
			returnsInt = true;
		} else if (returnType in ["Dee_ssize_t"] || returnType.endswith("*")) {
			returnsInt = false;
		} else {
			return none;
		}
		final local KNOWN_ALIASES: {int: {int: (string | none, string | none)}} = {
			0: {
				1: ("_DeeNone_rets0_1", "_DeeNone_reti0_1"),
				2: ("_DeeNone_rets0_2", "_DeeNone_reti0_2"),
				3: ("_DeeNone_rets0_3", "_DeeNone_reti0_3"),
				4: ("_DeeNone_rets0_4", "_DeeNone_reti0_4"),
				5: ("_DeeNone_rets0_5", "_DeeNone_reti0_5"),
				6: (none,               "_DeeNone_reti0_6"),
			},
			1: {
				1: (none, "_DeeNone_reti1_1"),
				2: (none, "_DeeNone_reti1_2"),
				3: (none, "_DeeNone_reti1_3"),
				4: (none, "_DeeNone_reti1_4"),
			},
		};
		local knownAlias = KNOWN_ALIASES.get(constReturnVal).get(#method.params)[returnsInt];
		if (knownAlias !is none) {
			alias = knownAlias;
			impl = none;
		}
	}
}

@@Print @text to stdout, replacing $-prefixes in identifiers with @dollarName,
@@while also calling function-style macros from @formatMacros when encountered
function printUserText(text: string, dollarName: string,
                       formatMacros: {string: Callable | string} = none) {
	local i = 0, end = #text, flushStart = 0;
	while (i < end) {
		local ch = text[i];
		++i;
		switch (ch) {

		case "'":
		case '"': {
			while (i < end) {
				local ch2 = text[i];
				++i;
				if (ch2 == ch) {
					break;
				} else if (ch2 == '\\') {
					++i;
				}
			}
		}	break;

		case "/":
			if (text.startswith("*", i)) {
				local commentEnd = text.find("*/", i + 1);
				if (commentEnd < 0)
					break;
				i = commentEnd + 2;
				continue;
			} else if (text.startswith("/", i)) {
				local commentEnd = text.find("\n", i + 1);
				if (commentEnd < 0)
					break;
				i = commentEnd + 1;
				continue;
			}
			break;
		default:
			if (ch.issymstrt()) {
				local symStart = i - 1;
				local symEnd = i;
				while (symEnd < end && text.issymcont(symEnd))
					++symEnd;
				local symbol = text[symStart:symEnd];
				if (symbol.startswith("$")) {
					print text[flushStart:symStart],;
					print dollarName,;
					print symbol[1:],;
					flushStart = i = symEnd;
					continue;
				} else {
					local formatMacro: Callable | string | none = formatMacros.get(symbol);
					if (formatMacro is string) {
						print text[flushStart:symStart],;
						print formatMacro,;
						flushStart = i = symEnd;
						continue;
					} else if (formatMacro !is none) {
						print text[flushStart:symStart],;
						final local parser = _SpecParser(
							data: text,
							dataLen: end,
							filename: f"<body-related-to-{dollarName}>",
							tokEnd: symEnd);
						local args: {string...} = [];
						parser.next();
						parser.skip("(");
						while (parser.tok != ")") {
							local argStart = parser.tokStart;
							while (parser.tok && parser.tok !in [",", ")"]) {
								if (parser.tok == "(") {
									local recursion = 1;
									while (parser.tok) {
										parser.next();
										if (parser.tok == "(") {
											++recursion;
										} else if (parser.tok == ")") {
											--recursion;
											if (!recursion) {
												parser.next();
												break;
											}
										}
									}
								} else {
									parser.next();
								}
							}
							local argEnd = parser.tokStart;
							args.append(text[argStart:argEnd].strip());
							if (parser.tok != ",")
								break;
							parser.next();
						}
						parser.require(")");
						try {
							print formatMacro(args...),;
						} catch (...) {
							print File.stderr: "While expanding", repr symbol;
							throw;
						}
						flushStart = i = parser.tokEnd;
						continue;
					} else {
						local userMacro: string | none = MACROS.get(symbol);
						if (userMacro !is none) {
							print text[flushStart:symStart],;
							printUserText(userMacro, dollarName, formatMacros);
							flushStart = i = symEnd;
							continue;
						}
					}
				}
				i = symEnd;
			}
			break;
		}
	}
	print text[flushStart:],;
}

global MethodHint;
class NativeMethod {
	this = default;
	public member wunused: bool;      /* true */
	public member returnType: string; /* "int" */
	public member cc: string;         /* "DCALL" */
	public member name: string;       /* "seq_any" */
	public member params: {NativeMethodParam...} = [];
	public member callAttrImpl: NativeMethodImpl | none;           /* Implementation for calling an attribute (if available) */
	public member unsupportedImpl: NativeMethodImpl | none = none; /* Implementation used when this attribute isn't available */
	public member selectImpl: string | none = none;                /* Implementation selection code (or "none" if only linkable against attributes) */
	public member customImpls: {string: NativeMethodImpl} = Dict(); /* Extra custom impls by name */
	public member getsetMember: string = ""; /* Which part of a getset this method implements ("get", "del", "set") */

	public member _methodHint: WeakRef with MethodHint | none = none;
	public property methodHint: MethodHint | none = { get() -> _methodHint.value; };

	public normalizeSymbolName(name: string): string {
		if (name.startswith("$"))
			return f"default__{this.name}__{name[1:]}";
		return name;
	}

	public optimize() {
		callAttrImpl.optimize(this);
		unsupportedImpl.optimize(this);
		for (local none, impl: customImpls)
			impl.optimize(this);
	}

	public printDecl(name: string, lineFeedBeforeName: bool = false) {
		local attrib = getReturnAttrib();
		if (attrib)
			print(attrib, " "),;
		print returnType,;
		if (lineFeedBeforeName) {
			if (cc) {
				if (!returnType.endswith("*"))
					print " ",;
				print cc,;
			}
			print;
		} else {
			if (!returnType.endswith("*"))
				print " ",;
			if (cc)
				print(cc, " "),;
		}
		print(name, "("),;
		print(", ".join(params.each.Cstr)),;
		print(")"),;
	}

	public printFunctionPointerType(name: string = "") {
		print returnType,;
		if (!returnType.endswith("*"))
			print " ",;
		print("("),;
		if (cc)
			print(cc, " "),;
		print("*", name, ")", "("),;
		print(", ".join(params.each.typ)),;
		print(")"),;
	}

	@@True if this method has `default__{name}__with_callobjectcache_{hintAttr}` variants.
	public property hasWithCallCacheDefaultImpls: bool = {
		get() -> methodHint.allAttributes && callAttrImpl.alias is none;
	};

	public printIntdefDeclOrAlias(name: string, impl: NativeMethodImpl) {
		if (impl.alias !is none) {
			print(f"#define {name} (*("),;
			printFunctionPointerType();
			print(f")&{impl.alias})");
		} else {
			print("INTDEF "),;
			printDecl(name);
			print(";");
		}
	}

	@@@param functionMacros Custom callbacks for macro replacement.
	public printInternImpl(name: string, impl: NativeMethodImpl,
	                       formatMacros: {string: Callable} = none) {
		assert impl.alias is none;
		local dollarName = f"default__{this.name}__";
		for (local prefix: impl.implPrefix) {
			printUserText(prefix, dollarName, formatMacros);
			print;
		}
		print("INTERN "),;
		printDecl(name, lineFeedBeforeName: true);
		print(" "),;
		printUserText(impl.impl, dollarName, formatMacros);
		print;
	}

	public printMHTypedef() {
		print("typedef "),;
		local attrib = getReturnAttrib("_T");
		if (attrib)
			print(attrib, " "),;
		print returnType,;
		if (!returnType.endswith("*"))
			print " ",;
		print("("),;
		if (cc)
			print(cc, " "),;
		print("*DeeMH_", name, "_t)", "("),;
		print(", ".join(params.each.Cstr)),;
		print(");");
	}

	public printDefaultImplDecls() {
		print(f"/* {name} */");
		local methodHint = this.methodHint;
		for (local attr: methodHint.allAttributes) {
			if (callAttrImpl is none)
				throw Error(f"Native method {repr name} is missing impl for callattr({repr attr})");
			printIntdefDeclOrAlias(f"default__{name}__with_callattr_{attr}", callAttrImpl);
		}
		if (methodHint.allAttributes) {
			local hintAttr = methodHint.attr;
			printIntdefDeclOrAlias(f"default__{name}__with_callobjectcache_{hintAttr}", callAttrImpl);
			if (!methodHint.getset) {
				print("#ifdef CONFIG_HAVE_MH_CALLMETHODCACHE");
				printIntdefDeclOrAlias(f"default__{name}__with_callmethodcache_{hintAttr}", callAttrImpl);
				printIntdefDeclOrAlias(f"default__{name}__with_callkwmethodcache_{hintAttr}", callAttrImpl);
				print("#endif /* CONFIG_HAVE_MH_CALLMETHODCACHE */");
			}
		}
		if (unsupportedImpl !is none)
			printIntdefDeclOrAlias(f"default__{name}__unsupported", unsupportedImpl);
		for (local name, impl: customImpls)
			printIntdefDeclOrAlias(name, impl);
		print;
	}

	public printDefaultImpls() {
		print(f"/* {name} */");
		local methodHint = this.methodHint;
		for (local attr: methodHint.allAttributes) {
			if (callAttrImpl is none)
				throw Error(f"Native method {repr name} is missing impl for callattr({repr attr})");
			if (callAttrImpl.alias !is none)
				continue;
			printInternImpl(f"default__{name}__with_callattr_{attr}", callAttrImpl, {
				"LOCAL_str_attr": () -> f"(DeeObject *)&str_{attr}",
				"LOCAL_STR_attr": () -> f"STR_{attr}",
				"LOCAL_GETATTR": (self) ->
					f"DeeObject_GetAttr({self}, (DeeObject *)&str_{attr})",
				"LOCAL_BOUNDATTR": (self) ->
					f"DeeObject_BoundAttr({self}, (DeeObject *)&str_{attr})",
				"LOCAL_DELATTR": (self) ->
					f"DeeObject_DelAttr({self}, (DeeObject *)&str_{attr})",
				"LOCAL_SETATTR": (self, value) ->
					f"DeeObject_SetAttr({self}, (DeeObject *)&str_{attr}, {value})",
				"LOCAL_CALLATTR": (self, argc, argv) ->
					f"DeeObject_CallAttr({self}, (DeeObject *)&str_{attr}, {argc}, {argv})",
				"LOCAL_CALLATTRF": (self, args...) ->
					f"DeeObject_CallAttrf({self}, (DeeObject *)&str_{attr}, {", ".join(args)})",
			});
			print;
		}
		if (hasWithCallCacheDefaultImpls) {
			local hintAttr = methodHint.attr;
			if (methodHint.getset) {
				printInternImpl(f"default__{name}__with_callobjectcache_{hintAttr}", callAttrImpl, {
					"LOCAL_GETATTR": (self) ->
						f"DeeObject_Call(Dee_TYPE({self})->tp_mhcache->mhc_get_{
							hintAttr}.c_object, 1, (DeeObject *const *)&{self})",
					"LOCAL_BOUNDATTR": (self) ->
						f"call_getter_for_bound(Dee_TYPE({self})->tp_mhcache->mhc_get_{
							hintAttr}.c_object, {self})",
					"LOCAL_DELATTR": (self) ->
						f"call_delete(Dee_TYPE({self})->tp_mhcache->mhc_del_{
							hintAttr}.c_object, {self})",
					"LOCAL_SETATTR": (self, value) ->
						f"call_setter(Dee_TYPE({self})->tp_mhcache->mhc_set_{
							hintAttr}.c_object, {self}, {value})",
					"LOCAL_CALLATTR": (self, argc, argv) ->
						f"call_getter_result(Dee_TYPE({self})->tp_mhcache->mhc_get_{
							hintAttr}.c_object, {self}, {argc}, {argv})",
					"LOCAL_CALLATTRF": (self, args...) ->
						f"call_getter_resultf(Dee_TYPE({self})->tp_mhcache->mhc_get_{
							hintAttr}.c_object, {self}, {", ".join(args)})",
				});
				print;
			} else {
				printInternImpl(f"default__{name}__with_callobjectcache_{hintAttr}", callAttrImpl, {
					"LOCAL_GETATTR": (self) ->
						f"DeeInstanceMethod_New(Dee_TYPE({self})->tp_mhcache->mhc_{
							hintAttr}.c_object, {self})",
					"LOCAL_BOUNDATTR": (self) -> f"Dee_BOUND_YES",
					"LOCAL_CALLATTR": (self, argc, argv) ->
						f"DeeObject_ThisCall(Dee_TYPE({self})->tp_mhcache->mhc_{
							hintAttr}.c_object, {self}, {argc}, {argv})",
					"LOCAL_CALLATTRF": (self, args...) ->
						f"DeeObject_ThisCallf(Dee_TYPE({self})->tp_mhcache->mhc_{
							hintAttr}.c_object, {self}, {", ".join(args)})",
				});
				print;

				print("#ifdef CONFIG_HAVE_MH_CALLMETHODCACHE");
				printInternImpl(f"default__{name}__with_callmethodcache_{hintAttr}", callAttrImpl, {
					"LOCAL_GETATTR": (self) ->
						f"DeeObjMethod_New(Dee_TYPE({self})->tp_mhcache->mhc_{
							hintAttr}.c_method, {self})",
					"LOCAL_BOUNDATTR": (self) -> f"Dee_BOUND_YES",
					"LOCAL_CALLATTR": (self, argc, argv) ->
						f"DeeObjMethod_CallFunc(Dee_TYPE({self})->tp_mhcache->mhc_{
							hintAttr}.c_method, {self}, {argc}, {argv})",
					"LOCAL_CALLATTRF": (self, args...) ->
						f"DeeObjMethod_CallFuncf(Dee_TYPE({self})->tp_mhcache->mhc_{
							hintAttr}.c_method, {self}, {", ".join(args)})",
				});
				print;
				printInternImpl(f"default__{name}__with_callkwmethodcache_{hintAttr}", callAttrImpl, {
					"LOCAL_GETATTR": (self) ->
						f"DeeKwObjMethod_New(Dee_TYPE({self})->tp_mhcache->mhc_{
							hintAttr}.c_kwmethod, {self})",
					"LOCAL_BOUNDATTR": (self) -> f"Dee_BOUND_YES",
					"LOCAL_CALLATTR": (self, argc, argv) ->
						f"DeeKwObjMethod_CallFunc(Dee_TYPE({self})->tp_mhcache->mhc_{
							hintAttr}.c_kwmethod, {self}, {argc}, {argv}, NULL)",
					"LOCAL_CALLATTRF": (self, args...) ->
						f"DeeKwObjMethod_CallFuncf(Dee_TYPE({self})->tp_mhcache->mhc_{
							hintAttr}.c_kwmethod, {self}, {", ".join(args)})",
				});
				print("#endif /* CONFIG_HAVE_MH_CALLMETHODCACHE */");
				print;
			}
		}
		if (unsupportedImpl !is none && unsupportedImpl.alias is none) {
			printInternImpl(f"default__{name}__unsupported", unsupportedImpl);
			print;
		}
		for (local name, impl: customImpls) {
			if (impl.alias is none) {
				printInternImpl(name, impl);
				print;
			}
		}
		print;
	}

	public printMhCacheNativeMember() {
		print(f"	DeeMH_{name}_t mh_{name};");
	}

	public printMhInitSelectImpl() {
		assert selectImpl !is none;
		print(f"INTERN ATTR_PURE WUNUSED NONNULL((1, 2)) DeeMH_{name}_t DCALL");
		print(f"mh_select_{name}(DeeTypeObject *self, DeeTypeObject *orig_type) \{"),;
		local usedSelectImpl = selectImpl;
		if (usedSelectImpl.startswith("{") && usedSelectImpl.endswith("}"))
			usedSelectImpl = usedSelectImpl[1:-1];
		printUserText(usedSelectImpl, f"default__{name}__", {
			"THIS_TYPE": "self",
			"ORIG_TYPE": "orig_type",
			"SEQ_CLASS": "DeeType_GetSeqClass(self)",
			"REQUIRE": (mhName) ->
				f"(DeeMH_{mhName}_t)DeeType_GetPrivateMethodHint(self, orig_type, Dee_TMH_{mhName})",
			"Dee_type_seq_has_custom_tp_size":
				(x) -> f"{x}->tp_size && !DeeType_IsDefaultSize({x}->tp_size)",
			"Dee_type_seq_has_custom_tp_sizeob":
				(x) -> f"{x}->tp_sizeob && !DeeType_IsDefaultSizeOb({x}->tp_sizeob)",
			"Dee_type_seq_has_custom_tp_foreach":
				(x) -> f"{x}->tp_foreach && !DeeType_IsDefaultForeach({x}->tp_foreach)",
		});
		print("	return NULL;");
		print("}");
		print;
	}

	public getReturnAttrib(_T: string = ""): string {
		local attributes: {string...} = [];
		if (wunused)
			attributes.append(f"WUNUSED{_T}");
		local nonnullIndices = ", ".join(params.enumerate()
			.filter(e -> e.last.nonnull)
			.map(e -> e.first + 1));
		if (nonnullIndices)
			attributes.append(f"NONNULL{_T}(({nonnullIndices}))");
		return " ".join(attributes);
	}

	public property Cparams: string = {
		get(): string -> ", ".join(params.each.Cstr);
	};

	public property Cargs: string = {
		get(): string -> ", ".join(params.each.name);
	};
};

global final KNOWN_BASE_CLASSES: {string: Type} = {
	"Sequence": Sequence,
	"Set": Set,
	"Mapping": Mapping,
	"Numeric": Numeric,
};

class MethodHintAlias {
	this = default;
	public member baseClass: Type; /* Sequence */
	public member attr: Type;      /* "any" */
	public member nameAliases: {string...} = ();
	public property name: string = { get() -> f"{baseClass}_{attr}"; };
};

class MethodHint: WeakRefAble {
	this = default;
	public member name: string; /* "__seq_any__" */
	public member declNameAliases: {string...} = []; /* Some more aliases for "name" (for backwards compat) */
	public member attr: string; /* "__seq_any__" */
	public member doc: string;  /* "(start=!0,end:?Dint=!A!Dint!PSIZE_MAX,key:?DCallable=!N)->?Dbool" */
	public member aliases: {MethodHintAlias...};
	public member call2native: NativeMethod | none; /* Implementation for "DeeMH___seq_any__" (or "none" for getsets) */
	public member kw: bool = false; /* True if `call2nativeImpl' has a "kw" argument */
	public member getset: bool = false; /* True if this is a getset (meaning it has 3 mhcache slots) */
	public member getsetCallbacks: {string...} = []; /* Set of getset callbacks defined in @nativeHints (s.a. @NativeMethod.getsetMember) */
	public member nativeHints: {string: NativeMethod} = Dict();

	public property nameComment: string = {
		get(): string {
			return ", ".join(allNames);
		}
	};

	public property typeMethodFlags: string = {
		get(): string {
			return kw ? "Dee_TYPE_METHOD_FKWDS" : "Dee_TYPE_METHOD_FNORMAL";
		}
	};

	public property allNames: {string...} = {
		get(): {string...} {
			for (local alias: aliases) {
				yield alias.name;
				yield alias.nameAliases...;
			}
			yield name;
			yield declNameAliases...;
		}
	};

	public property allAttributes: {string...} = {
		get(): {string...} {
			for (local alias: aliases)
				yield alias.attr;
			yield attr;
		}
	};

	public function guessSeqClass(): string | none {
		if (aliases.some.baseClass == Sequence)
			return "seq";
		if (aliases.some.baseClass == Set)
			return "set";
		if (aliases.some.baseClass == Mapping)
			return "map";
		if (attr.startswith("__seq_"))
			return "seq";
		if (attr.startswith("__set_"))
			return "set";
		if (attr.startswith("__map_"))
			return "map";
		return none;
	}

	function getMhCacheAttributeMembers(): {string...} {
		if (getset) {
			if ("get" in getsetCallbacks || "bound" in getsetCallbacks)
				yield f"mhc_get_{attr}";
			if ("del" in getsetCallbacks)
				yield f"mhc_del_{attr}";
			if ("set" in getsetCallbacks)
				yield f"mhc_set_{attr}";
		} else {
			yield f"mhc_{attr}";
		}
	}

	public printMethodAttributeDecls() {
		if (call2native is none)
			return;
		print("#define DeeMA_", name, "_flags ", typeMethodFlags);
		print(f"DDATDEF char const DeeMA_{name}_name[]; /* {repr attr} */");
		print(f"DDATDEF char const DeeMA_{name}_doc[];  /* {repr doc} */");
		print("DFUNDEF "),;
		call2native.printDecl(f"DeeMA_{name}");
		print(";");
		for (local alias: aliases) {
			print("#define DeeMA_", alias.name, "_flags DeeMA_", name, "_flags");
			print("#define DeeMA_", alias.name, "_doc   DeeMA_", name, "_doc");
			print("#define DeeMA_", alias.name, "       DeeMA_", name);
			print(f"DDATDEF char const DeeMA_{alias.name}_name[]; /* {repr alias.attr} */");
			for (local nameAlias: alias.nameAliases) {
				print("#define DeeMA_", nameAlias, "_flags DeeMA_", alias.name, "_flags");
				print("#define DeeMA_", nameAlias, "_name  DeeMA_", alias.name, "_name");
				print("#define DeeMA_", nameAlias, "_doc   DeeMA_", alias.name, "_doc");
				print("#define DeeMA_", nameAlias, "       DeeMA_", alias.name);
			}
		}
		for (local declAlias: declNameAliases) {
			print("#define DeeMA_", declAlias, "_flags DeeMA_", name, "_flags");
			print("#define DeeMA_", declAlias, "_name  DeeMA_", name, "_name");
			print("#define DeeMA_", declAlias, "_doc   DeeMA_", name, "_doc");
			print("#define DeeMA_", declAlias, "       DeeMA_", name);
		}
		print;
	}

	public printMethodAttributeImpls() {
		if (call2native is none)
			return;
		print(f"PUBLIC_CONST char const DeeMA_{name}_name[] = {repr attr};");
		print(f"PUBLIC_CONST char const DeeMA_{name}_doc[] = {repr doc};");
		for (local alias: aliases)
			print(f"PUBLIC_CONST char const DeeMA_{alias.name}_name[] = {repr alias.attr};");
		print("PUBLIC "),;
		call2native.printDecl(f"DeeMA_{name}", lineFeedBeforeName: true);
		printUserText(call2native.callAttrImpl.impl, "$");
		print;
		print;
	}
};

@@All known method-hints
global METHOD_HINTS: {string: MethodHint} = Dict();
global NATIVE_METHOD_HINTS: {string: NativeMethod} = Dict();
global ANONYMOUS_METHOD_HINTS: {string: NativeMethod} = Dict();


function getAllMethodHintAttributes(): {string...} {
	for (local none, hint: METHOD_HINTS) {
		yield hint.allAttributes...;
	}
}


function print_Dee_tmh_id() {
	print("/* !!! CAUTION !!! Method hint IDs are prone to arbitrarily change !!!");
	print(" *");
	print(" * Do not make use of these IDs if you're developing a DEX module and");
	print(" * wish to remain compatible with the deemon core across many version. */");
	print("enum Dee_tmh_id {");
	for (local none, hint: NATIVE_METHOD_HINTS) {
		print("	Dee_TMH_", hint.name, ",");
	}
	print("	Dee_TMH_COUNT");
	print("};");
}

function printMHTypedefs() {
	for (local none, hintAttr: METHOD_HINTS) {
		if (hintAttr.nativeHints) {
			print(f"/* {hintAttr.nameComment} */");
			for (local none, native: hintAttr.nativeHints)
				native.printMHTypedef();
			print;
		}
	}

	if (ANONYMOUS_METHOD_HINTS) {
		print("/* Anonymous method hints */");
		for (local none, hint: ANONYMOUS_METHOD_HINTS)
			hint.printMHTypedef();
	}
}

function printMethodAttributeDecls() {
	for (local none, hint: METHOD_HINTS)
		hint.printMethodAttributeDecls();
}

function printMethodAttributeImpls() {
	for (local none, hint: METHOD_HINTS)
		hint.printMethodAttributeImpls();
}

function printMethodHintDefs() {
	for (local none, hint: METHOD_HINTS) {
		print(f"Dee_DEFINE_TYPE_METHOD_HINT_{hint.kw ? "KW" : ""}METHOD({hint.name}, {repr hint.attr}, {repr hint.doc})");
		for (local alias: hint.aliases)
			print(f"Dee_DEFINE_TYPE_METHOD_HINT_ALIAS({alias.name}, {repr alias.attr}, {hint.name})");
		for (local none, native: hint.nativeHints) {
			print(f"Dee_DEFINE_TYPE_METHOD_HINT_FUNC({
				native.getReturnAttrib("_T")
			}, {native.returnType}, {native.cc}, {native.name}, ({native.Cparams}))");
		}
		print;
	}

	if (ANONYMOUS_METHOD_HINTS) {
		print("/* Anonymous method hints */");
		for (local none, native: ANONYMOUS_METHOD_HINTS) {
			print(f"Dee_DEFINE_TYPE_METHOD_HINT_FUNC({
				native.getReturnAttrib("_T")
			}, {native.returnType}, {native.cc}, {native.name}, ({native.Cparams}))");
		}
	}
}

function printDefaultImplDecls() {
	for (local none, native: NATIVE_METHOD_HINTS)
		native.printDefaultImplDecls();
}

function printDefaultImpls() {
	for (local none, native: NATIVE_METHOD_HINTS)
		native.printDefaultImpls();
}

function printMhCacheNativeMembers() {
	for (local none, native: NATIVE_METHOD_HINTS)
		native.printMhCacheNativeMember();
}

function getAllMhCacheAttributeMembers(): {string...} {
	for (local none, hint: METHOD_HINTS) {
		yield hint.getMhCacheAttributeMembers()...;
	}
}

function printMhCacheAttributeMembers() {
	local all = List(getAllMhCacheAttributeMembers());
	if (all) {
		for (local name: all) {
			if (name == all.first)
				print("#define MHC_FIRST ", name);
			print("\tunion mhc_slot ", name, ";");
			if (name == all.last)
				print("#define MHC_LAST ", name);
		}
	}
}

@@Generate prototypes for use with `mh_init_select_t`
function printMhInitSelectDecls() {
	for (local none, native: NATIVE_METHOD_HINTS) {
		if (native.selectImpl is none)
			continue;
		print(f"INTDEF ATTR_PURE WUNUSED NONNULL((1, 2)) DeeMH_{native.name}_t DCALL mh_select_{
				native.name}(DeeTypeObject *self, DeeTypeObject *orig_type);");
	}
}

function printMhInitSelectImpls() {
	for (local none, native: NATIVE_METHOD_HINTS) {
		if (native.selectImpl !is none)
			native.printMhInitSelectImpl();
	}
}

function printMhInitSpecs() {
	/* Start by printing secondary-attribute specs. */
	for (local none, native: NATIVE_METHOD_HINTS) {
		local methodHint: MethodHint | none = native.methodHint;
		if (!methodHint.aliases)
			continue;
		print(f"PRIVATE struct mh_init_spec_secondary_attrib tpconst mh_secondary_{
				native.name}[{#methodHint.aliases + 1}] = \{");
		for (local alias: methodHint.aliases) {
			print("	{"),;
			print("(DeeStringObject *)&str_", alias.attr, ", "),;
			if (alias.baseClass == Sequence) {
				print("NULL, Dee_SEQCLASS_SEQ, "),;
			} else if (alias.baseClass == Set) {
				print("NULL, Dee_SEQCLASS_SET, "),;
			} else if (alias.baseClass == Mapping) {
				print("NULL, Dee_SEQCLASS_MAP, "),;
			} else {
				print("&Dee", alias.baseClass, "_Type, 0, "),;
			}
			print(f"(Dee_funptr_t)&default__{native.name}__with_callattr_{alias.attr} \},",);
		}
		print("	{ NULL, NULL, 0, NULL }");
		print(f"\};");
	}
	print(f"INTERN_TPCONST struct mh_init_spec tpconst mh_init_specs[{#NATIVE_METHOD_HINTS}] = \{");
	for (local none, native: NATIVE_METHOD_HINTS) {
		local methodHint: MethodHint | none = native.methodHint;
		print("	MH_INIT_SPEC_INIT("),;
		print(methodHint is none ? "NULL" : f"&str_{methodHint.attr}"),;
		print(", ", !methodHint.aliases ? "NULL" : f"mh_secondary_{native.name}"),;
		print(", ", methodHint is none ? "NULL" :
			f"&default__{native.name}__with_callattr_{methodHint.attr}"),;
		print(", ", methodHint is none ? "0" : f"offsetof(struct Dee_type_mh_cache, mhc_{
			!methodHint.getset ? methodHint.attr :
				f"{native.getsetMember in ["bound", ""] ? "get" : native.getsetMember}_{methodHint.attr}"
		})"),;
		print(", ", (!methodHint.getset || !native.getsetMember)
			? "MH_KIND_METHOD"
			: f"MH_KIND_GETSET_{native.getsetMember.upper()}"),;
		print(", ", methodHint is none ? "NULL" : f"&default__{
				native.name}__with_callobjectcache_{methodHint.attr}"),;
		print(", ", (methodHint is none || methodHint.getset) ? "NULL" :
				f"&default__{native.name}__with_callmethodcache_{methodHint.attr}"),;
		print(", ", (methodHint is none || methodHint.getset) ? "NULL" :
				f"&default__{native.name}__with_callkwmethodcache_{methodHint.attr}"),;
		print(", ", !native.selectImpl ? "NULL" : f"&mh_select_{native.name}"),;
		print("),");
	}
	print("};");

}

function printMhUnsupportedArrayMembers() {
	for (local none, native: NATIVE_METHOD_HINTS) {
		if (native.unsupportedImpl !is none) {
			print(f"	(Dee_funptr_t)&default__{native.name}__unsupported,");
		} else {
			print(f"	NULL,");
		}
	}
}


class _SpecParserAttrib {
	this = default;
	public member kw: bool = false;
	public member wunused: bool = false;
	public member nonnull: bool = false;
	public member getset: bool = false;
	public member getsetMember: string = "";
	public member attr: string | none = none;
	public member cc: string = "DCALL";
	public member aliases: {MethodHintAlias...} = [];
	public member declNameAliases: {string...} = [];
	public member prefix: {string...} = [];
};

global final _C_TYPENAME_TOKENS = HashSet.Frozen({
	"*", "const", "volatile", "DREF", "__restrict" });

class _SpecParserFile {
	this = default;
	public member data: string;
	public member dataLen: int;
	public member filename: string;
	public member tokEnd: int = 0;
};

class _SpecParser {
	this = default;
	public member data: string;
	public member dataLen: int;
	public member filename: string;
	public member tokStart: int = 0;
	public member tokEnd: int = 0;
	public member tok: string = "";

	public saveParserContext() {
		return (data, dataLen, filename, tokStart, tokEnd, tok);
	}

	public restoreParserContext(context) {
		data, dataLen, filename, tokStart, tokEnd, tok = context...;
	}

	public next(): string {
		local i = tokEnd;
		local result;
again:
		tokStart = i;
		if (i >= dataLen) {
			i = dataLen;
			result = "";
			goto done;
		}
		local ch = data[i];
		++i;
		switch (ch) {

		case '"':
		case "'": {
			while (i < dataLen) {
				local ch2 = data[i];
				++i;
				if (ch2 == ch) {
					break;
				} else if (ch2 == '\\') {
					++i;
				}
			}
		}	break;

		case "/":
			if (data.startswith("*", i)) {
				i = data.index("*/", i + 1) + 2;
				goto again;
			} else if (data.startswith("/", i)) {
				i = data.find("\n", i) + 1;
				if (i <= 0)
					i = dataLen;
				goto again;
			}
			break;

		case "[":
		case "]":
			if (data.startswith(ch, i))
				++i;
			break;

		case "-":
			if (data.startswith(">", i))
				++i;
			break;

		default:
			if (ch.isspace())
				goto again;
			if (ch.issymcont()) {
				while (i < dataLen && data.issymcont(i))
					++i;
			}
			break;
		}
		result = data[tokStart:i];
done:
		tokEnd = i;
		tok = result;
		return result;
	}

	public lcAt(pos: int): (int, int) {
		local line = data.count("\n", 0, pos) + 1;
		local col = pos - data.rfind("\n", 0, pos);
		return (line, col);
	}

	public err(message: string) {
		local l, c = lcAt(tokStart)...;
		print(filename, "(", l, ", ", c, ") : ", message);
		throw Error(message);
	}

	public require(expected: string) {
		if (tok != expected)
			err(f"Unexpected token '{tok}'; expected '{expected}'");
	}

	public skip(expected: string): string {
		require(expected);
		return next();
	}

	public requireSymbol(): string {
		if (!tok.issymbol())
			err(f"Expected a symbol-token, but got '{tok}'");
		return tok;
	}

	public parseSymbol(): string {
		local result = requireSymbol();
		next();
		return result;
	}

	public property isstring: bool = {
		get() -> tok.startswith("'") || tok.startswith('"');
	};

	public requireString(): string {
		if (!isstring)
			err(f"Expected string, but got '{tok}'");
		return tok[1:-1].decode("c-escape");
	}

	public parseString(): string {
		local result = requireString();
		next();
		while (isstring)
			result += parseString();
		return result;
	}

	public member attrib: _SpecParserAttrib = _SpecParserAttrib();

	public parseMethodHintAliasBaseClass(): Type {
		local name = requireSymbol();
		local result = KNOWN_BASE_CLASSES.get(name);
		if (result is none)
			err(f"Unknown base class: {repr name}");
		next();
		return result;
	}

	public parseMethodHintAlias(): MethodHintAlias {
		local result: MethodHintAlias = MethodHintAlias();
		result.baseClass = parseMethodHintAliasBaseClass();
		skip(".");
		result.attr = parseSymbol();
		if (tok == "->") {
			result.nameAliases = [];
			next();
			for (;;) {
				result.nameAliases.append(parseString());
				if (tok != ",")
					break;
				next();
			}
		}
		return result;
	}

	public parseNativeMethodParam(): NativeMethodParam {
		if (tok == "[[") {
			next();
			parseAttrib();
			skip("]]");
		}
		requireSymbol();
		local paramTypeStart = tokStart;
		do {
			next();
		} while (tok in _C_TYPENAME_TOKENS);
		local paramTypeEnd = tokStart;
		local paramType = data[paramTypeStart:paramTypeEnd].strip();
		local paramName = parseSymbol();
		return NativeMethodParam(
				typ: paramType,
				name: paramName,
				nonnull: attrib.nonnull);
	}

	public parseAttribs() {
		while (tok == "[[") {
			next();
			parseAttrib();
			skip("]]");
		}
	}

	public parseAttrib() {
		while (tok && tok != "]]") {
			switch (tok) {
			case "kw":
			case "wunused":
			case "nonnull":
			case "getset": {
				local key = tok;
				next();
				attrib.operator . (key) = true;
			}	break;

			case "getset_member": {
				next();
				skip("(");
				local name = parseString();
				if (name !in ["get", "del", "set", "bound"])
					err(f"Invalid getset member name {repr name}");
				skip(")");
				attrib.getsetMember = name;
			}	break;

			case "cc":
			case "attr": {
				local key = tok;
				next();
				skip("(");
				attrib.operator . (key) = parseSymbol();
				skip(")");
			}	break;

			case "prefix": {
				next();
				skip("(");
				local prefixStart = tokStart;
				local prefixEnd = data.findmatch("(", ")", prefixStart);
				if (prefixEnd < 0)
					err("Missing end-of-prefix attribute body");
				attrib.prefix.append(data[prefixStart:prefixEnd].strip());
				tokEnd = prefixEnd;
				next();
				skip(")");
			}	break;

			case "declNameAlias": {
				next();
				skip("(");
				do {
					attrib.declNameAliases.append(parseString());
					if (tok != ",")
						break;
					next();
				} while (tok && tok != ")");
				skip(")");
			}	break;

			case "alias": {
				next();
				skip("(");
				do {
					attrib.aliases.append(parseMethodHintAlias());
					if (tok != ",")
						break;
					next();
				} while (tok && tok != ")");
				skip(")");
			}	break;

			default:
				err(f"Unknown attribute: {repr tok}");
			}
			if (tok != ",")
				break;
			next();
		}
	}

	public parseNativeMethodSpecialImplementation(method: NativeMethod) {
		local tag = parseSymbol();
		if (tok == "=") {
			next();
			resetContext();
			parseAttribs();
			local impl: NativeMethodImpl;
			if (isstring) {
				impl = NativeMethodImpl(alias: parseString());
			} else {
				local implStart = tokStart;
				local implEnd;
				if (tok == "{") {
					implEnd = data.findmatch("{", "}", implStart + 1);
					if (implEnd < 0) {
						err(f"Missing '\}' to terminate block-implementation {repr tag} of {repr method.name}");
					}
					++implEnd;
				} else {
					implEnd = data.findmatch("{", "}", implStart);
					if (implEnd < 0) {
						err(f"Missing '\}' to terminate return-implementation {repr tag} of {repr method.name}");
					}
				}
				local implBody = data[implStart:implEnd];
				if (!implBody.startswith("{")) {
					if (implBody.restartswith(r"return\b")) {
						implBody = f"\{\n\t{implBody.rstrip(";")};\n\}";
					} else {
						implBody = f"\{\n\treturn {implBody};\n\}";
					}
				}
				impl = NativeMethodImpl(implBody);
				tokEnd = implEnd;
				next();
			}
			impl.implPrefix = attrib.prefix;
			tag = method.normalizeSymbolName(tag);
			if (!method.customImpls.setnew(tag, impl))
				err(f"Custom impl {repr tag} defined multiple times");
			return;
		}
		skip("(");
		local impl: string;
		if (tok == "auto") {
			next();
			local spec = none;
			if (tok == "(") {
				next();
				spec = parseString();
				skip(")");
			}
			switch (tag) {

			case "unsupported": {
				local methodHint: MethodHint = method.methodHint;
				local seqClass = methodHint.guessSeqClass();
				if (spec is none)
					spec = methodHint.name;
				if (seqClass is none)
					err(f"Unable to guess sequence class of {repr method.name}");
				impl = f"err_{seqClass}_unsupportedf({method.params.first.name}, \"{
					spec.encode("c-escape")
				}({", ".join(
					for (local x: method.params[1:])
						getCTypeFormatReprCode(x.typ)
				)})\"{((
					for (local x: method.params[1:])
						f", {x.name}"
				) + ...) ?? ""})";
			}	break;

			default:
				err(f"Unknown implementation tag %\{{tag}(auto)\}");
				break;
			}
		} else if (isstring) {
			impl = parseString();
		} else {
			local implStart = tokStart;
			local implEnd = data.findmatch("(", ")", implStart + 1);
			if (implEnd < 0)
				err(f"Missing '\}' to terminate implementation of {repr method.name}");
			impl = data[implStart:implEnd].strip();
			tokEnd = implEnd;
			next();
		}

		/* Automatically wrap in statement if not already done. */
		if (tag.endswith("_alias")) {
			impl = method.normalizeSymbolName(impl);
		} else if (!impl.startswith("{")) {
			if (impl.restartswith(r"return\b")) {
				impl = f"\{\n\t{impl.rstrip(";")};\n\}";
			} else if (method.returnType.endswith("*")) {
				impl = f"\{\n\t{impl};\n\treturn NULL;\n\}";
			} else if (method.returnType in ["int", "Dee_ssize_t"]) {
				impl = f"\{\n\treturn {impl};\n\}";
			} else {
				impl = f"\{\n\treturn ({
					method.returnType.rereplace(r"\b__restrict\b", "")
				}){impl};\n\}";
			}
		}

		switch (tag) {
		case "callattr":
			method.callAttrImpl = NativeMethodImpl(impl);
			break;
		case "callattr_alias":
			method.callAttrImpl = NativeMethodImpl(alias: impl);
			break;
		case "unsupported":
			method.unsupportedImpl = NativeMethodImpl(impl);
			break;
		case "unsupported_alias":
			method.unsupportedImpl = NativeMethodImpl(alias: impl);
			break;
		default:
			err(f"Unknown implementation tag {repr tag}");
			break;
		}
		skip(")");
	}

	public resetContext() {
		attrib = _SpecParserAttrib();
	}

	public parsePercentDirectives() {
		for (;;) {
			parsePercentDirective();
			if (tok != ",")
				break;
			next();
		}
	}
	public parsePercentDirective() {
		switch (tok) {

		case "define": {
			next();
			skip("(");
			local name = parseSymbol();
			skip("=");
			local bodyStart = tokStart;
			local bodyEnd = data.findmatch("(", ")", bodyStart);
			if (bodyEnd < 0)
				err(f"Missing end-of-body for macro {repr name}");
			local body = data[bodyStart:bodyEnd].strip();
			if (!MACROS.setnew(name, body)) {
				if (MACROS[name] != body)
					err(f"Macro {repr name} re-defined with different body");
			}
			tokEnd = bodyEnd;
			next();
			skip(")");
		}	break;

		case "include": {
			next();
			skip("(");
			local filename = posix.joinpath(posix.headof(this.filename), parseString());
			skip(")");
			local data = File.open(filename, "rb").readall().unifylines().decode("utf-8");
			local ctx = saveParserContext();
			try {
				this.filename = filename;
				this.data = data;
				this.dataLen = #data;
				this.tokEnd = 0;
				this.next();
				loadMethodHints();
			} finally {
				restoreParserContext(ctx);
			}
		}	break;

		default:
			err(f"Unknown directive %[{tok} ...]");
			break;
		}
	}

	public loadMethodHints() {
		for (;;) {
			switch (tok) {

			case "":
				return;

			case ";":
				next();
				resetContext();
				break;

			case "[[":
				next();
				parseAttrib();
				skip("]]");
				break;

			case "%":
				next();
				skip("[");
				parsePercentDirectives();
				skip("]");
				break;

			default: {
				if (!tok.issymbol())
					err(f"Unexpected top-level token: {repr tok}");
				local returnTypeStart = tokStart;
				while (tok in _C_TYPENAME_TOKENS)
					next();
				do {
					next();
				} while (tok in _C_TYPENAME_TOKENS);
				local returnTypeEnd = tokStart;
				local returnType = data[returnTypeStart:returnTypeEnd].strip();
				if (tok == "=" && returnType.issymbol()) {
					/* Define "selectImpl" of a NativeMethod */
					local nativeMethod = NATIVE_METHOD_HINTS.get(returnType);
					if (nativeMethod is none)
						err(f"Unknown native method {repr returnType}");
					if (nativeMethod.selectImpl !is none)
						err(f"Native method {repr returnType} already has its select-impl defined");
					next();
					require("{");
					local selectImplStart = tokStart;
					local selectImplEnd = data.findmatch("{", "}", selectImplStart + 1);
					if (selectImplEnd < 0)
						err(f"Missing trailing '\}' after select-impl of {repr returnType}");
					++selectImplEnd;
					nativeMethod.selectImpl = data[selectImplStart:selectImplEnd].strip();
					tokEnd = selectImplEnd;
					next();
					skip(";");
					continue;
				}
				if (tok in ["(", "->"] && returnType.issymbol()) {
					local docStart = tokStart;
					local docEnd;
					if (tok == "(") {
						docEnd = data.findmatch("(", ")", docStart + 1);
						if (docEnd < 0)
							err("Missing closing ')' for doc string");
						docEnd = data.findany({"{", ";"}, docEnd);
					} else {
						docEnd = data.findany({"{", ";"}, docStart);
					}
					if (docEnd < 0)
						err("Missing '{' or ';' after doc string");
					local methodHint: MethodHint = MethodHint(
						name: returnType,
						attr: attrib.attr ?? returnType,
						doc: data[docStart:docEnd].strip().lsstrip("()"),
						aliases: attrib.aliases,
						kw: attrib.kw,
						getset: attrib.getset,
						declNameAliases: attrib.declNameAliases,
					);
					if (data[docEnd] == "{") {
						local nativeBodyStart = docEnd;
						local nativeBodyEnd = data.findmatch("{", "}", nativeBodyStart + 1);
						if (nativeBodyEnd < 0)
							err(f"Missing '\}' for body of call2native-impl of {repr methodHint.name}");
						++nativeBodyEnd;
						local call2native = NativeMethod(
							wunused: attrib.wunused,
							returnType: "DREF DeeObject *",
							cc: "DCALL",
							params: [
								NativeMethodParam("DeeObject *__restrict", "self", true),
								NativeMethodParam("size_t", "argc"),
								NativeMethodParam("DeeObject *const *", "argv"),
							],
							callAttrImpl: NativeMethodImpl(data[nativeBodyStart:nativeBodyEnd].strip()),
							_methodHint: WeakRef(methodHint));
						if (attrib.kw)
							call2native.params.append(NativeMethodParam("DeeObject *", "kw"));
						methodHint.call2native = call2native;
						tokEnd = nativeBodyEnd;
						next();
					} else {
						if (!methodHint.getset)
							err(f"Method {repr methodHint.name} has no default body, and isn't a [[getset]]");
						if (methodHint.kw)
							err(f"Method {repr methodHint.name} is marked as [[getset]] and [[kw]]");
						methodHint.call2native = none;
						tokEnd = docEnd;
						next();
						skip(";");
					}
					if (!METHOD_HINTS.setnew(methodHint.name, methodHint))
						err(f"Method hint {repr methodHint.name} was already defined");
					resetContext();
					continue;
				}

				local method: NativeMethod = NativeMethod(
						returnType: returnType,
						wunused: attrib.wunused,
						cc: attrib.cc,
						getsetMember: attrib.getsetMember);
				local name1 = parseSymbol();
				if (tok == ".") {
					local methodHint: MethodHint = METHOD_HINTS.get(name1);
					if (methodHint is none)
						err(f"Unknown method hint {repr name1}");
					if (method.getsetMember) {
						if (!methodHint.getset) {
							err(f"getset_member attribute specified on method linked against {
									repr name1}, which isn't a getset");
						}
						if (method.getsetMember in methodHint.getsetCallbacks) {
							// Nah. This is OK because of getfirst + trygetfirst
							/*err(f"getset_member({repr method.getsetMember}) or {
								repr name1} was already defined");*/
						} else {
							methodHint.getsetCallbacks.append(method.getsetMember);
						}
					}
					next();
					method.name = parseSymbol();
					method._methodHint = WeakRef(methodHint);
					if (!methodHint.nativeHints.setnew(method.name, method))
						err(f"Method hint {repr methodHint.name} in {repr name1} was already defined");
				} else {
					method.name = name1;
					if (!ANONYMOUS_METHOD_HINTS.setnew(name1, method))
						err(f"Anonymous method hint {repr name1} was already defined");
				}
				if (!NATIVE_METHOD_HINTS.setnew(method.name, method))
					err(f"Native method hint {repr method.name} was already defined");
				skip("(");
				while (tok && tok != ")") {
					method.params.append(parseNativeMethodParam());
					if (tok != ",")
						break;
					next();
				}
				skip(")");
				while (tok == "%") {
					next();
					skip("{");
					parseNativeMethodSpecialImplementation(method);
					skip("}");
				}
				resetContext();
				parseAttribs();
				if (tok == "=") {
					next();
					if (method.callAttrImpl is bound)
						err(f"Callattr implementation of {repr method.name} defined multiple times");
					method.callAttrImpl = NativeMethodImpl(
							alias: method.normalizeSymbolName(parseSymbol()),
							implPrefix: attrib.prefix);
					if (method.unsupportedImpl is none)
						method.unsupportedImpl = method.callAttrImpl;
					skip(";");
				} else if (tok == "{") {
					local implStart = tokStart;
					local implEnd = data.findmatch("{", "}", implStart + 1);
					if (implEnd < 0)
						err(f"Missing '\}' to terminate implementation of {repr method.name}");
					if (method.callAttrImpl is bound)
						err(f"Callattr implementation of {repr method.name} defined multiple times");
					++implEnd;
					method.callAttrImpl = NativeMethodImpl(
							data[implStart:implEnd].strip(),
							implPrefix: attrib.prefix);
					tokEnd = implEnd;
					next();
				} else {
					if (method.callAttrImpl !is bound)
						method.callAttrImpl = none;
					skip(";");
				}
				resetContext();
			}	break;

			}
		}
	}
};

function loadMethodHints() {
	final local FILENAME = posix.joinpath(posix.headof(__FILE__), "method-hints.h");
	final local SPEC_DATA = File.open(FILENAME, "rb").readall().unifylines().decode("utf-8");
	final local parser = _SpecParser(
		data: SPEC_DATA,
		dataLen: #SPEC_DATA,
		filename: FILENAME);
	parser.next();
	parser.loadMethodHints();

	for (local native: NATIVE_METHOD_HINTS.values)
		native.optimize();
}

loadMethodHints();

#ifdef __MAIN__
//printMethodHintDefs();
//printDefaultImplDecls();
//printDefaultImpls();
//printMhCacheNativeMembers();
//printMhCacheAttributeMembers();
printMethodAttributeImpls();
#endif /* __MAIN__ */
