/* Copyright (c) 2018-2025 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2018-2025 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

/* TODO: Detect aliases between default implementations:
 *       When 2 functions share binary-compatible prototypes, and identical bodies,
 *       those 2 functions can alias each other.
 *       example: `default__seq_locate__empty' and `default__seq_rlocate__empty' */

/* TODO: Don't define stuff `DeeMA_*_name' and `DeeMA_*_doc' as exports; just use
 *       macros and trust the compiler to be smart enough to eliminate duplicate
 *       strings. */

/* TODO: Don't generate "tdefault__size_fast__with__" (typed variants without dependencies). */


import * from deemon;
import posix;

global _SpecParser;


global final CTYPE_FORMAT_REPR_CODES: {string: string} = {
	"DeeObject*":   "%r",
	"int":          "%d",
	"unsigned int": "%u",
	"Dee_ssize_t":  "%\" PRFdSIZ \"",
	"size_t":       "%\" PRFuSIZ \"",
};

function getCTypeSimplified(typ: string, after: string = ""): string {
	typ = typ.rereplace(r"\b(__restrict|const|volatile)\b", "");
	typ = typ.rereplace(r"\s*\*\s*", "*");
	typ = typ.rereplace(r"\b  +\b", " ");
	if (after)
		typ += "*";
	return typ;
}

function getCTypeFormatReprCode(typ: string, after: string): string {
	return CTYPE_FORMAT_REPR_CODES[getCTypeSimplified(typ, after)];
}


@@expansion macros defined by "%[define(foo = bar)]"
global MACROS: {string: string} = Dict();


final class NativeMethodParam {
	this = default;
	public member typ: string;  /* "DeeObject *__restrict" */
	public member name: string; /* "self" */
	public member nonnull: bool = false;
	public member typAfter: string = "";  /* "[2]" */

	public property cTypeSimplified: string = {
		get(): string -> getCTypeSimplified(typ, typAfter);
	};

	public property typWithoutRestrict: string = {
		get(): string {
			return typ
				.rereplace(r"\b__restrict\b", "")
				.rereplace(r"\b  +\b", " ");
		}
	};

	public _withoutRestrict(): NativeMethodParam {
		return NativeMethodParam(
				typ: typWithoutRestrict,
				name: name,
				nonnull: nonnull,
				typAfter: typAfter);
	}

	public property Cstr: string = {
		get(): string {
			if (typ.endswith("*"))
				return typ + name + typAfter;
			return f"{typ} {name}{typAfter}";
		}
	};
};

function detectConstantReturnValue(body: string): int | none {
	local parser = _SpecParser(data: body, dataLen: #body, filename: "<inline>");
	parser.next();
	for (;;) {
		switch (parser.tok) {
		case "{":
		case "}":
		case ";":
			break;
		case "(":
			if (parser.next() != "void")
				goto nope;
			if (parser.next() != ")")
				goto nope;
			parser.next();
			parser.next();
			break;
		case "return": {
			local returnExpr = parser.next();
			if (returnExpr == "-") {
				returnExpr = parser.next();
				return try -int(returnExpr) catch (...) none;
			}
			if (returnExpr == "NULL")
				return 0;
			if (returnExpr == "ITER_DONE")
				return -1;
			return try int(returnExpr) catch (...) none;
		}	break;
		default:
			goto nope;
		}
		parser.next();
	}
nope:
	return none;
}

global NativeMethod;
global NativeOperator;
final class NativeMethodImpl {
	this = default;
	public member impl: string | none = none;     /* Implementation body */
	public member alias: string | none = none;    /* Name of a function to alias */
	public member implPrefix: {string...} = ();   /* Extra code to emit before the function body */
	public member origImpl: string | none = none; /* Implementation body */

	function _makeTyped(): NativeMethodImpl {
		local result = copy this;
		if (result.alias !is none)
			result.alias = "t" + alias;
		return result;
	}

	@@Try to detect "simple" impls when linked against
	@@"method", and replace them with none-operators.
	public optimize(method: NativeMethod | NativeOperator) {
		if (impl is none)
			return;
		origImpl = impl;
		local constReturnVal: int = detectConstantReturnValue(impl);
		if (constReturnVal is none)
			return;
		@@true:  returns int
		@@false: returns size_t/pointer
		local returnsInt: bool;
		local returnType: string = method.returnType;
		if (returnType in ["int", "unsigned int"]) {
			returnsInt = true;
		} else if (returnType in ["Dee_ssize_t", "size_t"] || returnType.endswith("*")) {
			returnsInt = false;
		} else {
			return none;
		}
		final local KNOWN_ALIASES: {int: {int: (string | none, string | none)}} = {
			0: {
				1: ("_DeeNone_rets0_1", "_DeeNone_reti0_1"),
				2: ("_DeeNone_rets0_2", "_DeeNone_reti0_2"),
				3: ("_DeeNone_rets0_3", "_DeeNone_reti0_3"),
				4: ("_DeeNone_rets0_4", "_DeeNone_reti0_4"),
				5: ("_DeeNone_rets0_5", "_DeeNone_reti0_5"),
				6: (none,               "_DeeNone_reti0_6"),
			},
			1: {
				1: (none, "_DeeNone_reti1_1"),
				2: (none, "_DeeNone_reti1_2"),
				3: (none, "_DeeNone_reti1_3"),
				4: (none, "_DeeNone_reti1_4"),
			},
		};
		local knownAlias = KNOWN_ALIASES.get(constReturnVal).get(#method.params)[returnsInt];
		if (knownAlias !is none) {
			alias = knownAlias;
			impl = none;
		}
	}
}

@@Print @text to stdout, replacing $-prefixes in identifiers with @dollarName,
@@while also calling function-style macros from @formatMacros when encountered
function printUserText(text: string, dollarName: string,
                       formatMacros: {string: Callable | string} = none) {
	local i = 0, end = #text, flushStart = 0;
	while (i < end) {
		local ch = text[i];
		++i;
		switch (ch) {

		case "'":
		case '"': {
			while (i < end) {
				local ch2 = text[i];
				++i;
				if (ch2 == ch) {
					break;
				} else if (ch2 == '\\') {
					++i;
				}
			}
		}	break;

		case "/":
			if (text.startswith("*", i)) {
				local commentEnd = text.find("*/", i + 1);
				if (commentEnd < 0)
					break;
				i = commentEnd + 2;
				continue;
			} else if (text.startswith("/", i)) {
				local commentEnd = text.find("\n", i + 1);
				if (commentEnd < 0)
					break;
				i = commentEnd + 1;
				continue;
			}
			break;
		default:
			if (ch.issymstrt()) {
				local symStart = i - 1;
				local symEnd = i;
				while (symEnd < end && text.issymcont(symEnd))
					++symEnd;
				local symbol = text[symStart:symEnd];
				if (symbol.startswith("$")) {
					print text[flushStart:symStart],;
					print dollarName,;
					print symbol[1:],;
					flushStart = i = symEnd;
					continue;
				} else {
					local formatMacro: Callable | string | none = formatMacros.get(symbol);
					if (formatMacro is string) {
						print text[flushStart:symStart],;
						print formatMacro,;
						flushStart = i = symEnd;
						continue;
					} else if (formatMacro !is none) {
						print text[flushStart:symStart],;
						final local parser = _SpecParser(
							data: text,
							dataLen: end,
							filename: f"<body-related-to-{dollarName}>",
							tokEnd: symEnd);
						local args: {string...} = [];
						parser.next();
						parser.skip("(");
						while (parser.tok != ")") {
							local argStart = parser.tokStart;
							while (parser.tok && parser.tok !in [",", ")"]) {
								if (parser.tok == "(") {
									local recursion = 1;
									while (parser.tok) {
										parser.next();
										if (parser.tok == "(") {
											++recursion;
										} else if (parser.tok == ")") {
											--recursion;
											if (!recursion) {
												parser.next();
												break;
											}
										}
									}
								} else {
									parser.next();
								}
							}
							local argEnd = parser.tokStart;
							args.append(text[argStart:argEnd].strip());
							if (parser.tok != ",")
								break;
							parser.next();
						}
						parser.require(")");
						try {
							print formatMacro(args...),;
						} catch (...) {
							print File.stderr: "While expanding", repr symbol;
							throw;
						}
						flushStart = i = parser.tokEnd;
						continue;
					} else {
						local userMacro: string | none = MACROS.get(symbol);
						if (userMacro !is none) {
							print text[flushStart:symStart],;
							printUserText(userMacro, dollarName, formatMacros);
							flushStart = i = symEnd;
							continue;
						}
					}
				}
				i = symEnd;
			}
			break;
		}
	}
	print text[flushStart:],;
}

final class OperatorSpec {
	this = default;
	@@Required base-class for this operator to be linkable
	public member baseClass: string;
	@@OPERATOR_ITER  (or "0" if not defined)
	public member operatorName: string;
	@@tp_seq (@none if part of the root DeeTypeObject)
	public member operatorTable: string | none = none;
	@@tp_iter
	public member operatorField: string;
}


global MethodHint;
final class NativeMethod {
	this = default;
	public member wunused: bool;      /* true */
	public member returnType: string; /* "int" */
	public member cc: string;         /* "DCALL" */
	public member name: string;       /* "seq_any" */
	public member params: {NativeMethodParam...} = [];

	@@Implementation for calling an attribute (if available)
	public member callAttrImpl: NativeMethodImpl | none;

	@@Implementation used when this attribute isn't available
	public member unsupportedImpl: NativeMethodImpl | none = none;

	@@Implementation selection code (or "none" if only linkable against attributes)
	public member selectImpl: string | none = none;

	@@Extra custom impls by name
	public member customImpls: {string: NativeMethodImpl} = Dict();

	@@Which part of a getset this method implements ("get", "del", "set")
	public member getsetMember: string = "";

	@@Descriptor for a location within "DeeTypeObject" where a binary-compatible
	@@callback can be found that may be used to implement this native method, too.
	public member operatorSpecs: {OperatorSpec...} = ();

	public member _methodHint: WeakRef with MethodHint | none = none;
	public property methodHint: MethodHint | none = { get() -> _methodHint.value; };

	public getReturnAttrib(_T: string = ""): string {
		local attributes: {string...} = [];
		if (wunused)
			attributes.append(f"WUNUSED{_T}");
		local nonnullIndices = ", ".join(params.enumerate()
			.filter(e -> e.last.nonnull)
			.map(e -> e.first + 1));
		if (nonnullIndices)
			attributes.append(f"NONNULL{_T}(({nonnullIndices}))");
		return " ".join(attributes);
	}

	public property Cparams: string = {
		get(): string -> ", ".join(params.each.Cstr);
	};

	public property Cargs: string = {
		get(): string -> ", ".join(params.each.name);
	};

	public normalizeSymbolName(name: string): string {
		if (name.startswith("$"))
			return f"default__{this.name}__{name[1:]}";
		return name;
	}

	public optimize() {
		callAttrImpl.optimize(this);
		unsupportedImpl.optimize(this);
		for (local none, impl: customImpls)
			impl.optimize(this);
	}

	public printDecl(name: string, lineFeedBeforeName: bool = false) {
		local attrib = getReturnAttrib();
		if (attrib)
			print(attrib, " "),;
		print returnType,;
		if (lineFeedBeforeName) {
			if (cc) {
				if (!returnType.endswith("*"))
					print " ",;
				print cc,;
			}
			print;
		} else {
			if (!returnType.endswith("*"))
				print " ",;
			if (cc)
				print(cc, " "),;
		}
		print(name, "("),;
		print(", ".join(params.each.Cstr)),;
		print(")"),;
	}

	public printFunctionPointerType(name: string = "") {
		print returnType,;
		if (!returnType.endswith("*"))
			print " ",;
		print("("),;
		if (cc)
			print(cc, " "),;
		print("*", name, ")", "("),;
		print(", ".join(params.each.typ)),;
		print(")"),;
	}

	@@True if this method has `default__{name}__with_callobjectcache_{hintAttr}` variants.
	public property hasWithCallCacheDefaultImpls: bool = {
		get() -> methodHint.allAttributes && callAttrImpl.alias is none;
	};

	public printIntdefDeclOrAlias(name: string, impl: NativeMethodImpl | none) {
		if (impl.alias !is none) {
			print(f"#define {name} (*("),;
			printFunctionPointerType();
			print(f")&{impl.alias})");
		} else {
			print("INTDEF "),;
			printDecl(name);
			print(";");
		}
	}

	@@@param functionMacros Custom callbacks for macro replacement.
	public printInternImpl(name: string, impl: NativeMethodImpl,
	                       formatMacros: {string: Callable} = none) {
		assert impl.alias is none;
		local dollarName = f"default__{this.name}__";
		for (local prefix: impl.implPrefix) {
			printUserText(prefix, dollarName, formatMacros);
			print;
		}
		print("INTERN "),;
		printDecl(name, lineFeedBeforeName: true);
		print(" "),;
		printUserText(impl.impl, dollarName, formatMacros);
		print;
	}

	public printMHTypedef() {
		print("typedef "),;
		local attrib = getReturnAttrib("_T");
		if (attrib)
			print(attrib, " "),;
		print returnType,;
		if (!returnType.endswith("*"))
			print " ",;
		print("("),;
		if (cc)
			print(cc, " "),;
		print("*DeeMH_", name, "_t)", "("),;
		print(", ".join(params.each.Cstr)),;
		print(");");
	}

	public printDefaultImplDecls() {
		print(f"/* {name} */");
		local methodHint = this.methodHint;
		if (operatorSpecs)
			printIntdefDeclOrAlias(f"default__{name}", none);
		for (local attr: methodHint.allAttributes.distinct()) {
			if (callAttrImpl is none)
				throw Error(f"Native method {repr name} is missing impl for callattr({repr attr})");
			printIntdefDeclOrAlias(f"default__{name}__with_callattr_{attr}", callAttrImpl);
		}
		if (methodHint.allAttributes) {
			local hintAttr = methodHint.attr;
			printIntdefDeclOrAlias(f"default__{name}__with_callobjectcache_{hintAttr}", callAttrImpl);
			if (!methodHint.getset) {
				print("#ifdef CONFIG_HAVE_MH_CALLMETHODCACHE");
				printIntdefDeclOrAlias(f"default__{name}__with_callmethodcache_{hintAttr}", callAttrImpl);
				printIntdefDeclOrAlias(f"default__{name}__with_callkwmethodcache_{hintAttr}", callAttrImpl);
				print("#endif /* CONFIG_HAVE_MH_CALLMETHODCACHE */");
			}
		}
		if (unsupportedImpl !is none)
			printIntdefDeclOrAlias(f"default__{name}__unsupported", unsupportedImpl);
		for (local name, impl: customImpls)
			printIntdefDeclOrAlias(name, impl);
		print;
	}

	public printDefaultImpls() {
		print(f"/* {name} */");
		local methodHint = this.methodHint;
		if (operatorSpecs) {
			local selfArg = params.first.name;
			if (selfArg == "p_self")
				selfArg = "*p_self";
			printInternImpl(f"default__{name}", NativeMethodImpl(impl:
				f"\{\n\treturn (*DeeType_RequireMethodHint(Dee_TYPE({
					selfArg}), {name}))({", ".join(params.each.name)});\n\}"
			));
			print;
		}
		for (local attr: methodHint.allAttributes.distinct()) {
			if (callAttrImpl is none)
				throw Error(f"Native method {repr name} is missing impl for callattr({repr attr})");
			if (callAttrImpl.alias !is none)
				continue;
			printInternImpl(f"default__{name}__with_callattr_{attr}", callAttrImpl, {
				"LOCAL_str_attr": () -> f"(DeeObject *)&str_{attr}",
				"LOCAL_STR_attr": () -> f"STR_{attr}",
				"LOCAL_GETATTR": (self) ->
					f"DeeObject_GetAttr({self}, (DeeObject *)&str_{attr})",
				"LOCAL_BOUNDATTR": (self) ->
					f"DeeObject_BoundAttr({self}, (DeeObject *)&str_{attr})",
				"LOCAL_DELATTR": (self) ->
					f"DeeObject_DelAttr({self}, (DeeObject *)&str_{attr})",
				"LOCAL_SETATTR": (self, value) ->
					f"DeeObject_SetAttr({self}, (DeeObject *)&str_{attr}, {value})",
				"LOCAL_CALLATTR": (self, argc, argv) ->
					f"DeeObject_CallAttr({self}, (DeeObject *)&str_{attr}, {argc}, {argv})",
				"LOCAL_CALLATTRF": (self, args...) ->
					f"DeeObject_CallAttrf({self}, (DeeObject *)&str_{attr}, {", ".join(args)})",
			});
			print;
		}
		if (hasWithCallCacheDefaultImpls) {
			local hintAttr = methodHint.attr;
			if (methodHint.getset) {
				printInternImpl(f"default__{name}__with_callobjectcache_{hintAttr}", callAttrImpl, {
					"LOCAL_GETATTR": (self) ->
						f"DeeObject_Call(Dee_TYPE({self})->tp_mhcache->mhc_get_{
							hintAttr}.c_object, 1, (DeeObject *const *)&{self})",
					"LOCAL_BOUNDATTR": (self) ->
						f"call_getter_for_bound(Dee_TYPE({self})->tp_mhcache->mhc_get_{
							hintAttr}.c_object, {self})",
					"LOCAL_DELATTR": (self) ->
						f"call_delete(Dee_TYPE({self})->tp_mhcache->mhc_del_{
							hintAttr}.c_object, {self})",
					"LOCAL_SETATTR": (self, value) ->
						f"call_setter(Dee_TYPE({self})->tp_mhcache->mhc_set_{
							hintAttr}.c_object, {self}, {value})",
					"LOCAL_CALLATTR": (self, argc, argv) ->
						f"call_getter_result(Dee_TYPE({self})->tp_mhcache->mhc_get_{
							hintAttr}.c_object, {self}, {argc}, {argv})",
					"LOCAL_CALLATTRF": (self, args...) ->
						f"call_getter_resultf(Dee_TYPE({self})->tp_mhcache->mhc_get_{
							hintAttr}.c_object, {self}, {", ".join(args)})",
				});
				print;
			} else {
				printInternImpl(f"default__{name}__with_callobjectcache_{hintAttr}", callAttrImpl, {
					"LOCAL_GETATTR": (self) ->
						f"DeeInstanceMethod_New(Dee_TYPE({self})->tp_mhcache->mhc_{
							hintAttr}.c_object, {self})",
					"LOCAL_BOUNDATTR": (self) -> f"Dee_BOUND_YES",
					"LOCAL_CALLATTR": (self, argc, argv) ->
						f"DeeObject_ThisCall(Dee_TYPE({self})->tp_mhcache->mhc_{
							hintAttr}.c_object, {self}, {argc}, {argv})",
					"LOCAL_CALLATTRF": (self, args...) ->
						f"DeeObject_ThisCallf(Dee_TYPE({self})->tp_mhcache->mhc_{
							hintAttr}.c_object, {self}, {", ".join(args)})",
				});
				print;

				print("#ifdef CONFIG_HAVE_MH_CALLMETHODCACHE");
				printInternImpl(f"default__{name}__with_callmethodcache_{hintAttr}", callAttrImpl, {
					"LOCAL_GETATTR": (self) ->
						f"DeeObjMethod_New(Dee_TYPE({self})->tp_mhcache->mhc_{
							hintAttr}.c_method, {self})",
					"LOCAL_BOUNDATTR": (self) -> f"Dee_BOUND_YES",
					"LOCAL_CALLATTR": (self, argc, argv) ->
						f"DeeObjMethod_CallFunc(Dee_TYPE({self})->tp_mhcache->mhc_{
							hintAttr}.c_method, {self}, {argc}, {argv})",
					"LOCAL_CALLATTRF": (self, args...) ->
						f"DeeObjMethod_CallFuncf(Dee_TYPE({self})->tp_mhcache->mhc_{
							hintAttr}.c_method, {self}, {", ".join(args)})",
				});
				print;
				printInternImpl(f"default__{name}__with_callkwmethodcache_{hintAttr}", callAttrImpl, {
					"LOCAL_GETATTR": (self) ->
						f"DeeKwObjMethod_New(Dee_TYPE({self})->tp_mhcache->mhc_{
							hintAttr}.c_kwmethod, {self})",
					"LOCAL_BOUNDATTR": (self) -> f"Dee_BOUND_YES",
					"LOCAL_CALLATTR": (self, argc, argv) ->
						f"DeeKwObjMethod_CallFunc(Dee_TYPE({self})->tp_mhcache->mhc_{
							hintAttr}.c_kwmethod, {self}, {argc}, {argv}, NULL)",
					"LOCAL_CALLATTRF": (self, args...) ->
						f"DeeKwObjMethod_CallFuncf(Dee_TYPE({self})->tp_mhcache->mhc_{
							hintAttr}.c_kwmethod, {self}, {", ".join(args)})",
				});
				print("#endif /* CONFIG_HAVE_MH_CALLMETHODCACHE */");
				print;
			}
		}
		if (unsupportedImpl !is none && unsupportedImpl.alias is none) {
			printInternImpl(f"default__{name}__unsupported", unsupportedImpl);
			print;
		}
		for (local name, impl: customImpls) {
			if (impl.alias is none) {
				printInternImpl(name, impl);
				print;
			}
		}
		print;
	}

	public printMhCacheNativeMember() {
		print(f"	DeeMH_{name}_t mh_{name};");
	}

	public printMhInitSelectImpl() {
		assert selectImpl !is none;
		print(f"INTERN ATTR_PURE WUNUSED NONNULL((1, 2)) DeeMH_{name}_t DCALL");
		print(f"mh_select_{name}(DeeTypeObject *self, DeeTypeObject *orig_type) \{"),;
		local usedSelectImpl = selectImpl;
		if (usedSelectImpl.startswith("{") && usedSelectImpl.endswith("}"))
			usedSelectImpl = usedSelectImpl[1:-1];
		printUserText(usedSelectImpl, f"default__{name}__", {
			"THIS_TYPE": "self",
			"ORIG_TYPE": "orig_type",
			"SEQ_CLASS": "DeeType_GetSeqClass(self)",
			"REQUIRE": (mhName) ->
				f"(DeeMH_{mhName}_t)DeeType_GetPrivateMethodHint(self, orig_type, Dee_TMH_{mhName})",
			"REQUIRE_NODEFAULT": (mhName) ->
				f"(DeeMH_{mhName}_t)DeeType_GetPrivateMethodHintNoDefault(self, orig_type, Dee_TMH_{mhName})",
			"REQUIRE_ANY": (mhName) ->
				f"(DeeMH_{mhName}_t)DeeType_GetMethodHint(orig_type, Dee_TMH_{mhName})",
			"Dee_type_seq_has_custom_tp_size":
				(x) -> f"{x}->tp_size && !DeeType_IsDefaultSize({x}->tp_size)",
			"Dee_type_seq_has_custom_tp_sizeob":
				(x) -> f"{x}->tp_sizeob && !DeeType_IsDefaultSizeOb({x}->tp_sizeob)",
			"Dee_type_seq_has_custom_tp_foreach":
				(x) -> f"{x}->tp_foreach && !DeeType_IsDefaultForeach({x}->tp_foreach)",
		});
		print("	return NULL;");
		print("}");
		print;
	}
}

global final PRETTY_BASE_CLASS_NAMES: {string: string} = {
	"DeeSeq_Type": "Sequence",
	"DeeSet_Type": "Set",
	"DeeMapping_Type": "Mapping",
	"DeeNumeric_Type": "Numeric",
};

global final BASE_CLASS_ALIASES: {string: string} = Dict.Frozen(
	for (local nativeName, prettyName: PRETTY_BASE_CLASS_NAMES)
		(prettyName, nativeName));

final class MethodHintAlias {
	this = default;
	public member baseClass: string; /* "DeeSeq_Type" */
	public member attr: string;      /* "any" */
	public member nameAliases: {string...} = ();
	public property name: string = { get() -> f"{
		PRETTY_BASE_CLASS_NAMES.get(baseClass, baseClass)}_{attr}"; };
}

final class MethodHint: WeakRefAble {
	this = default;
	public member name: string; /* "__seq_any__" */
	public member declNameAliases: {string...} = []; /* Some more aliases for "name" (for backwards compat) */
	public member attr: string; /* "__seq_any__" */
	public member doc: string;  /* "(start=!0,end:?Dint=!A!Dint!PSIZE_MAX,key:?DCallable=!N)->?Dbool" */
	public member aliases: {MethodHintAlias...};
	public member call2native: NativeMethod | none; /* Implementation for "DeeMH___seq_any__" (or "none" for getsets) */
	public member kw: bool = false; /* True if `call2nativeImpl' has a "kw" argument */
	public member getset: bool = false; /* True if this is a getset (meaning it has 3 mhcache slots) */
	public member getsetCallbacks: {string...} = []; /* Set of getset callbacks defined in @nativeHints (s.a. @NativeMethod.getsetMember) */
	public member nativeHints: {string: NativeMethod} = Dict();

	public property nameComment: string = {
		get(): string {
			return ", ".join(allNames);
		}
	};

	public property typeMethodFlags: string = {
		get(): string {
			return kw ? "Dee_TYPE_METHOD_FKWDS" : "Dee_TYPE_METHOD_FNORMAL";
		}
	};

	public property allNames: {string...} = {
		get(): {string...} {
			for (local alias: aliases) {
				yield alias.name;
				yield alias.nameAliases...;
			}
			yield name;
			yield declNameAliases...;
		}
	};

	public property allAttributes: {string...} = {
		get(): {string...} {
			for (local alias: aliases)
				yield alias.attr;
			yield attr;
		}
	};

	public function guessSeqClass(): string | none {
		if (aliases.some.baseClass == "DeeSeq_Type")
			return "seq";
		if (aliases.some.baseClass == "DeeSet_Type")
			return "set";
		if (aliases.some.baseClass == "DeeMapping_Type")
			return "map";
		if (attr.startswith("__seq_"))
			return "seq";
		if (attr.startswith("__set_"))
			return "set";
		if (attr.startswith("__map_"))
			return "map";
		return none;
	}

	function getMhCacheAttributeMembers(): {string...} {
		if (getset) {
			if ("get" in getsetCallbacks || "bound" in getsetCallbacks)
				yield f"mhc_get_{attr}";
			if ("del" in getsetCallbacks)
				yield f"mhc_del_{attr}";
			if ("set" in getsetCallbacks)
				yield f"mhc_set_{attr}";
		} else {
			yield f"mhc_{attr}";
		}
	}

	public printMethodAttributeDecls() {
		if (call2native is none)
			return;
		print("#define DeeMA_", name, "_flags ", typeMethodFlags);
		print(f"DDATDEF char const DeeMA_{name}_name[]; /* {repr attr} */");
		print(f"DDATDEF char const DeeMA_{name}_doc[];  /* {repr doc} */");
		print("DFUNDEF "),;
		call2native.printDecl(f"DeeMA_{name}");
		print(";");
		for (local alias: aliases) {
			print("#define DeeMA_", alias.name, "_flags DeeMA_", name, "_flags");
			print("#define DeeMA_", alias.name, "_doc   DeeMA_", name, "_doc");
			print("#define DeeMA_", alias.name, "       DeeMA_", name);
			print(f"DDATDEF char const DeeMA_{alias.name}_name[]; /* {repr alias.attr} */");
			for (local nameAlias: alias.nameAliases) {
				print("#define DeeMA_", nameAlias, "_flags DeeMA_", alias.name, "_flags");
				print("#define DeeMA_", nameAlias, "_name  DeeMA_", alias.name, "_name");
				print("#define DeeMA_", nameAlias, "_doc   DeeMA_", alias.name, "_doc");
				print("#define DeeMA_", nameAlias, "       DeeMA_", alias.name);
			}
		}
		for (local declAlias: declNameAliases) {
			print("#define DeeMA_", declAlias, "_flags DeeMA_", name, "_flags");
			print("#define DeeMA_", declAlias, "_name  DeeMA_", name, "_name");
			print("#define DeeMA_", declAlias, "_doc   DeeMA_", name, "_doc");
			print("#define DeeMA_", declAlias, "       DeeMA_", name);
		}
		print;
	}

	public printMethodAttributeImpls() {
		if (call2native is none)
			return;
		print(f"PUBLIC_CONST char const DeeMA_{name}_name[] = {repr attr};");
		print(f"PUBLIC_CONST char const DeeMA_{name}_doc[] = {repr doc};");
		for (local alias: aliases)
			print(f"PUBLIC_CONST char const DeeMA_{alias.name}_name[] = {repr alias.attr};");
		print("PUBLIC "),;
		call2native.printDecl(f"DeeMA_{name}", lineFeedBeforeName: true);
		printUserText(call2native.callAttrImpl.impl, "$");
		print;
		print;
	}
}



function simplifyNativeOperatorNamePart(part: string): string {
	return part[part.rfind(".") + 1:].lsstrip("tp_").replace(".", "_");
}

final class NativeOperatorName {
	this = default;
	public member table: string | none = none; /* tp_seq */
	public member field: string;               /* tp_foreach */

	public property TNO_id: string = {
		get(): string {
			return f"Dee_TNO_{name}";
		}
	}

	public property name: string = {
		get(): string {
#if 1
			return simplifyNativeOperatorNamePart(field);
#else
			if (table is none)
				return simplifyNativeOperatorNamePart(field);
			return f"{
				simplifyNativeOperatorNamePart(table)
			}_{
				simplifyNativeOperatorNamePart(field)
			}";
#endif
		}
	}

	public property locExpr: string = {
		get(): string {
			if (table !is none)
				return f"{table}->{field}";
			return field;
		}
	}

	operator str() -> locExpr;
}



final class NativeOperatorImpl {
	this = default;
	@@Operators that must be provided for this one to function
	public member dependencies: {NativeOperatorName...} = [];
	public member impl: NativeMethodImpl;

	public optimize(method: NativeOperator) {
		impl.optimize(method);
	}

	public _makeTyped(): NativeOperatorImpl {
		return NativeOperatorImpl(
			dependencies: dependencies,
			impl: impl._makeTyped());
	}
}

global NATIVE_OPERATORS;
final class NativeOperator {
	this = default;
	public member wunused: bool;                       /* true */
	public member returnType: string;                  /* "int" */
	public member cc: string;                          /* "DCALL" */
	public member name: NativeOperatorName;            /* tp_seq->tp_foreach */
	public member params: {NativeMethodParam...} = []; /* { ... } */
	public member tpSelfExpr: string;                  /* "Dee_TYPE(self)" */
	public member impls: {NativeOperatorImpl...} = []; /* { ... } */
	public member usrtypeImpls: {string: NativeMethodImpl} = Dict();
	public member typed: NativeOperator | none = none;
	public member namePrefix: string = "";
	public member operatorName: string = ""; /* OPERATOR_ITER (empty string if not assigned) */
	public member customUnsupportedImplName: string = "";

	public _makeTyped() {
		typed = NativeOperator(
			wunused: wunused,
			returnType: returnType,
			cc: cc,
			name: name,
			params: (
				NativeMethodParam(
					typ: "DeeTypeObject *",
					name: "tp_self",
					nonnull: true),
				params.each._withoutRestrict()...),
			tpSelfExpr: "tp_self",
			impls: Tuple(impls.each._makeTyped()),
			usrtypeImpls: Dict(
				for (local uImplName, impl: usrtypeImpls)
					(uImplName, impl._makeTyped())
			),
			namePrefix: "t"
		);
	}

	public getReturnAttrib(_T: string = ""): string {
		local attributes: {string...} = [];
		if (wunused)
			attributes.append(f"WUNUSED{_T}");
		local nonnullIndices = params.enumerate()
			.filter(e -> e.last.nonnull)
			.map(e -> e.first + 1);
		nonnullIndices = nonnullIndices.cached;
		if (nonnullIndices)
			attributes.append(f"NONNULL{_T}(({", ".join(nonnullIndices)}))");
		return " ".join(attributes);
	}

	public property Cparams: string = {
		get(): string -> ", ".join(params.each.Cstr);
	};

	public property Cargs: string = {
		get(): string -> ", ".join(params.each.name);
	};

	public optimize() {
		if (!tpSelfExpr)
			tpSelfExpr = f"Dee_TYPE({params.first.name})";
		for (local impl: impls)
			impl.optimize(this);
		typed.optimize();
	}

	public printNativeOperatorTypedef() {
		print("typedef "),;
		local attrib = getReturnAttrib("_T");
		if (attrib)
			print(attrib, " "),;
		print returnType,;
		if (!returnType.endswith("*"))
			print " ",;
		print("("),;
		if (cc)
			print(cc, " "),;
		print("*DeeNO_", name.name, "_t)", "("),;
		print(", ".join(params.each.Cstr)),;
		print(");");
	}

	public printDecl(name: string, lineFeedBeforeName: bool = false) {
		local attrib = getReturnAttrib();
		if (attrib)
			print(attrib, " "),;
		print returnType,;
		if (lineFeedBeforeName) {
			if (cc) {
				if (!returnType.endswith("*"))
					print " ",;
				print cc,;
			}
			print;
		} else {
			if (!returnType.endswith("*"))
				print " ",;
			if (cc)
				print(cc, " "),;
		}
		print(name, "(", ", ".join(params.each.Cstr), ")"),;
	}

	public printFunctionPointerType(name: string = "") {
		print returnType,;
		if (!returnType.endswith("*"))
			print " ",;
		print("("),;
		if (cc)
			print(cc, " "),;
		print("*", name, ")(", ", ".join(params.each.typ), ")"),;
	}

	public printIntdefDeclOrAlias(name: string, impl: NativeMethodImpl | none) {
		if (impl.alias !is none) {
			print(f"#define {name} (*("),;
			printFunctionPointerType();
			print(f")&{impl.alias})");
		} else {
			print("INTDEF "),;
			printDecl(name);
			print(";");
		}
	}

	function nativeSymbolNameForUrstypeImpl(uImplName: string, impl: NativeMethodImpl): string {
		return f"{namePrefix}usrtype__{name.name}{uImplName ? "__" : ""}{uImplName}";
	}

	function nativeSymbolNameForImpl(impl: NativeOperatorImpl): string {
		return f"{namePrefix}default__{name.name}__with__{
			"__and__".join(impl.dependencies.each.name)
		}";
	}

	function enumerateNamesAndImpls(): {(string, NativeOperatorImpl)...} {
		for (local uImplName, impl: usrtypeImpls) {
			yield (
				nativeSymbolNameForUrstypeImpl(uImplName, impl),
				NativeOperatorImpl(
					dependencies: { NativeOperatorName(field: "tp_class") },
					impl: impl)
			);
		}
		for (local impl: impls) {
			yield (nativeSymbolNameForImpl(impl), impl);
		}
	}

	@@Returns symbol names of impls that must appear in `maketyped__*`
	function doPrintNativeOperatorHintDecl(): {string...} {
		local result: {string...} = [];
		for (local symName, impl: enumerateNamesAndImpls()) {
			printIntdefDeclOrAlias(symName, impl.impl);
			local coreImpl: NativeMethodImpl = impl.impl;
			if (coreImpl.origImpl is none ||
			    coreImpl.origImpl.recontains(r"\bCALL_DEPENDENCY\b")) {
				result.append(symName);
			}
		}
		return result;
	}

	function printNativeOperatorHintDecl() {
		print("/* ", name.locExpr, " */");
		local typedNames = typed.doPrintNativeOperatorHintDecl();
		if (usrtypeImpls || impls)
			typed.printIntdefDeclOrAlias(f"{typed.namePrefix}default__{name.name}", none);
		local normalNames = doPrintNativeOperatorHintDecl();
		assert #normalNames == #typedNames;
		local nameFieldBase = name.field;
		local nameFieldBase = name.field[name.field.rfind(".") + 1:];
		if (usrtypeImpls) {
			print(f"#define isusrtype__{name.name}({nameFieldBase}) ({
				" || ".join(
					for (local uImplName, impl: usrtypeImpls)
						f"({nameFieldBase}) == &{nativeSymbolNameForUrstypeImpl(uImplName, impl)}"
				)
			})");
		}
		if (impls) {
			print(f"#define isdefault__{name.name}({nameFieldBase}) ({
				" || ".join(
					for (local impl: impls)
						f"({nameFieldBase}) == &{nativeSymbolNameForImpl(impl)}"
				)
			})");
		}
		if (normalNames) {
			print(f"#define maketyped__{name.name}({nameFieldBase}) ({
				(
					for (local i, symbolName: normalNames.enumerate())
						f"({nameFieldBase}) == &{symbolName} ? &{typedNames[i]} : "
				) + ...
			}&tdefault__{name.name})");
		}
		print;
	}

	@@@param functionMacros Custom callbacks for macro replacement.
	public printInternImpl(name: string, impl: NativeMethodImpl,
	                       formatMacros: {string: Callable} = none) {
		assert impl.alias is none;
		for (local prefix: impl.implPrefix) {
			printUserText(prefix, "$", formatMacros);
			print;
		}
		print("INTERN "),;
		printDecl(name, lineFeedBeforeName: true);
		print(" "),;
		printUserText(impl.impl, "$", formatMacros);
		print;
		print;
	}

	function enumerateNamesAndImplsForImpl(): {(string, NativeOperatorImpl)...} {
		for (local name, impl: enumerateNamesAndImpls()) {
			if (impl.impl.alias is none)
				yield (name, impl);
		}
	}

	@@Return default impls that must be mapped for @dep
	@@e.g. @(getDependencyMappings("tp_seq->tp_iter") == {("usrtype__iter", "tdefault__iter")})
	function getDependencyMappings(currentImpl: NativeOperatorImpl,
	                               dep: string): none | (string, {(string, string)...}) {
		local depTable, none, depField = dep.partition("->")...;
		local depName: NativeOperatorName = NativeOperatorName(
				table: depField ? depTable : none,
				field: depField ? depField : depTable);
		local natOp = NATIVE_OPERATORS.get(depName);
		if (natOp !is none) {
			@@Dependencies that we can assume to be present in the current context
			@@Any mapping of @dep that depends on only a sub-set of these doesn't
			@@have to be mapped
			local availableDependencies: {NativeOperatorName...} =
					List(currentImpl.dependencies);
			availableDependencies.append(name);
			local mappings: {(string, string)...} = [];
			for (local depName, depImpl/*: NativeOperatorImpl*/:
					natOp.enumerateNamesAndImpls()) {
				if (depImpl.impl.origImpl is none ||
				    depImpl.impl.origImpl.recontains(r"\bCALL_DEPENDENCY\b")) {
				}
				local missingDependencies = depImpl.dependencies
					.filter(e -> e !in availableDependencies);
				if (missingDependencies) {
					mappings.append((depName, natOp.typed.namePrefix + depName));
				}
			}
			local typedNatOp = natOp.typed;
			return (f"{typedNatOp.namePrefix}default__{typedNatOp.name.name}", mappings);
		}
		return none;
	}

	function doPrintNativeOperatorHintImpl(
			typedSymNames: {string...} | none = none): {string...} {
		local result = [];
		for (local i, symNameAndImpl: enumerateNamesAndImplsForImpl().enumerate()) {
			local symName, impl = symNameAndImpl...;
			local typedName: string | none = typedSymNames[i];
			local usedImpl: NativeMethodImpl = impl.impl;
			if (typedName !is none) {
				usedImpl = copy usedImpl;
				local baseImplRaw: string = usedImpl.impl.strip().strip("{}").strip();
				usedImpl.impl = f"\{\n"
					f"#ifdef __OPTIMIZE_SIZE__\n"
					f"	return {typedName}({tpSelfExpr}, {", ".join(params.each.name)});\n"
					f"#else /* __OPTIMIZE_SIZE__ */\n"
					f"{baseImplRaw.startswith("#") ? "" : "\t"}{baseImplRaw}\n"
					f"#endif /* __OPTIMIZE_SIZE__ */\n"
					f"\}";
			}
			function callDependency(dep: string, args...): string {
				if (typedName !is none)
					return f"(*{tpSelfExpr}->{dep})({", ".join(args)})";
				local fallbackName, mustMap = getDependencyMappings(impl, dep)...;
				if (!mustMap)
					return f"(*{tpSelfExpr}->{dep})({", ".join(args)})";
				return f"(*({(
					for (local src, dst: mustMap)
						f"{tpSelfExpr}->{dep} == &{src} ? &{dst} : "
				) + ...}&{fallbackName}))({tpSelfExpr}, {", ".join(args)})";
			}
			printInternImpl(symName, usedImpl, {
				"THIS_TYPE": tpSelfExpr,
				"CALL_DEPENDENCY": callDependency,
				"PRELOAD_DEPENDENCY": (dep) -> "", // TODO
				"CALL_PRELOAD_DEPENDENCY": callDependency, // TODO
				"IF_TYPED_ELSE": (ifTyped, ifNotTyped) ->
					typedName is none ? ifTyped : ifNotTyped
			});
			result.append(symName);
		}
		return result;
	}

	function printDefaultTypedCallforward(typelessParams: {NativeMethodParam...}) {
		printInternImpl(f"{namePrefix}default__{name.name}", NativeMethodImpl(
			f"\{\n\treturn (*{tpSelfExpr}->{name})({
					", ".join(typelessParams.each.name)
			});\n\}"
		));
	}

	function printNativeOperatorHintImpl() {
		print("/* ", name.locExpr, " */");
		local typedNames = typed.doPrintNativeOperatorHintImpl();
		if (usrtypeImpls || impls)
			typed.printDefaultTypedCallforward(params);
		doPrintNativeOperatorHintImpl(typedNames);
	}
}


@@All known method-hints
global METHOD_HINTS: {string: MethodHint} = Dict();
global NATIVE_METHOD_HINTS: {string: NativeMethod} = Dict();
global ANONYMOUS_METHOD_HINTS: {string: NativeMethod} = Dict();

@@Native (non-method-hint) operators
global NATIVE_OPERATORS: {NativeOperatorName: NativeOperator} = Dict();


function getAllMethodHintAttributes(): {string...} {
	for (local none, hint: METHOD_HINTS) {
		yield hint.allAttributes...;
	}
}


function print_Dee_tmh_id() {
	print("/* !!! CAUTION !!! Method hint IDs are prone to arbitrarily change !!!");
	print(" *");
	print(" * Do not make use of these IDs if you're developing a DEX module and");
	print(" * wish to remain compatible with the deemon core across many version.");
	print(" * If that's want you're trying to accomplish, you should instead define");
	print(" * regular `tp_methods' with names recognized as method hints. */");
	print("enum Dee_tmh_id {");
	for (local none, hint: NATIVE_METHOD_HINTS) {
		print("	Dee_TMH_", hint.name, ",");
	}
	print("	Dee_TMH_COUNT");
	print("};");
}

function printMHTypedefs() {
	for (local none, hintAttr: METHOD_HINTS) {
		if (hintAttr.nativeHints) {
			print(f"/* {hintAttr.nameComment} */");
			for (local none, native: hintAttr.nativeHints)
				native.printMHTypedef();
			print;
		}
	}

	if (ANONYMOUS_METHOD_HINTS) {
		print("/* Anonymous method hints */");
		for (local none, hint: ANONYMOUS_METHOD_HINTS)
			hint.printMHTypedef();
	}
}

function printMethodAttributeDecls() {
	for (local none, hint: METHOD_HINTS)
		hint.printMethodAttributeDecls();
}

function printMethodAttributeImpls() {
	for (local none, hint: METHOD_HINTS)
		hint.printMethodAttributeImpls();
}

function printMethodHintDefs() {
	for (local none, hint: METHOD_HINTS) {
		print(f"Dee_DEFINE_TYPE_METHOD_HINT_{hint.kw ? "KW" : ""}METHOD({hint.name}, {repr hint.attr}, {repr hint.doc})");
		for (local alias: hint.aliases)
			print(f"Dee_DEFINE_TYPE_METHOD_HINT_ALIAS({alias.name}, {repr alias.attr}, {hint.name})");
		for (local none, native: hint.nativeHints) {
			print(f"Dee_DEFINE_TYPE_METHOD_HINT_FUNC({
				native.getReturnAttrib("_T")
			}, {native.returnType}, {native.cc}, {native.name}, ({native.Cparams}))");
		}
		print;
	}

	if (ANONYMOUS_METHOD_HINTS) {
		print("/* Anonymous method hints */");
		for (local none, native: ANONYMOUS_METHOD_HINTS) {
			print(f"Dee_DEFINE_TYPE_METHOD_HINT_FUNC({
				native.getReturnAttrib("_T")
			}, {native.returnType}, {native.cc}, {native.name}, ({native.Cparams}))");
		}
	}
}

function printDefaultImplDecls() {
	for (local none, native: NATIVE_METHOD_HINTS)
		native.printDefaultImplDecls();
}

function printDefaultImpls() {
	for (local none, native: NATIVE_METHOD_HINTS)
		native.printDefaultImpls();
}

function printMhCacheNativeMembers() {
	for (local none, native: NATIVE_METHOD_HINTS)
		native.printMhCacheNativeMember();
}

function getAllMhCacheAttributeMembers(): {string...} {
	for (local none, hint: METHOD_HINTS) {
		yield hint.getMhCacheAttributeMembers()...;
	}
}

function printMhCacheAttributeMembers() {
	local all = List(getAllMhCacheAttributeMembers());
	print("#define MHC_COUNT ", #all);
	if (all) {
		for (local name: all) {
			if (name == all.first)
				print("#define MHC_FIRST ", name);
			print("\tunion mhc_slot ", name, ";");
			if (name == all.last)
				print("#define MHC_LAST ", name);
		}
	}
}

@@Generate prototypes for use with `mh_init_select_t`
function printMhInitSelectDecls() {
	for (local none, native: NATIVE_METHOD_HINTS) {
		if (native.selectImpl is none)
			continue;
		print(f"INTDEF ATTR_PURE WUNUSED NONNULL((1, 2)) DeeMH_{native.name}_t DCALL mh_select_{
				native.name}(DeeTypeObject *self, DeeTypeObject *orig_type);");
	}
}

function printMhInitSelectImpls() {
	for (local none, native: NATIVE_METHOD_HINTS) {
		if (native.selectImpl !is none)
			native.printMhInitSelectImpl();
	}
}

function printMhInitSpecs() {
	/* Start by printing secondary-attribute specs. */
	for (local none, native: NATIVE_METHOD_HINTS) {
		local methodHint: MethodHint | none = native.methodHint;
		if (methodHint.aliases) {
			print(f"PRIVATE struct mh_init_spec_secondary_attrib tpconst mh_secondary_{
					native.name}[{#methodHint.aliases + 1}] = \{");
			for (local alias: methodHint.aliases) {
				print("	MH_INIT_SPEC_SECONDARY_ATTRIB_INIT("),;
				print("&str_", alias.attr, ", "),;
				if (alias.baseClass == "DeeSeq_Type") {
					print("NULL, Dee_SEQCLASS_SEQ, "),;
				} else if (alias.baseClass == "DeeSet_Type") {
					print("NULL, Dee_SEQCLASS_SET, "),;
				} else if (alias.baseClass == "DeeMapping_Type") {
					print("NULL, Dee_SEQCLASS_MAP, "),;
				} else {
					print("&", alias.baseClass, ", 0, "),;
				}
				print(f"&default__{native.name}__with_callattr_{alias.attr}),",);
			}
			print("	MH_INIT_SPEC_SECONDARY_ATTRIB_END");
			print(f"\};");
		}
		if (native.operatorSpecs) {
			print(f"PRIVATE struct_mh_init_spec_operators({#native.operatorSpecs + 1
				}) tpconst mh_operators_{native.name} = \{");
			print("	/* .misos_default   = */ (Dee_funptr_t)&default__", native.name, ",");
			print("	/* .misos_operators = */ {");
			for (local spec: native.operatorSpecs) {
				print("		MH_INIT_SPEC_OPERATOR_INIT("),;
				local opName = NativeOperatorName(
						table: spec.operatorTable,
						field: spec.operatorField);
				local op: NativeOperator | none = NATIVE_OPERATORS.get(opName);
				local opNameStr: string = op !is none
						? op.name.TNO_id
						: f"Dee_TNO_MISSING({opName})";
				print(opNameStr, ", "),;
				if (spec.baseClass == "DeeSeq_Type") {
					print("NULL, Dee_SEQCLASS_SEQ, "),;
				} else if (spec.baseClass == "DeeSet_Type") {
					print("NULL, Dee_SEQCLASS_SET, "),;
				} else if (spec.baseClass == "DeeMapping_Type") {
					print("NULL, Dee_SEQCLASS_MAP, "),;
				} else {
					print("&", spec.baseClass, ", 0, "),;
				}
				print(spec.operatorName, "),");
			}
			print("		MH_INIT_SPEC_OPERATOR_END");
			print("	}");
			print("};");
		}
	}
	print(f"INTERN_TPCONST struct mh_init_spec tpconst mh_init_specs[{#NATIVE_METHOD_HINTS}] = \{");
	for (local none, native: NATIVE_METHOD_HINTS) {
		local methodHint: MethodHint | none = native.methodHint;
		print("	MH_INIT_SPEC_INIT("),;
		print(methodHint is none ? "NULL" : f"&str_{methodHint.attr}"),;
		print(", ", !methodHint.aliases ? "NULL" : f"mh_secondary_{native.name}"),;
		print(", ", !native.operatorSpecs ? "NULL" : f"&mh_operators_{native.name}"),;
		print(", ", methodHint is none ? "NULL" :
			f"&default__{native.name}__with_callattr_{methodHint.attr}"),;
		print(", ", methodHint is none ? "0" : f"offsetof(struct Dee_type_mh_cache, mhc_{
			!methodHint.getset ? methodHint.attr :
				f"{native.getsetMember in ["bound", ""] ? "get" : native.getsetMember}_{methodHint.attr}"
		})"),;
		print(", ", (!methodHint.getset || !native.getsetMember)
			? "MH_KIND_METHOD"
			: f"MH_KIND_GETSET_{native.getsetMember.upper()}"),;
		print(", ", methodHint is none ? "NULL" : f"&default__{
				native.name}__with_callobjectcache_{methodHint.attr}"),;
		print(", ", (methodHint is none || methodHint.getset) ? "NULL" :
				f"&default__{native.name}__with_callmethodcache_{methodHint.attr}"),;
		print(", ", (methodHint is none || methodHint.getset) ? "NULL" :
				f"&default__{native.name}__with_callkwmethodcache_{methodHint.attr}"),;
		print(", ", !native.selectImpl ? "NULL" : f"&mh_select_{native.name}"),;
		print("),");
	}
	print("};");

}

function printMhUnsupportedArrayMembers() {
	for (local none, native: NATIVE_METHOD_HINTS) {
		if (native.unsupportedImpl !is none) {
			print(f"	(Dee_funptr_t)&default__{native.name}__unsupported,");
		} else {
			print(f"	NULL,");
		}
	}
}

function printNativeOperatorIds() {
	for (local none, method: NATIVE_OPERATORS)
		print("	", method.name.TNO_id, ",");
}

function printNativeOperatorTypes() {
	for (local none, method: NATIVE_OPERATORS)
		method.printNativeOperatorTypedef();
}

function printNativeOperatorHintDecls() {
	for (local none, method: NATIVE_OPERATORS)
		method.printNativeOperatorHintDecl();
}

function printNativeOperatorHintImpls() {
	for (local none, method: NATIVE_OPERATORS)
		method.printNativeOperatorHintImpl();
}

function printNativeOperatorHintSpecs() {
	@@Native methods (from method hints) that have a bi-directional link to native operators
	local nativeMethodsByOperatorName:
			{NativeOperatorName: {(OperatorSpec, NativeMethod)...}} = Dict();
	for (local none, nativeMethod: NATIVE_METHOD_HINTS) {
		for (local operatorSpec/*: OperatorSpec*/: nativeMethod.operatorSpecs) {
			local operatorName = NativeOperatorName(
					table: operatorSpec.operatorTable,
					field: operatorSpec.operatorField);
			local impls: {(OperatorSpec, NativeMethod)...} =
					nativeMethodsByOperatorName.setdefault(operatorName, []);
			impls.append((operatorSpec, nativeMethod));
		}
	}
	for (local name, method: NATIVE_OPERATORS) {
		if (method.impls) {
			print(f"PRIVATE struct oh_init_spec_impl tpconst oh_impls_{
					name.name}[{#method.impls + 1}] = \{");
			for (local impl/*: NativeOperatorImpl*/: method.impls) {
				local deps = Tuple(impl.dependencies.each.TNO_id);
				local dep1 = #deps >= 1 ? deps[0] : "Dee_TNO_COUNT";
				local dep2 = #deps >= 2 ? deps[1] : "Dee_TNO_COUNT";
				local symName = method.nativeSymbolNameForImpl(impl);
				if (#deps >= 3) {
					throw Error(f"Max 2 dependencies are supported for default operators, but {
							repr symName} has {#deps}");
				}
				print(f"	OH_INIT_SPEC_IMPL_INIT(&{symName}, {dep1}, {dep2}),");
			}
			print(f"	OH_INIT_SPEC_IMPL_END");
			print(f"\};");
		}
		local nativeMethods: {(OperatorSpec, NativeMethod)...} | none =
				nativeMethodsByOperatorName.get(name);
		if (nativeMethods) {
			print(f"PRIVATE struct oh_init_spec_mhint tpconst oh_mhints_{
					name.name}[{#nativeMethods + 1}] = \{");
			for (local operatorSpec, nativeMethod: nativeMethods) {
				print("	OH_INIT_SPEC_MHINT_INIT(Dee_TMH_", nativeMethod.name, ", "),;
				if (operatorSpec.baseClass == "DeeSeq_Type") {
					print("NULL, Dee_SEQCLASS_SEQ"),;
				} else if (operatorSpec.baseClass == "DeeSet_Type") {
					print("NULL, Dee_SEQCLASS_SET"),;
				} else if (operatorSpec.baseClass == "DeeMapping_Type") {
					print("NULL, Dee_SEQCLASS_MAP"),;
				} else {
					print("&", operatorSpec.baseClass, ", 0"),;
				}
				print("),");
			}
			print("	OH_INIT_SPEC_MHINT_END");
			print("};");
		}
	}
	print("INTERN_TPCONST struct oh_init_spec tpconst oh_init_specs[", #NATIVE_OPERATORS, "] = {");
	local longestNameLength = NATIVE_OPERATORS.keys.each.locExpr.length > ...;
	for (local name, method: NATIVE_OPERATORS) {
		local nativeMethods: {(OperatorSpec, NativeMethod)...} | none =
				nativeMethodsByOperatorName.get(name);
		print("	/* ", name.locExpr.ljust(longestNameLength), " */ OH_INIT_SPEC_INIT("),;
		print(name.table is none ? "0" : f"offsetof(DeeTypeObject, {name.table})"),;
		local subTableTypeName = name.table is none
			? "DeeTypeObject"
			: f"struct type_{name.table.lsstrip("tp_")}";
		print(f", offsetof({subTableTypeName}, {name.field}), "),;
		print(method.impls ? f"oh_impls_{name.name}" : "NULL", ", "),;
		print(nativeMethods ? f"oh_mhints_{name.name}" : "NULL"),;
		print("),");
	}
	print("};");
}


function getCTypeSuperSimplified(typ: string, after: string = ""): string {
	local result = getCTypeSimplified(typ, after);
	if (result.endswith("*"))
		return "void*";
	return {
		"Dee_foreach_t": "void*",
		"Dee_foreach_pair_t": "void*",
		"Dee_hash_t": "void*",
		"size_t": "void*",
		"Dee_ssize_t": "void*",
		"unsigned int": "int",
	}.get(result, result);
}



class ErrorMethodKey {
	this = default;
	@@Return type, as per @getCTypeSimplified
	public member returnType: string;
	public member cc: string;
	@@Argument types, as per @getCTypeSimplified
	public member paramTypes: {string...};
	@@Expression to get the type of the "self"-argument
	@@(assuming that argument's name to be "self", and being the first argument)
	public member tpSelfExpr: string;
	@@Function body
	public member body: string;

	public printIntdefDecl(name: string) {
		print("INTDEF ", returnType),;
		if (!returnType.endswith("*"))
			print(" "),;
		print(cc, " ", name, "(", ", ".join(paramTypes), ");");
	}

	public printInternImpl(name: string) {
		print("INTERN ", returnType),;
		if (!returnType.endswith("*"))
			print(" "),;
		local firstParam = paramTypes.first;
		print(cc, " ", name, "(", firstParam),;
		if (!firstParam.endswith("*"))
			print(" "),;
		print("self", ((
			for (local x: paramTypes[1:]) ", " + x
		) + ...) ?? "", ") ", body),;
		print;
	}

	public printIntdefDeclAndAliases(names: {string...}) {
		if (!names)
			return;
		local primary = names.first;
		printIntdefDecl(primary);
		for (local alias: names[1:]) {
			print("#define ", alias, " ", primary);
		}
	}
}

@@param decls: When true, print decls (and aliases) for error functions; else, print their impls
function printNativeOperatorHintErrorImpls(decls: bool) {
	@@Mapping of required functions, to the names under which they must be provided
	local requiredFunctions: {ErrorMethodKey: {string...}} = Dict();
	function addKey(key: ErrorMethodKey, name: string) {
		requiredFunctions.setdefault(key, []).append(name);
	}
	function makeBodyWithMinus1Expr(key: ErrorMethodKey, expr: string): string {
		if (key.returnType.endswith("*")) {
			return
				f"\{\n"
				f"	{expr};\n"
				f"	return NULL;\n"
				f"\}";
		} else if (key.returnType in ["Dee_ssize_t", "int"]) {
			return
				f"\{\n"
				f"	return {expr};\n"
				f"\}";
		} else {
			return
				f"\{\n"
				f"	return ({key.returnType}){expr};\n"
				f"\}";
		}
	}
	for (local none, nativeOperator /*: NativeOperator*/: NATIVE_OPERATORS) {
		function makeKey(includeTpSelfExpr: bool): ErrorMethodKey {
			return ErrorMethodKey(
					returnType: getCTypeSuperSimplified(nativeOperator.returnType),
					cc: nativeOperator.cc,
					paramTypes: includeTpSelfExpr ? Tuple({
						nativeOperator.params.first.cTypeSimplified,
						(
							for (local x: nativeOperator.params[1:])
								getCTypeSuperSimplified(x.typ, x.typAfter)
						)...
					}) : (
						for (local x: nativeOperator.params)
								getCTypeSuperSimplified(x.typ, x.typAfter)
					).frozen,
					tpSelfExpr: includeTpSelfExpr
						? nativeOperator.tpSelfExpr.rereplace(
							f"\\b{nativeOperator.params.first.name}\\b", "self")
						: "");
		}
		if (nativeOperator.name.table) {
			local sizeofExpr = f"sizeof(struct type_{
					nativeOperator.name.table.lsstrip("tp_")})";
			local key: ErrorMethodKey = makeKey(false);
			key.body = makeBodyWithMinus1Expr(key, f"Dee_BadAlloc({sizeofExpr})");
			addKey(key, f"default__{nativeOperator.name.name}__badalloc");
		}
		if (nativeOperator.operatorName && !nativeOperator.customUnsupportedImplName) {
			/* Need a fallback for "_DeeType_GetNativeOperatorUnsupported" */
			local key: ErrorMethodKey = makeKey(true);
			key.body = makeBodyWithMinus1Expr(key, f"err_unimplemented_operator({
					key.tpSelfExpr}, {nativeOperator.operatorName})");
			addKey(key, f"default__{nativeOperator.name.name}__unsupported");
		}
	}

	// TODO: More functions can be re-used under "#ifdef DCALL_CALLER_CLEANUP"
	if (decls) {
		for (local key, names: requiredFunctions)
			key.printIntdefDeclAndAliases(names);
	} else {
		for (local key, names: requiredFunctions) {
			if (names)
				key.printInternImpl(names.first);
		}
	}
}

function printNativeOperatorHintBadAllocTable() {
	local longestNameLength = NATIVE_OPERATORS.values.each.name.name.length > ...;
	for (local none, nativeOperator /*: NativeOperator*/: NATIVE_OPERATORS) {
		print(f"	/* {nativeOperator.name.name.ljust(longestNameLength)} */ "),;
		if (nativeOperator.name.table) {
			print(f"(Dee_funptr_t)&default__{nativeOperator.name.name}__badalloc,");
		} else {
			print(f"NULL,");
		}
	}
}

function printNativeOperatorHintUnsupportedTable() {
	local longestNameLength = NATIVE_OPERATORS.values.each.name.name.length > ...;
	for (local none, nativeOperator /*: NativeOperator*/: NATIVE_OPERATORS) {
		print(f"	/* {nativeOperator.name.name.ljust(longestNameLength)} */ "),;
		if (nativeOperator.customUnsupportedImplName) {
			print(f"(Dee_funptr_t)&{nativeOperator.customUnsupportedImplName},");
		} else if (nativeOperator.operatorName) {
			print(f"(Dee_funptr_t)&default__{nativeOperator.name.name}__unsupported,");
		} else {
			print(f"NULL,");
		}
	}
}


final class _SpecParserAttrib {
	this = default;
	public member kw: bool = false;
	public member wunused: bool = false;
	public member tpSelfExpr: string = "";
	public member nonnull: bool = false;
	public member getset: bool = false;
	public member getsetMember: string = "";
	public member attr: string | none = none;
	public member cc: string = "DCALL";
	public member aliases: {MethodHintAlias...} = [];
	public member declNameAliases: {string...} = [];
	public member prefix: {string...} = [];
	public member operatorSpecs: {OperatorSpec...} = [];
	public member customUnsupportedImplName: string = "";
};

global final _C_TYPENAME_TOKENS = HashSet.Frozen({
	"*", "const", "volatile", "DREF", "__restrict" });

final class _SpecParserFile {
	this = default;
	public member data: string;
	public member dataLen: int;
	public member filename: string;
	public member tokEnd: int = 0;
};

final class _SpecParser {
	this = default;
	public member data: string;
	public member dataLen: int;
	public member filename: string;
	public member tokStart: int = 0;
	public member tokEnd: int = 0;
	public member tok: string = "";

	public saveParserContext() {
		return (data, dataLen, filename, tokStart, tokEnd, tok);
	}

	public restoreParserContext(context) {
		data, dataLen, filename, tokStart, tokEnd, tok = context...;
	}

	public next(): string {
		local i = tokEnd;
		local result;
again:
		tokStart = i;
		if (i >= dataLen) {
			i = dataLen;
			result = "";
			goto done;
		}
		local ch = data[i];
		++i;
		switch (ch) {

		case '"':
		case "'": {
			while (i < dataLen) {
				local ch2 = data[i];
				++i;
				if (ch2 == ch) {
					break;
				} else if (ch2 == '\\') {
					++i;
				}
			}
		}	break;

		case "/":
			if (data.startswith("*", i)) {
				i = data.index("*/", i + 1) + 2;
				goto again;
			} else if (data.startswith("/", i)) {
				i = data.find("\n", i) + 1;
				if (i <= 0)
					i = dataLen;
				goto again;
			}
			break;

		case "[":
		case "]":
			if (data.startswith(ch, i))
				++i;
			break;

		case "-":
			if (data.startswith(">", i))
				++i;
			break;

		default:
			if (ch.isspace())
				goto again;
			if (ch.issymcont()) {
				while (i < dataLen && data.issymcont(i))
					++i;
			}
			break;
		}
		result = data[tokStart:i];
done:
		tokEnd = i;
		tok = result;
		return result;
	}

	public lcAt(pos: int): (int, int) {
		local line = data.count("\n", 0, pos) + 1;
		local col = pos - data.rfind("\n", 0, pos);
		return (line, col);
	}

	public err(message: string) {
		local l, c = lcAt(tokStart)...;
		print(filename, "(", l, ", ", c, ") : ", message);
		throw Error(message);
	}

	public require(expected: string) {
		if (tok != expected)
			err(f"Unexpected token '{tok}'; expected '{expected}'");
	}

	public skip(expected: string): string {
		require(expected);
		return next();
	}

	public requireSymbol(): string {
		if (!tok.issymbol())
			err(f"Expected a symbol-token, but got '{tok}'");
		return tok;
	}

	public parseSymbol(): string {
		local result = requireSymbol();
		next();
		return result;
	}

	public property isstring: bool = {
		get() -> tok.startswith("'") || tok.startswith('"');
	};

	public requireString(): string {
		if (!isstring)
			err(f"Expected string, but got '{tok}'");
		return tok[1:-1].decode("c-escape");
	}

	public parseString(): string {
		local result = requireString();
		next();
		while (isstring)
			result += parseString();
		return result;
	}

	public member attrib: _SpecParserAttrib = _SpecParserAttrib();

	public parseTypename(): string {
		local result = parseSymbol();
		return BASE_CLASS_ALIASES.get(result, result);
	}

	public parseMethodHintAlias(): MethodHintAlias {
		local result: MethodHintAlias = MethodHintAlias();
		result.baseClass = parseTypename();
		skip(".");
		result.attr = parseSymbol();
		if (tok == "->") {
			result.nameAliases = [];
			next();
			for (;;) {
				result.nameAliases.append(parseString());
				if (tok != ",")
					break;
				next();
			}
		}
		return result;
	}

	public parseNativeMethodParam(): NativeMethodParam {
		resetContext();
		parseAttribs();
		requireSymbol();
		local paramTypeStart = tokStart;
		while (tok in _C_TYPENAME_TOKENS)
			next();
		do {
			next();
		} while (tok in _C_TYPENAME_TOKENS);
		local paramTypeEnd = tokStart;
		local paramType = data[paramTypeStart:paramTypeEnd].strip();
		local paramName = parseSymbol();
		local typAfter = "";
		if (tok == "[") {
			local typAfterStart = tokStart;
			next();
			local recursion = 0;
			while (tok) {
				if (tok == "]") {
					if (!recursion)
						break;
					--recursion;
				} else if (tok == "[") {
					++recursion;
				}
				next();
			}
			typAfter = data[typAfterStart:tokEnd];
			skip("]");
		}
		return NativeMethodParam(
				typ: paramType,
				name: paramName,
				nonnull: attrib.nonnull,
				typAfter: typAfter);
	}

	public parseAttribs() {
		while (tok == "[[") {
			next();
			parseAttrib();
			skip("]]");
		}
	}

	public parseFieldDesc(): string {
		local result = parseSymbol();
		for (;;) {
			if (tok == ".") {
				next();
				result = f"{result}.{parseSymbol()}";
				continue;
			}
			break;
		}
		return result;
	}

	public parseBaseClassList(): {string...} {
		if (tok == "[") {
			next();
			for (;;) {
				yield parseTypename();
				if (tok != ",")
					break;
				next();
			}
			skip("]");
		} else {
			yield parseTypename();
		}
	}

	public parseOperatorSpecs(): {OperatorSpec...} {
		local result = OperatorSpec();
		local baseClasses = parseBaseClassList().frozen;
		if (tok == ".") {
			next();
			result.operatorName = parseSymbol();
		} else {
			result.operatorName = "0";
		}
		skip(":");
		local field = parseFieldDesc();
		if (tok == "->") {
			next();
			result.operatorTable = field;
			result.operatorField = parseFieldDesc();
		} else {
			result.operatorField = field;
		}
		for (local baseClass: baseClasses) {
			result.baseClass = baseClass;
			yield copy result;
		}
	}

	public parseAttrib() {
		while (tok && tok != "]]") {
			switch (tok) {
			case "kw":
			case "wunused":
			case "nonnull":
			case "getset": {
				local key = tok;
				next();
				attrib.operator . (key) = true;
			}	break;

			case "getset_member": {
				next();
				skip("(");
				local name = parseString();
				if (name !in ["get", "del", "set", "bound"])
					err(f"Invalid getset member name {repr name}");
				skip(")");
				attrib.getsetMember = name;
			}	break;

			case "cc":
			case "attr": {
				local key = tok;
				next();
				skip("(");
				attrib.operator . (key) = parseSymbol();
				skip(")");
			}	break;

			case "prefix": {
				next();
				skip("(");
				local prefixStart = tokStart;
				local prefixEnd = data.findmatch("(", ")", prefixStart);
				if (prefixEnd < 0)
					err("Missing end-of-prefix attribute body");
				attrib.prefix.append(data[prefixStart:prefixEnd].strip());
				tokEnd = prefixEnd;
				next();
				skip(")");
			}	break;

			case "tp_self": {
				next();
				skip("(");
				local prefixStart = tokStart;
				local prefixEnd = data.findmatch("(", ")", prefixStart);
				if (prefixEnd < 0)
					err("Missing end-of-tp_self attribute body");
				attrib.tpSelfExpr = data[prefixStart:prefixEnd].strip();
				tokEnd = prefixEnd;
				next();
				skip(")");
			}	break;

			case "custom_unsupported_impl_name":
				next();
				skip("(");
				attrib.customUnsupportedImplName = parseSymbol();
				skip(")");
				break;

			case "operator": {
				next();
				skip("(");
				attrib.operatorSpecs.extend(parseOperatorSpecs());
				skip(")");
			}	break;

			case "declNameAlias": {
				next();
				skip("(");
				do {
					attrib.declNameAliases.append(parseString());
					if (tok != ",")
						break;
					next();
				} while (tok && tok != ")");
				skip(")");
			}	break;

			case "alias": {
				next();
				skip("(");
				do {
					attrib.aliases.append(parseMethodHintAlias());
					if (tok != ",")
						break;
					next();
				} while (tok && tok != ")");
				skip(")");
			}	break;

			default:
				err(f"Unknown attribute: {repr tok}");
			}
			if (tok != ",")
				break;
			next();
		}
	}

	public parseNativeMethodSpecialImplementation(method: NativeMethod) {
		local tag = parseSymbol();
		if (tok == "=") {
			next();
			resetContext();
			parseAttribs();
			local impl: NativeMethodImpl;
			if (isstring) {
				impl = NativeMethodImpl(alias: parseString());
			} else {
				local implStart = tokStart;
				local implEnd;
				if (tok == "{") {
					implEnd = data.findmatch("{", "}", implStart + 1);
					if (implEnd < 0) {
						err(f"Missing '\}' to terminate block-implementation {repr tag} of {repr method.name}");
					}
					++implEnd;
				} else {
					implEnd = data.findmatch("{", "}", implStart);
					if (implEnd < 0) {
						err(f"Missing '\}' to terminate return-implementation {repr tag} of {repr method.name}");
					}
				}
				local implBody = data[implStart:implEnd];
				if (!implBody.startswith("{")) {
					if (implBody.startswith("return")) {
						implBody = f"\{\n\t{implBody.rstrip(";")};\n\}";
					} else {
						implBody = f"\{\n\treturn {implBody};\n\}";
					}
				}
				impl = NativeMethodImpl(implBody);
				tokEnd = implEnd;
				next();
			}
			impl.implPrefix = attrib.prefix;
			tag = method.normalizeSymbolName(tag);
			if (!method.customImpls.setnew(tag, impl))
				err(f"Custom impl {repr tag} defined multiple times");
			return;
		}
		skip("(");
		local impl: string;
		if (tok == "auto") {
			next();
			local spec = none;
			if (tok == "(") {
				next();
				spec = parseString();
				skip(")");
			}
			switch (tag) {

			case "unsupported": {
				local methodHint: MethodHint = method.methodHint;
				local seqClass = methodHint.guessSeqClass();
				if (spec is none)
					spec = methodHint.name;
				if (seqClass is none)
					err(f"Unable to guess sequence class of {repr method.name}");
				impl = f"err_{seqClass}_unsupportedf({method.params.first.name}, \"{
					spec.encode("c-escape")
				}({", ".join(
					for (local x: method.params[1:])
						getCTypeFormatReprCode(x.typ, x.typAfter)
				)})\"{((
					for (local x: method.params[1:])
						f", {x.name}"
				) + ...) ?? ""})";
			}	break;

			default:
				err(f"Unknown implementation tag %\{{tag}(auto)\}");
				break;
			}
		} else if (isstring) {
			impl = parseString();
		} else {
			local implStart = tokStart;
			local implEnd = data.findmatch("(", ")", implStart + 1);
			if (implEnd < 0)
				err(f"Missing '\}' to terminate implementation of {repr method.name}");
			impl = data[implStart:implEnd].strip();
			tokEnd = implEnd;
			next();
		}

		/* Automatically wrap in statement if not already done. */
		if (tag.endswith("_alias")) {
			impl = method.normalizeSymbolName(impl);
		} else if (!impl.startswith("{")) {
			if (impl.restartswith(r"return\b")) {
				impl = f"\{\n\t{impl.rstrip(";")};\n\}";
			} else if (method.returnType.endswith("*")) {
				impl = f"\{\n\t{impl};\n\treturn NULL;\n\}";
			} else if (method.returnType in ["int", "Dee_ssize_t"]) {
				impl = f"\{\n\treturn {impl};\n\}";
			} else {
				impl = f"\{\n\treturn ({
					method.returnType.rereplace(r"\b__restrict\b", "")
				}){impl};\n\}";
			}
		}

		switch (tag) {
		case "callattr":
			method.callAttrImpl = NativeMethodImpl(impl);
			break;
		case "callattr_alias":
			method.callAttrImpl = NativeMethodImpl(alias: impl);
			break;
		case "unsupported":
			method.unsupportedImpl = NativeMethodImpl(impl);
			break;
		case "unsupported_alias":
			method.unsupportedImpl = NativeMethodImpl(alias: impl);
			break;
		default:
			err(f"Unknown implementation tag {repr tag}");
			break;
		}
		skip(")");
	}

	public resetContext() {
		attrib = _SpecParserAttrib();
	}

	public parsePercentDirectives() {
		for (;;) {
			parsePercentDirective();
			if (tok != ",")
				break;
			next();
		}
	}

	public parsePercentDirective() {
		switch (tok) {

		case "define": {
			next();
			skip("(");
			local name = parseSymbol();
			skip("=");
			local bodyStart = tokStart;
			local bodyEnd = data.findmatch("(", ")", bodyStart);
			if (bodyEnd < 0)
				err(f"Missing end-of-body for macro {repr name}");
			local body = data[bodyStart:bodyEnd].strip();
			if (!MACROS.setnew(name, body)) {
				if (MACROS[name] != body)
					err(f"Macro {repr name} re-defined with different body");
			}
			tokEnd = bodyEnd;
			next();
			skip(")");
		}	break;

		case "include": {
			next();
			skip("(");
			local filename = posix.joinpath(posix.headof(this.filename), parseString());
			skip(")");
			local data = File.open(filename, "rb").readall().unifylines().decode("utf-8");
			local ctx = saveParserContext();
			try {
				this.filename = filename;
				this.data = data;
				this.dataLen = #data;
				this.tokEnd = 0;
				this.next();
				loadMethodHints();
			} finally {
				restoreParserContext(ctx);
			}
		}	break;

		default:
			err(f"Unknown directive %[{tok} ...]");
			break;
		}
	}

	public parseNativeOperatorName(): NativeOperatorName {
		local result = NativeOperatorName();
		local field = parseFieldDesc();
		if (tok == "->") {
			next();
			result.table = field;
			result.field = parseFieldDesc();
		} else {
			result.field = field;
		}
		return result;
	}

	public parseNativeOperatorNames(): {NativeOperatorName...} {
		if (tok == "[") {
			next();
			 while (tok && tok != "]") {
				yield parseNativeOperatorName();
				if (tok != ",")
					break;
				next();
			}
			skip("]");
		} else {
			yield parseNativeOperatorName();
		}
	}

	@@Parses the `...` in contents in `%{...}` of a native operator definition
	public parseNativeOperatorImplementation(method: NativeOperator) {
		if (tok == "using") {
			next();
			local impl: NativeOperatorImpl = NativeOperatorImpl(
					dependencies: parseNativeOperatorNames().frozen);
			if (tok == ":") {
				next();
				resetContext();
				parseAttribs();
				require("{");
				local implStart = tokStart;
				local implEnd = data.findmatch("{", "}", implStart + 1);
				if (implEnd < 0)
					err(f"Missing '\}' to terminate implementation of '{method.name.locExpr}'");
				++implEnd;
				impl.impl = NativeMethodImpl(
						data[implStart:implEnd].strip(),
						implPrefix: attrib.prefix);
				tokEnd = implEnd;
				next();
			} else if (tok == "=") {
				next();
				impl.impl = NativeMethodImpl(alias: parseSymbol());
			} else {
				err(f"Expected ':' or '=' after dependency in native operator implementation, but for {repr tok}");
			}
			method.impls.append(impl);
		} else if (tok == "class") {
			local uImplName = "";
			next();
			if (tok != "{") {
				uImplName = parseSymbol();
				skip(":");
			}
			if (uImplName in method.usrtypeImpls) {
				err(f"User-type implementation {repr uImplName
					} already defined for '{method.name.locExpr}'");
			}
			local impl: NativeMethodImpl;
			if (tok == "=") {
				next();
				impl = NativeMethodImpl(alias: parseSymbol());
			} else {
				resetContext();
				parseAttribs();
				require("{");
				local implStart = tokStart;
				local implEnd = data.findmatch("{", "}", implStart + 1);
				if (implEnd < 0)
					err(f"Missing '\}' to terminate implementation of '{method.name.locExpr}'");
				++implEnd;
				impl = NativeMethodImpl(
						data[implStart:implEnd].strip(),
						implPrefix: attrib.prefix);
				tokEnd = implEnd;
				next();
			}
			method.usrtypeImpls[uImplName] = impl;
		} else {
			err(f"Expected 'using' or 'class' for native operator implementation, but got {repr tok}");
		}
	}

	public parseNativeOperator() {
		for (;;) {
			switch (tok) {
			case "":
			case "}":
				return;

			case ";":
				next();
				resetContext();
				break;

			case "[[":
				next();
				parseAttrib();
				skip("]]");
				break;

			case "%":
				next();
				skip("[");
				parsePercentDirectives();
				skip("]");
				break;

			default: {
				if (!tok.issymbol())
					err(f"Unexpected top-level token: {repr tok}");
				local returnTypeStart = tokStart;
				while (tok in _C_TYPENAME_TOKENS)
					next();
				do {
					next();
				} while (tok in _C_TYPENAME_TOKENS);
				local returnTypeEnd = tokStart;
				local returnType = data[returnTypeStart:returnTypeEnd].strip();
				local operatorName: NativeOperatorName = parseNativeOperatorName();
				local method: NativeOperator = NativeOperator(
						returnType: returnType,
						wunused: attrib.wunused,
						cc: attrib.cc,
						tpSelfExpr: attrib.tpSelfExpr,
						name: operatorName,
						customUnsupportedImplName: attrib.customUnsupportedImplName);
				if (!NATIVE_OPERATORS.setnew(operatorName, method))
					err(f"Native operator '{operatorName.locExpr}' was already defined");
				skip("(");
				while (tok && tok != ")") {
					method.params.append(parseNativeMethodParam());
					if (tok != ",")
						break;
					next();
				}
				skip(")");
				while (tok == "%") {
					next();
					skip("{");
					parseNativeOperatorImplementation(method);
					skip("}");
				}
				if (tok == "=") {
					next();
					method.operatorName = parseSymbol();
				}
				skip(";");
				method._makeTyped();
				resetContext();
			}	break;

			}
		}
	}

	public loadMethodHints() {
		for (;;) {
			switch (tok) {

			case "":
				return;

			case "operator":
				next();
				skip("{");
				do {
					parseNativeOperator();
				} while (tok !in ["", "}"]);
				skip("}");
				break;

			case ";":
				next();
				resetContext();
				break;

			case "[[":
				next();
				parseAttrib();
				skip("]]");
				break;

			case "%":
				next();
				skip("[");
				parsePercentDirectives();
				skip("]");
				break;

			default: {
				if (!tok.issymbol())
					err(f"Unexpected top-level token: {repr tok}");
				local returnTypeStart = tokStart;
				while (tok in _C_TYPENAME_TOKENS)
					next();
				do {
					next();
				} while (tok in _C_TYPENAME_TOKENS);
				local returnTypeEnd = tokStart;
				local returnType = data[returnTypeStart:returnTypeEnd].strip();
				if (tok == "=" && returnType.issymbol()) {
					/* Define "selectImpl" of a NativeMethod */
					local nativeMethod = NATIVE_METHOD_HINTS.get(returnType);
					if (nativeMethod is none)
						err(f"Unknown native method {repr returnType}");
					if (nativeMethod.selectImpl !is none)
						err(f"Native method {repr returnType} already has its select-impl defined");
					next();
					require("{");
					local selectImplStart = tokStart;
					local selectImplEnd = data.findmatch("{", "}", selectImplStart + 1);
					if (selectImplEnd < 0)
						err(f"Missing trailing '\}' after select-impl of {repr returnType}");
					++selectImplEnd;
					nativeMethod.selectImpl = data[selectImplStart:selectImplEnd].strip();
					tokEnd = selectImplEnd;
					next();
					skip(";");
					continue;
				}
				if (tok in ["(", "->"] && returnType.issymbol()) {
					local docStart = tokStart;
					local docEnd;
					if (tok == "(") {
						docEnd = data.findmatch("(", ")", docStart + 1);
						if (docEnd < 0)
							err("Missing closing ')' for doc string");
						docEnd = data.findany({"{", ";"}, docEnd);
					} else {
						docEnd = data.findany({"{", ";"}, docStart);
					}
					if (docEnd < 0)
						err("Missing '{' or ';' after doc string");
					local methodHint: MethodHint = MethodHint(
						name: returnType,
						attr: attrib.attr ?? returnType,
						doc: data[docStart:docEnd].strip().lsstrip("()").rsstrip("?O"),
						aliases: attrib.aliases,
						kw: attrib.kw,
						getset: attrib.getset,
						declNameAliases: attrib.declNameAliases,
					);
					if (data[docEnd] == "{") {
						local nativeBodyStart = docEnd;
						local nativeBodyEnd = data.findmatch("{", "}", nativeBodyStart + 1);
						if (nativeBodyEnd < 0)
							err(f"Missing '\}' for body of call2native-impl of {repr methodHint.name}");
						++nativeBodyEnd;
						local call2native = NativeMethod(
							wunused: attrib.wunused,
							returnType: "DREF DeeObject *",
							cc: "DCALL",
							params: [
								NativeMethodParam("DeeObject *__restrict", "self", true),
								NativeMethodParam("size_t", "argc"),
								NativeMethodParam("DeeObject *const *", "argv"),
							],
							callAttrImpl: NativeMethodImpl(data[nativeBodyStart:nativeBodyEnd].strip()),
							_methodHint: WeakRef(methodHint));
						if (attrib.kw)
							call2native.params.append(NativeMethodParam("DeeObject *", "kw"));
						methodHint.call2native = call2native;
						tokEnd = nativeBodyEnd;
						next();
					} else {
						if (!methodHint.getset)
							err(f"Method {repr methodHint.name} has no default body, and isn't a [[getset]]");
						if (methodHint.kw)
							err(f"Method {repr methodHint.name} is marked as [[getset]] and [[kw]]");
						methodHint.call2native = none;
						tokEnd = docEnd;
						next();
						skip(";");
					}
					if (!METHOD_HINTS.setnew(methodHint.name, methodHint))
						err(f"Method hint {repr methodHint.name} was already defined");
					resetContext();
					continue;
				}

				local method: NativeMethod = NativeMethod(
						returnType: returnType,
						wunused: attrib.wunused,
						cc: attrib.cc,
						getsetMember: attrib.getsetMember,
						operatorSpecs: attrib.operatorSpecs);
				local name1 = parseSymbol();
				if (tok == ".") {
					local methodHint: MethodHint = METHOD_HINTS.get(name1);
					if (methodHint is none)
						err(f"Unknown method hint {repr name1}");
					if (method.getsetMember) {
						if (!methodHint.getset) {
							err(f"getset_member attribute specified on method linked against {
									repr name1}, which isn't a getset");
						}
						if (method.getsetMember in methodHint.getsetCallbacks) {
							// Nah. This is OK because of getfirst + trygetfirst
							/*err(f"getset_member({repr method.getsetMember}) or {
								repr name1} was already defined");*/
						} else {
							methodHint.getsetCallbacks.append(method.getsetMember);
						}
					}
					next();
					method.name = parseSymbol();
					method._methodHint = WeakRef(methodHint);
					if (!methodHint.nativeHints.setnew(method.name, method))
						err(f"Method hint {repr methodHint.name} in {repr name1} was already defined");
				} else {
					method.name = name1;
					if (!ANONYMOUS_METHOD_HINTS.setnew(name1, method))
						err(f"Anonymous method hint {repr name1} was already defined");
				}
				if (!NATIVE_METHOD_HINTS.setnew(method.name, method))
					err(f"Native method hint {repr method.name} was already defined");
				skip("(");
				while (tok && tok != ")") {
					method.params.append(parseNativeMethodParam());
					if (tok != ",")
						break;
					next();
				}
				skip(")");
				while (tok == "%") {
					next();
					skip("{");
					parseNativeMethodSpecialImplementation(method);
					skip("}");
				}
				resetContext();
				parseAttribs();
				if (tok == "=") {
					next();
					if (method.callAttrImpl is bound)
						err(f"Callattr implementation of {repr method.name} defined multiple times");
					method.callAttrImpl = NativeMethodImpl(
							alias: method.normalizeSymbolName(parseSymbol()),
							implPrefix: attrib.prefix);
					if (method.unsupportedImpl is none)
						method.unsupportedImpl = method.callAttrImpl;
					skip(";");
				} else if (tok == "{") {
					local implStart = tokStart;
					local implEnd = data.findmatch("{", "}", implStart + 1);
					if (implEnd < 0)
						err(f"Missing '\}' to terminate implementation of {repr method.name}");
					if (method.callAttrImpl is bound)
						err(f"Callattr implementation of {repr method.name} defined multiple times");
					++implEnd;
					method.callAttrImpl = NativeMethodImpl(
							data[implStart:implEnd].strip(),
							implPrefix: attrib.prefix);
					tokEnd = implEnd;
					next();
				} else {
					if (method.callAttrImpl !is bound)
						method.callAttrImpl = none;
					skip(";");
				}
				resetContext();
			}	break;

			}
		}
	}
};

function loadMethodHints() {
	final local FILENAME = posix.joinpath(posix.headof(__FILE__), "method-hints.h");
	final local SPEC_DATA = File.open(FILENAME, "rb").readall().unifylines().decode("utf-8");
	final local parser = _SpecParser(
		data: SPEC_DATA,
		dataLen: #SPEC_DATA,
		filename: FILENAME);
	parser.next();
	parser.loadMethodHints();

	for (local none, native: NATIVE_METHOD_HINTS)
		native.optimize();
	for (local none, native: NATIVE_OPERATORS)
		native.optimize();
}

loadMethodHints();

#ifdef __MAIN__
//printMethodHintDefs();
//printDefaultImplDecls();
//printDefaultImpls();
//printMhCacheNativeMembers();
//printMhCacheAttributeMembers();
printMethodAttributeImpls();
#endif /* __MAIN__ */
