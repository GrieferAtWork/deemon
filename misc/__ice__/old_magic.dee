/* Copyright (c) 2018 Griefer@Work                                            *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement in the product documentation would be  *
 *    appreciated but is not required.                                        *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */
#ifndef NO_AUTO_TARGET
//#define TARGET_386 1
#ifdef __WINDOWS__
#define TARGET_WINDOWS 1
#endif
#endif /* !NO_AUTO_TARGET */

/* Compiler configuration */
local config_format_compiler_messages = false; /* Format GCC warning/error messages to MSVC format. */
local config_generate_preprocessor    = false; /* Generate preprocessor output instead of object files. */
local config_generate_assembly        = false; /* Generate assembly instead of object files. */
local config_compile_single           = <false>; /* Only run one compiler at a time. */
local config_force_rebuild            = <false>; /* Force a full recompilation. */
local config_build_only               = false; /* Don't start emulation once compilation is done. */
local config_debug                    = true; /* Enable compiling with debug information. */
local config_optimize                 = none; /* Otherwise: A string "0", "1", etc... */
local config_max_compilers            = 8; /* Max amount of compilers to run in parallel */
local config_printcmd                 = false;
#ifdef TARGET_386
local config_build_path               = "build/i386-deemon";
#else
local config_build_path               = "build/deemon";
#endif

/* Compiler script options. */
local config_verbose = false;

#ifdef __WINDOWS__
#	define EXE(x) x ".exe"
#	define DLL(x) x ".dll"
#else
#	define EXE(x) x
#	define DLL(x) x ".so"
#endif

#if __DEEMON__ >= 200
import * from deemon;
#endif

/* Paths to used executables */
local executables = dict {
#if defined(TARGET_386) && 1
	"asm"           : EXE("i686-w64-mingw32-gcc"),
	"c"             : EXE("i686-w64-mingw32-gcc"),
	"c++"           : EXE("i686-w64-mingw32-g++"),
	"cpp"           : EXE("i686-w64-mingw32-cpp"),
	"ar"            : EXE("i686-w64-mingw32-ar"),
	"ld"            : EXE("i686-w64-mingw32-ld"),
	"nm"            : EXE("i686-w64-mingw32-nm"),
	"addr2line"     : EXE("i686-w64-mingw32-addr2line"),
	"readelf"       : EXE("i686-w64-mingw32-readelf"),
#else
	"asm"           : EXE("gcc"),
	"c"             : EXE("gcc"),
	"c++"           : EXE("g++"),
	"cpp"           : EXE("cpp"),
	"ar"            : EXE("ar"),
	"ld"            : EXE("ld"),
	"nm"            : EXE("nm"),
	"addr2line"     : EXE("addr2line"),
	"readelf"       : EXE("readelf"),
#endif
};

#include <file>
#include <fs>
#include <util>
#include <process>
#include <thread>
#include <time>
#include <pipe>
#include <sys>
#include <error>
#include <time>

local root_folder = fs::path::head(__FILE__).replace("\\","/").rstrip("/");

#if __has_include("misc/paths.dee")
#include "misc/paths.dee"
#endif

#ifdef __WINDOWS__
function fix_path(rel_prefix,filename) {
	if (filename.startswith("/cygdrive/")) {
		filename = filename[#"/cygdrive/":];
		local drive,none,path = filename.partition("/")...;
		filename = drive.upper()+":/"+path;
		if (filename.lower().startswith(root_folder.lower())) {
			filename = rel_prefix+filename[#root_folder:].lstrip("/\\");
		}
		rel_prefix = "";
	}
#ifdef CONFIG_CYGWIN_ROOT
	if (filename.startswith("/")) {
		filename = CONFIG_CYGWIN_ROOT+filename;
	} else
#endif /* CONFIG_CYGWIN_ROOT */
	{
		filename = rel_prefix+filename;
	}
#ifdef __WINDOWS__
	filename = filename.replace("/","\\");
#endif
	return filename;
}
#endif /* __WINDOWS__ */

function fix_pathstring(path) {
	local pos;
	while ((pos = path.find("/..")) != -1) {
		local end = path.rfind("/",0,pos);
		if (end == -1) break;
		path = path[:end]+path[pos+3:];
	}
	return path;
}
root_folder = fix_pathstring(root_folder);

fs::chdir(root_folder);

local kernel_args = sys.argv[1:];
while (kernel_args && kernel_args.front().startswith("-")) {
	local arg = kernel_args.pop_front();
	if (arg == "--cmd") break;
	switch (arg) {
	case "-f":
	case "--force":
		::config_force_rebuild.set(true);
		break;
	case "-E":
	case "--gen-pp":
		::config_generate_preprocessor = true;
		::config_build_only = true;
		break;
	case "-S":
	case "--asm":
		::config_generate_assembly = true;
		::config_build_only = true;
		break;
	case "--format-error-messages":
		::config_format_compiler_messages = true;
		break;
	case "--optimize":
		::config_optimize = "3";
	case "--ndebug":
		::config_debug = false;
		break;
	case "--single":
	case "-1":
		::config_compile_single.set(true);
		break;
	case "-v":
	case "--verbose":
		config_verbose = true;
		break;
	case "-cmd":
		config_printcmd = true;
		config_compile_single.set(true);
		config_force_rebuild.set(true);
		break;
	default:
		if (arg.startswith("-O")) {
			::config_optimize = arg[2:];
			break;
		}
		print "Unknown argument:",repr arg;
		break;
	}
}

if (config_debug) {
	config_build_path += "-debug";
}



#ifdef TARGET_WINDOWS
local exe_suffix = ".exe";
local dll_suffix = ".dll";
#else
local exe_suffix = "";
local dll_suffix = ".so";
#endif
#undef EXE
#undef DLL
#define EXE(x) (x "")+exe_suffix
#define DLL(x) (x "")+dll_suffix

if (config_printcmd) {
	function print_default(name,def) {
		print "if ! [[ -v "+name+" ]]; then "+name+"="+def+"; fi";
	}
	local defaults = copy executables;
	executables["asm"]       = "${ASM}";
	executables["c"]         = "${CC}";
	executables["c++"]       = "${CXX}";
	executables["cpp"]       = "${CPP}";
	executables["ar"]        = "${AR}";
	executables["ld"]        = "${LD}";
	executables["nm"]        = "${NM}";
	executables["addr2line"] = "${ADDR2LINE}";
	executables["readelf"]   = "${READELF}";
	print "#!/bin/bash";
	print "if ! [[ -v RUN ]]; then";
	print "	function RUN {";
	print "		echo $*";
	print "		$*";
	print "	}";
	print "fi";
	print "case \"$(uname -s)\" in";
	print "	CYGWIN*)";
	print "		DEFAULT_EXE=\".exe\"";
	print "		DEFAULT_DLL=\".dll\"";
	print "		;;";
	print "	*)";
	print "		DEFAULT_EXE=\"\"";
	print "		DEFAULT_DLL=\".so\"";
	print "		;;";
	print "esac";

	for (local key,name: executables) {
		try {
			local var = name.scanf("${%[^}]}")...;
			print_default(var,
				"\"RUN "+defaults[key]
#ifdef __WINDOWS__
				.rsstrip(".exe")+
#endif
				"\"");
		} catch (...) {
		}
	}
	print_default("MKDIR","mkdir");
	print_default("EXE","${DEFAULT_EXE}");
	print_default("DLL","${DEFAULT_DLL}");
	exe_suffix = "${EXE}";
	dll_suffix = "${DLL}";
}




#define SYNC(x) \
  ({ local _o = config_compile_single.get(); \
     ::config_compile_single.set(true); \
     (x); \
     ::config_compile_single.set(_o); \
  })

/* List of files that will/have changed since the
 * last compilation, until the end of the current
 * (Yes: This also contains files that will have changed later) */
local _mtime_cache = dict {};
local _mtime_change_year = 9999;
function set_file_changed(filename) {
#ifdef __WINDOWS__
	filename = fs::path::abs(filename,root_folder).replace("/","\\");
#else
	filename = fs::path::abs(filename,root_folder);
#endif
	_mtime_cache[filename] = time.years(_mtime_change_year++);
}
function unset_file_changed(filename) {
#ifdef __WINDOWS__
	filename = fs::path::abs(filename,root_folder).replace("/","\\");
#else
	filename = fs::path::abs(filename,root_folder);
#endif
	_mtime_cache[filename] = time(1);
}
function fast_getmtime(filename) {
	local result;
#ifdef __WINDOWS__
	filename = fs::path::abs(filename,root_folder).replace("/","\\");
#ifdef CONFIG_CYGWIN_ROOT
	if (filename.startswith(CONFIG_CYGWIN_ROOT))
		return time.years(0);
#endif
	try return _mtime_cache[filename]; catch (...);
	try result = fs::getmtime(filename);
	catch (...) result = fs::getmtime(filename+".exe");
#else
	filename = fs::path::abs(filename,root_folder);
	try return _mtime_cache[filename]; catch (...);
	result = fs::getmtime(filename);
#endif
	_mtime_cache[filename] = result;
	return result;
}
local existing_paths = [];
function fast_mkdir(path) {
	path = fs::path::abs(path,root_folder);
	if (path == root_folder)
		return;
	if (path !in existing_paths) {
		existing_paths.append(path);
		if (config_printcmd) {
			print "${MKDIR}",fs::path::rel(path,root_folder);
		} else {
			try fs::mkdir(path);
			catch (...);
		}
	}
}
function force_mkdir(path) {
	path = fs::path::exctrail(path);
	local head = fs::path::head(path);
	local tail = fs::path::tail(path);
	if (head && (config_printcmd || !fs::exists(head)))
		force_mkdir(head);
	try fast_mkdir(path); catch (...);
}

local print_lock = mutex();
local running_processes = [];
#define wait_all_processes() \
	({ while (#running_processes) thread.sleep(1); })
#define SYNC_PRINT(...) \
	({	if (!config_printcmd) { \
			print_lock.acquire(); \
			try { \
				print __VA_ARGS__; \
			} finally { \
				print_lock.release(); \
			} \
		} \
	})

function do_print_process(proc) {
	print proc.exe," ".join(proc.argv);
}
function do_start_process(proc) {
	if (config_printcmd) {
		do_print_process(proc);
		return;
	}
	if (config_verbose) {
		print "PROCESS:",proc.exe," ".join(proc.argv);
	}
	proc.start();
}
function get_exe(name) {
	if (name.startswith("/")) {
		return root_folder+name;
	}
	if ("/" in name || "\\" in name) {
		return name;
	}
	if (name.startswith("PATH:")) {
		return name[#"PATH:":];
	}
	return executables[name];
}
function start_io_process(proc,process_callback) {
	if (config_printcmd) {
		do_print_process(proc);
		return;
	}
	local process_out_read,process_out_write = pipe.new()...;
	proc.stdout = process_out_write;
	//proc.stderr = process_out_write;
	do_start_process(proc);
	process_out_write.close();
	while (#running_processes > config_max_compilers) thread.sleep(1);
	running_processes.append(proc);
	local t = thread([]{
		try {
			process_callback(process_out_read);
			local error = proc.join();
			/* remove may fail sporadically in an SMP environment... (sorry about that) */
			while (!running_processes.remove(proc));
			if (error != 0) {
				print "Process failed:",repr proc.cmd;
				sys.exit(error);
			}
		} catch (e...) {
			print "Process failed:",e;
			print repr proc.cmd;
			sys.exit(1);
		}
	});
	t.start();
	if (::config_compile_single.get()) t.join();
}
function fix_binutils(filename) {
	local start = filename.rfind("/binutils/");
	if (start != -1) {
		filename = fix_pathstring(filename[start:]);
		filename = "${ROOT}"+filename;
	}
	return filename;
}

function start_process(proc,proj) {
	if (config_printcmd) {
		do_print_process(proc);
		return;
	}
	local compiler_out_read,compiler_out_write = none...;
	if (config_format_compiler_messages) {
		compiler_out_read,compiler_out_write = pipe.new()...;
		proc.stdout = compiler_out_write;
		proc.stderr = compiler_out_write;
	}
	do_start_process(proc);
	compiler_out_write.close();
	while (#running_processes > config_max_compilers) thread.sleep(1);
	running_processes.append(proc);

	local t = thread([]{
		try {
			if (config_format_compiler_messages) {
				for (local line: compiler_out_read) {
					local filename,lno,col,rest;
					try {
						filename,lno,col,rest = line.scanf("%[^:]:%[^:]:%[^:]:%[^]")...;
						if (filename.endswith("/ld") || filename.endswith("-ld")) {
							rest = "{} ({})".format({ rest.strip(),repr fix_binutils(filename.strip()) });
							filename = lno;
							lno = col;
							col = none;
						}
#ifdef __WINDOWS__
						if (lno.startswith("/cygdrive/")) {
							local a,none,b = lno[#"/cygdrive/":].partition("/")...;
							SYNC_PRINT("{}:\\{}({}) : error : <{}> : {} ({})".format({
								a.upper(),b.replace("/","\\"),col,proj._name,
								rest,filename
							}));
							continue;
						}
#endif
					} catch (...) try {
						filename,lno,rest = line.scanf("%[^:]:%[^:]:%[^]")...;
						col = none;
					} catch (...) try {
						filename,lno,rest = line.scanf("%[^:]:%[^,]%[^]")...;
						col = none;
					} catch (...) {
						SYNC_PRINT(line,);
						continue;
					}
					if (!lno.isdigit()) {
						if (filename.endswith("/ld") || filename.endswith("-ld")) {
							rest = "{} ({})".format({ rest.strip(),repr fix_binutils(filename.strip()) });
							filename = lno;
							lno      = "0";
							if (" " in filename && "/" !in filename) {
								rest     = filename.strip()+": "+rest.strip();
								filename = proj._outfile;
							}
						} else {
							SYNC_PRINT(line,);
							continue;
						}
					}
					filename = filename.strip();
					rest = rest.strip();
					local const inc_prefix = "In file included from ";
					local const frm_prefix = "from ";
					if (filename.startswith(inc_prefix)) {
						rest = "warning : "+inc_prefix+"here "+rest;
						filename = filename[#inc_prefix:];
					}
					if (filename.startswith(frm_prefix)) {
						rest = "warning : "+inc_prefix+"here "+rest;
						filename = filename[#frm_prefix:];
					}
#ifdef __WINDOWS__
					filename = fix_path("../",filename);
#endif /* __WINDOWS__ */
					local msg_class = "warning";
					if (col && !col.isdigit()) {
						rest = col.strip()+" : "+rest.strip();
						col = "";
					}
					if (rest.startswith("note")) {
						rest = rest[#"note":];
					} else if (rest.startswith("warning")) {
						rest = rest[#"warning":];
					} else if (rest.startswith("error")) {
						rest = rest[#"error":];
						msg_class = "error";
					} else {
						if (rest.startswith("multiple definition of"))
							msg_class = "error";
					}
					rest = rest.strip(" :\t\r\n");
					if (col) {
						SYNC_PRINT("{}({},{}) : {} : <{}> : {}".format({
							filename,lno,col,msg_class,proj._name,rest
						}));
					} else {
						SYNC_PRINT("{}({}) : {} : <{}> : {}".format({
							filename,lno,msg_class,proj._name,rest
						}));
					}
				}
			}
			local error = proc.join();
			/* remove may fail sporadically in an SMP environment... (sorry about that) */
			while (!running_processes.remove(proc));
			if (error != 0) {
				print "Process failed:",repr proc.cmd;
				sys.exit(error);
			}
		} catch (e...) {
			print "Process failed:",e;
			print repr proc.cmd;
			sys.exit(1);
		}
	});
	t.start();
	if (::config_compile_single.get()) t.join();
}

class Source
#if __DEEMON__ >= 200
	: OldUserClass from d200
#endif
{
	this(p_exe,p_flags,c_flags,file) {
		/* NOTE: For 'justsym'-style sources, '_exe_p' is the 'nm' executable. */
		this._exe_p   = p_exe;
		this._p_flags = copy p_flags;
		this._c_flags = copy c_flags;
		this._file    = file;
		this._changed = false;
	}
	get_dep_file(proj) -> config_build_path+"/"+proj._name+"/"+this._file.replace("/",".")+".mf";
	get_pp_file(proj)  -> config_build_path+"/"+proj._name+"/"+this._file.replace("/",".")+".E";
	get_asm_file(proj) -> config_build_path+"/"+proj._name+"/"+this._file.replace("/",".")+".S";
	get_sym_file(proj) -> config_build_path+"/"+proj._name+"/"+this._file.replace("/",".")+".nm";
	get_o_file(proj)   -> config_build_path+"/"+proj._name+"/"+this._file.replace("/",".")+".o";
	get_obj_file(proj) {
		if (config_generate_assembly) {
			return this.get_asm_file(proj);
		} else if (config_generate_preprocessor) {
			return this.get_pp_file(proj);
		} else {
			return this.get_o_file(proj);
		}
	}

	get_dep(proj) {
		local text = file.open(this.get_dep_file(proj),"r").read();
		text = text.replace("\r\n","\n").replace("\r","\n");
		text = text.replace("\\\n","").replace("\n"," ");
		text = text.partition(":")[2];
		for (local part: text.split(" ")) {
			if (part) {
#ifdef __WINDOWS__
				part = fix_path("",part);
#endif /* __WINDOWS__ */
				yield part;
			}
		}
	}

	must_perform_action(proj,output_file) {
		if (::config_force_rebuild.get()) return true;
		try {
			local mtime = fast_getmtime(output_file);
			for (local d: this.get_dep(proj)) {
				if (fast_getmtime(d) > mtime)
					return true;
			}
		} catch (...) {
			return true;
		}
		return false;
	}
	must_perform_action_nodep(proj,output_file) {
		if (::config_force_rebuild.get()) return true;
		try {
			if (fast_getmtime(this._file) >
			    fast_getmtime(output_file))
				return true;
		} catch (...) {
			return true;
		}
		return false;
	}

	must_compile(proj) -> this.must_perform_action(proj,this.get_obj_file(proj));
	must_preprocess(proj) -> this.must_perform_action(proj,this.get_pp_file(proj));
	must_justsym(proj) -> this.must_perform_action_nodep(proj,this.get_sym_file(proj));

	unset_changes(proj) {
		unset_file_changed(this._file);
		try {
			for (local d: this.get_dep(proj)) {
				unset_file_changed(d);
			}
		} catch (...) {
		}
	}
	compile(proj) {
		SYNC_PRINT("["+proj.logname()+"] Compiling",repr this._file);
		local objfile = this.get_obj_file(proj);
		local depfile = this.get_dep_file(proj);
		local compiler_args = ["-o",objfile,"-MD","-MF",depfile];
		force_mkdir(fs::path::head(objfile));
		if (this._exe_p !is none) {
			/* TODO: Pass input through custom preprocessor. */
		} else {
			compiler_args.extend(this._p_flags);
		}
		compiler_args.extend(this._c_flags);
		if (config_optimize !is none) {
			compiler_args.append("-O"+config_optimize);
		}
		if (config_generate_assembly) {
			compiler_args.append("-S");
		} else if (config_generate_preprocessor) {
			compiler_args.append("-E");
		} else {
			compiler_args.append("-c");
		}
		compiler_args.append(this._file);
		local proc = process(get_exe(proj._exe_c),compiler_args);
		start_process(proc,proj);
		this.unset_changes(proj);
	}
	preprocess(proj) {
		SYNC_PRINT("["+proj.logname()+"] Proprocessing",repr this._file);
		local ppfile = this.get_pp_file(proj);
		local depfile = this.get_dep_file(proj);
		local pp_args = ["-E","-o",ppfile,"-MMD","-MF",depfile];
		force_mkdir(fs::path::head(ppfile));
		local used_pp = this._exe_p;
		if (used_pp is none) used_pp = proj._exe_cpp;
		pp_args.extend(this._p_flags);
		pp_args.append(this._file);
		local proc = process(get_exe(used_pp),pp_args);
		start_process(proc,proj);
		this.unset_changes(proj);
	}
	justsym(proj) {
		SYNC_PRINT("["+proj.logname()+"] Creating symbol list for",repr this._file);
		local nmfile = this.get_sym_file(proj);
		local nm_args = ["-g",this._file];
		force_mkdir(fs::path::head(nmfile));
		nm_args.extend(this._p_flags);
		local proc = process(get_exe(this._exe_p),nm_args);
		start_io_process(proc,[](process_pipe){
			local output = file.open(nmfile,"w");
			for (local line: process_pipe) {
				local addr,name;
				try addr,none,name = line.scanf("%[^ ] %[^ ] %[^]")...;
				catch (...) {
					print "Unrecognized NM line:",repr line;
					continue;
				}
				output.write("PROVIDE({} = 0x{});\n".format({
					name.strip(),addr
				}));
			}
			output.close();
		});
	}
};

local projects = [];

function files(text,def_file) {
	if (text is list) {
		for (local e: text)
			yield files(e,def_file);
	} else {
		if (text && text.startswith("/")) {
			text = text[1:];
		} else {
			text = fs::path::rel(fs::path::abs(text,
			                     fs::path::head(def_file)),
			                     root_folder);
		}
		text = text.replace("\\","/");
		if ("*" in text) {
			local head = fs::path::head(text);
			try {
				for (local q: fs::query(text)) {
					yield head+q;
				}
			} catch (...) {
			}
		} else {
			yield text;
		}
	}
}

class Project
#if __DEEMON__ >= 200
	: OldUserClass from d200
#endif
{
	this(name) {
		this._name       = name;
		this._sources    = []; /* Array of 'Source' objects. */
		this._l_flags    = []; /* Linker flags. */
		this._l_deps     = []; /* Shared library dependencies. */
		this._l_requires = []; /* Additional files who's absense requires a relink. */
		this._l_objs     = []; /* Additional object files. */
		this._l_script   = []; /* Linker script used ('Source' file). */
		this._l_jstsym   = []; /* Static link descriptors for '--just-symbols=...'. */
		this._outfile    = "bin/"+name; /* Binary output path. */
		this._exe_c      = "c"; /* Used compiler. */
		this._exe_cpp    = "cpp"; /* Used preprocessor. */
		this._exe_a      = none; /* Archiver executable (when 'none', do linking with '_exe_l'). */
		this._exe_l      = "c"; /* Used linker. */
		this._cus_link   = none; /* Custom linker commandline. ("ld -o {output} {objects}") */
		this._exe_nm     = "nm"; /* Used linker. */
		this._modes      = []; /* Active user-modes. */
		this._relink     = false; /* Set to true if the project must be re-linked. */
		this._created    = false; /* Set to true when the project was been linked. */
		this._deps       = []; /* Dependencies on other projects */
		::projects.append(this);
	}
	logname() {
		return "{} ({})".format({ this._name, this._outfile });
	}
	add_source(p_exe,p_flags,c_flags,fps) {
		for (local f: fps) {
			this._sources.append(Source(p_exe,p_flags,c_flags,f));
		}
	}
	add_linker_scripts(p_exe,p_flags,c_flags,filename) {
		for (local f: filename) {
			this._l_script.append(Source(p_exe,p_flags,c_flags,f));
		}
	}
	add_justsyms(filename) {
		for (local f: filename) {
			this._l_jstsym.append(Source(this._exe_nm,[],[],f));
		}
	}
	will_relink() {
		if (!this._relink) {
			set_file_changed(this._outfile);
			this._relink = true;
			return true;
		}
		return false;
	}
	reset_changes() {
		this._relink = false;
		for (local src: this._sources) src._changed = false;
		for (local src: this._l_jstsym) src._changed = false;
		for (local src: this._l_script) src._changed = false;
	}
	determine_changes() {
		local result = false;
		for (local src: this._sources) {
			if (src.must_compile(this)) {
				src._changed = true;
				set_file_changed(src.get_obj_file(this));
				set_file_changed(src.get_dep_file(this));
				if (this.will_relink()) result = true;
			}
		}
		for (local src: this._l_jstsym) {
			if (src.must_justsym(this)) {
				src._changed = true;
				set_file_changed(src.get_sym_file(this));
				if (this.will_relink()) result = true;
			}
		}
		for (local script: this._l_script) {
			if (script.must_preprocess(this)) {
				/* Make sure not to generate line directives */
				script._changed = true;
				set_file_changed(script.get_pp_file(this));
				set_file_changed(script.get_dep_file(this));
				if (this.will_relink()) result = true;
			}
		}
		if (result) return true;
		/* Checked for changes in additional object files. */
		try {
			for (local s: this._l_requires) fast_getmtime(s);
			local out_time = fast_getmtime(this._outfile);
			for (local s: this._l_objs) {
				if (out_time < fast_getmtime(s)) {
					return this.will_relink();
				}
			}
		} catch (...) {
			return this.will_relink();
		}
		return false;
	}
	compile_changes() {
		for (local src: this._sources) {
			if (src._changed) {
				src.compile(this);
			}
		}
		for (local script: this._l_script) {
			if (script._changed) {
				/* Make sure not to generate line directives */
				script._p_flags.remove("-P");
				script._p_flags.append("-P");
				script._p_flags.remove("-D__LINKER__");
				script._p_flags.append("-D__LINKER__");
				script.preprocess(this);
				this.will_relink();
			}
		}
	}

	relink() {
		if (!::config_generate_preprocessor &&
		    !::config_generate_assembly) {
			local source_objects = [];
			for (local s: this._sources) {
				source_objects.append(s.get_obj_file(this));
			}
			source_objects.extend(this._l_objs);
			force_mkdir(fs::path::head(this._outfile));
			if (this._exe_a !is none) {
				SYNC_PRINT("["+this.logname()+"] Archiving",repr this._outfile);
				if (this._exe_a == "" && #source_objects == 1) {
					try fs::unlink(this._outfile);
					catch (...);
					fs::copy_(fs::path::abs(source_objects[0],root_folder),
							  fs::path::abs(this._outfile,root_folder));
				} else {
					local archive_flags = [];
					archive_flags.extend(this._l_flags);
					archive_flags.append("rcs",this._outfile);
					archive_flags.extend(source_objects);
					local proc = process(get_exe(this._exe_a),archive_flags);
					start_process(proc,this);
				}
			} else {
				SYNC_PRINT("["+this.logname()+"] Linking",repr this._outfile);
				local linker_flags = ["-o",this._outfile];
				if (config_optimize !is none) {
					linker_flags.append("-O"+config_optimize);
				}
				for (local src: this._l_jstsym) {
					if (src._changed) {
						SYNC(src.justsym(this));
					}
				}
				for (local script: this._l_jstsym) {
					linker_flags.append("--just-symbols="+script.get_sym_file(this));
				}
				for (local script: this._l_script) {
					linker_flags.append("-T",script.get_pp_file(this));
				}
				linker_flags.extend(this._l_flags);
				linker_flags.extend(source_objects);
				/* Make sure that '-lgcc' goes at the end. */
				if ("gcc" in this._l_deps) {
					this._l_deps.remove("gcc");
					this._l_deps.append("gcc");
				}
				for (local lib: this._l_deps)
					linker_flags.append("-l"+lib);
				//print repr linker_flags;
				local proc = process(get_exe(this._exe_l),linker_flags);
				if (this._cus_link !is none) {
					SYNC(start_process(proc,this));
					if (this._cus_link is string) {
						local custom_proc = process(this._cus_link.format({
							.input = this._outfile,
							.root  = root_folder,
						}));
						start_process(custom_proc,this);
					} else {
						this._cus_link(this._outfile);
					}
				} else {
					start_process(proc,this);
				}
			}
		}
		this._created = true;
	}
};

#define FILES(x)         files(x,__FILE__)

/* General project compilation. */
#define BEGIN_NEW      { local _p_flags = []; \
                         local _c_flags = []; \
						 local _p_exe   = <none>;
#define BEGIN          { local _p_flags = copy(__nth(2) _p_flags); \
                         local _c_flags = copy(__nth(2) _c_flags); \
						 local _p_exe   = copy(__nth(2) _p_exe);
#define PROJECT(x)       local _proj = Project(x);
#define PROJ_DEP(x)      _proj._deps.append(x);
#define END            };

/* Build environment configuration */
#define SET_OUTPUT(x)       _proj._outfile = FILES(x)[0];
#define SET_PREPROCESSOR(x) _p_exe.set(x);
#define SET_COMPILER(x)     _proj._exe_c = (x);
#define SET_NM(x)           _proj._exe_nm = (x);
#define SET_ARCHIVER(x)     _proj._exe_a = (x);
#define SET_LINKER(x)       _proj._exe_l = (x);
#define SET_CUSTOM_LINK(x)  _proj._cus_link = (x);

/* Preprocessor utilities. */
#define DEFINE(x)        _p_flags.append("-D"+(x));
#define UNDEF(x)         _p_flags.remove("-D"+(x));
#define P_FLAGS(...)     _p_flags.append(__VA_ARGS__);
#define INCLUDE(x)       _p_flags.extend(for (local _f: FILES(x)) "-I"+_f);
#define UNINCLUDE(x)   { for (local _f: FILES(x)) _p_flags.remove("-I"+_f); }

/* Compiler utilities. */
#define C_FLAGS(...)     _c_flags.append(__VA_ARGS__);
#define SOURCE(x)        _proj.add_source(_p_exe.get(),_p_flags,_c_flags,FILES(x));

/* Linker utilities. */
#define L_FLAGS(...)       _proj._l_flags.append(__VA_ARGS__);
#define LIBPATH(x)         _proj._l_flags.extend(for (local _f: FILES(x)) "-L"+_f);
#define LIB(x)             _proj._l_deps.append(x);
#define UNLIB(x)           _proj._l_deps.remove(x);
#define OBJECT(x)          _proj._l_objs.extend(FILES(x));
#define LINKER_SCRIPT(x)   _proj.add_linker_scripts(_p_exe.get(),_p_flags,_c_flags,FILES(x));
#define STATIC_SYMBOLS(x)  _proj.add_justsyms(FILES(x));
#define LINK_IF_MISSING(x) _proj._l_requires.extend(FILES(x));

try {

	/* Include project definition files. */
	BEGIN_NEW
#ifdef SOURCES
#define __SOURCE_STR2(x) #x
#define __SOURCE_STR(x) __SOURCE_STR2(x)
#		include __SOURCE_STR(SOURCES)
#else
#		include ".sources"
#endif
	END

	function link_and_compile_everything() {
		local result = false;
		for (local p: projects) {
			p.reset_changes();
		}
		{	local found_changes;
			do {
				found_changes = false;
				for (local proj: projects) {
					if (proj.determine_changes()) {
						found_changes = true;
						result        = true;
					}
				}
			} while (found_changes);
		}
		for (local proj: projects)
			proj.compile_changes();

		local link_projects = [];
		local done_projects = [];
		for (local p: projects) {
			if (::config_force_rebuild.get() || p._relink) {
				link_projects.append(p);
			} else {
				done_projects.append(p);
			}
		}
		function was_linked(name) {
			for (local p: done_projects)
				if (p._name == name) return true;
			return false;
		}
		while (link_projects) {
			local linking_projects = [];
			for (local i = 0; i < #link_projects; ) {
				local can_link = true;
				local proj = link_projects[i];
				for (local d: proj._deps) {
					if (!was_linked(d)) {
						can_link = false;
						break;
					}
				}
				if (can_link) {
					linking_projects.append(proj);
					link_projects.erase(i);
				} else {
					++i;
				}
			}
			wait_all_processes();
			if (!linking_projects) break;
			local i = 0;
			function is_linking_project(name) {
				for (local p: linking_projects)
					if (p._name == name) return true;
				return false;
			}
			for (i = 0; i < #linking_projects;) {
				local proj = linking_projects[i];
				proj._relink = false;
				for (local d: proj._deps) {
					local p = none;
					for (p: projects) {
						if (p._name == d) {
							if (p._relink) proj._relink = true;
							break;
						}
					}
					if (proj._relink) break;
				}
				if (!proj._relink) proj.relink();
				if (proj._relink) {
					/* Something has changed. - Must compile/link this project again. */
					linking_projects.erase(i);
				} else {
					++i;
				}
			}
			done_projects.extend(linking_projects);
		}
		if (link_projects) {
			print done_projects;
			print "CANNOT LINK DEPENDENCY LOOP:";
			for (local proj: link_projects) {
				print "   ",proj._name;
				for (local d: proj._deps) {
					if (!was_linked(d)) {
						print "       ",d;
					}
				}
			}
		}
		return result;
	}
	while (link_and_compile_everything()) {
		config_force_rebuild.set(false);
		wait_all_processes();
	}

	wait_all_processes();

} catch (e...) {
	print repr e;
	print repr __builtin_last_traceback();
	sys.exit(0);
}
sys.exit(0);




