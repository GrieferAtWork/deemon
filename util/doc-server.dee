#!/usr/bin/deemon
/* Copyright (c) 2018-2020 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2018-2020 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

import doctext;
import * from doc;
import * from net;
import * from deemon;
import util;
import fs;

function writePageHeader(fp: File, title: string) {
	fp <<
		"<!DOCTYPE html>\r\n"
		"<html>\r\n"
		"<head>\r\n"
			"\t<meta charset=\"UTF-8\">\r\n"
			"\t<link rel=\"stylesheet\" href=\"/style.css\">\r\n"
			"\t<title>{}</title>\r\n"
		"</head>\r\n"
		"<body>\r\n"
		.format({ title });
}
function writePageFooter(fp) {
	fp << "</body>\r\n</html>\r\n";
}
function escapeSpecialHtmlCharacters(text) {
	return text
		.replace("<", "&lt;")
		.replace(">", "&gt;")
		.replace("\n", "<br />\r\n");
}

global docObjectCache: {string: Doc} = Dict();
function getDocByPath(path: string): Doc {
	path = path.lstrip("/");
	local result = docObjectCache.get(path);
	if (result is none) {
		result = Doc(path);
		docObjectCache[path] = result;
	}
	return result;
}

@@Print a type reference
function printTypeRef(fp: File, t: TypeRef) {
	local p = t.path;
	local s = escapeSpecialHtmlCharacters(str t);
	if (p is none) {
		fp << s;
	} else {
		fp << "<a href=" << repr("/modules" + p) << ">" << s << "</a>";
	}
}

@@Print a type reference
function printTypeExpr(fp: File, t: TypeExpr) {
	switch (t.kind) {

	case "E":
		return printTypeRef(fp, t.Etyperef);

	case "C":
		printTypeExpr(fp, t.Ccelltype);
		fp << " with ";
		printTypeExpr(fp, t.Citemtype);
		break;

	case "T":
		if (#t.Ttypes == 1) {
			fp << "(";
			printTypeExpr(fp, t.Ttypes[0]);
			fp << ",)";
		} else {
			fp << "(";
			local is_first = true;
			for (local x: t.Ttypes) {
				if (!is_first) fp << ", ";
				is_first = false;
				printTypeExpr(fp, x);
			}
			fp << ")";
		}
		break;

	case "X": {
		local is_first = true;
		for (local x: t.Xtypes) {
			if (!is_first) fp << " | ";
			is_first = false;
			printTypeExpr(fp, x);
		}
	}	break;

	case "S":
		fp << "{";
		printTypeExpr(fp,t.Stype);
		fp << "...}";
		break;

	default:
		fp	<< "<div class=\"BrokenLink\"><i>"
			<< escapeSpecialHtmlCharacters(t.docstring)
			<< "</i></div>";
		break;
	}
}

@@Print a doc expression
function printExpression(fp: File, t: Expression) {
	/* TODO */
	fp << escapeSpecialHtmlCharacters(str t);
}

@@Print Declaration parameters (if any), as well as the return type
function printDeclarationParameters(fp: File, decl: Declaration) {
	if (decl.isdeleted) {
		fp << " = del";
		return;
	}
	if (decl.isinherited) {
		fp << " = super";
		return;
	}
	local params = decl.parameters;
	if (params !is none) {
		fp << "(";
		local is_first = true;
		for (local par: params) {
			if (!is_first) fp << ", ";
			is_first = false;
			if (par.isvarkwds)
				fp << "**";
			fp << "<i>" << escapeSpecialHtmlCharacters(par.name) << "</i>";
			if (par.isvarargs) {
				fp << "...";
			} else if (par.isoptional) {
				fp << "?";
			}
			fp << ": ";
			printTypeExpr(fp, par.typ);
			local def = par.defexpr;
			if (def !is none) {
				fp << " = ";
				printExpression(fp, def);
			}
		}
		fp << ")";
	}
	local ret = decl.ret;
	if (decl.istypeexplicit || !ret.isnone) {
		fp << ": ";
		printTypeExpr(fp, ret);
	}
}

@@Print a given text segment
function printTextSegment(fp: File, t: TextSegment) {
	fp << "<div class=\"TextSegment\">";
	/* TODO: Do this proper! */
	fp << "<code>";
	fp << escapeSpecialHtmlCharacters(str(t).replace(" ", "&nbsp;"));
	fp << "</code>";
	
	fp << "</div>";
}


@@Lookup a page for the /module/ sub-directory, and write that page to @fp
@@@param: path: The already-split components of the path to lookup
function getModuleRootSubPage(fp: File, path: {string...}) {
	local d = getDocByPath("/".join(path));
	writePageHeader(fp, d.prettypath);
	fp << "<nav><ul>"
		"<li><a href=\"/\">home</a></li><li class=\"sep\">|</li>"
		"<li><a href=\"/modules\">modules</a></li>";
	local linkPath = "/modules";
	for (local x: path[:-1]) {
		linkPath = "{}/{}".format({ linkPath, x });
		local name_start = x.find(":");
		fp << "<li><a href=\"{}\">&gt;{}</a></li>".format({
			linkPath,
			name_start >= 0 ? x[name_start + 1:] : x
		});
	}
	fp << "<li><a href=\"/modules{}\">&gt;{}</a></li>".format({
		d.path,
		d.prettypathname
	});
	fp << "</ul></nav>\r\n<main>\r\n";
	fp << "<h2><b>" << d.kind << "</b>: " << d.typename;
	if (d.istype && d.object is bound) {
		local base = Type.__base__(d.object);
		if (base !is none && base !== Object) {
			base = Doc(base);
			fp << " extends <b>";
			local path = base.path;
			if (path !is none) {
				fp	<< "<a href=\"/modules"
					<< path
					<< "\">"
					<< base.prettyname
					<< "</a>";
			} else {
				fp	<< base.prettyname;
			}
			fp << "</b>";
		}
	}
	fp << "</h2><hr>\r\n<div>";
	local prettyName = d.name;
	local isFirst = true;
	for (local sect: d.docsections) {
		for (local seg: sect.segments) {
			if (seg is Declaration) {
				fp << "<div><code>" << d.kind << " ";
				fp << prettyName;
				if (!prettyName.issymcont(#prettyName - 1))
					fp << " ";
				printDeclarationParameters(fp, seg);
				fp << "</code></div>\r\n";
			} else {
				printTextSegment(fp, seg);
			}
		}
	}
	fp << "</div><hr>\r\n<div><table>";
	local children = List(d);
	children.sort();
	for (local child: children) {
		if (child.isprivate)
			continue; /* Don't enumerate private members. */
		local child_link = "/modules" + child.path;
		local prettyName = child.name;
		local has_descls = false;
		//TODO:local tooltip = get_tooltip_text(d, text);
		for (local d: child.decls) {
			has_descls = true;
			fp << "<tr><td>" << child.kind << "</td><td><div><code>";
			//TODO:if (tooltip !is none)
			//TODO:	fp << "<div class=\"tooltip\">";
			fp << "<a href=" << repr child_link << ">" << escapeSpecialHtmlCharacters(prettyName) << "</a>";
			//TODO:if (tooltip !is none) {
			//TODO:	fp	<< "<span class=\"tooltiptext\">"
			//TODO:		<< tooltip
			//TODO:		<< "</span></div>";
			//TODO:}
			if (!prettyName.issymcont(#prettyName - 1))
				fp << " ";
			printDeclarationParameters(fp, d);
			fp << "</code></div></td></tr>\r\n";
		}
		if (!has_descls) {
			fp << "<tr><td>" << child.kind << "</td><td><div><code>";
			fp << "<a href=" << repr child_link << ">" << escapeSpecialHtmlCharacters(prettyName) << "</a>";
			fp << "</code></div></td></tr>\r\n";
		}
	}
	fp << "</table></div></main>\r\n";
	writePageFooter(fp);
}

function listModulesInPath(
		p: string, prefix: string, showAll: bool = false): {string...} {
	import fs;
	try {
		for (local f: fs.dir(p)) {
			local path = fs.joinpath(p, f);
			if (f.startswith("_") && !showAll)
				continue; /* Hidden symbol (e.g. `_codecs') */
			if (fs.stat.isdir(path)) {
				/* Skip files found in /include-folders. */
				if (f == "include" && !showAll)
					continue;
				local new_prefix = "{}{}.".format({ prefix, f });
				for (local x: listModulesInPath(path, prefix))
					yield new_prefix + x;
				continue;
			}
			if (f.startswith(".") && f.startswith(".dec"))
				yield f[1:-4];
			else if (f.endswith(".so"))
				yield f[:-3];
			else if (f.endswith(".dll"))
				yield f[:-4];
			else if (f.endswith(".dee"))
				yield f[:-4];
		}
	} catch (...) {
	}
}

function enumerateGlobalModules(): {string...} {
	yield "deemon";
	for (local p: Module.path)
		yield listModulesInPath(p, "")...;
}

@@Print the /modules page
function getModulesPage(fp: File) {
	writePageHeader(fp, "Modules");
	fp << "<nav><ul>"
		"<li><a href=\"/\">home</a></li><li class=\"sep\">|</li>"
		"<li><a href=\"/modules\">modules</a></li>"
		"</ul></nav>\r\n<main>\r\n";
	for (local name: enumerateGlobalModules()) {
		fp	<< "<div class=\"module_item\"><a href=\"/modules/"
			<< name
			<< "\">"
			<< name
			<< "</a></div>\r\n";
	}
	fp << "</main>";
	writePageFooter(fp);
}

@@Print the root (home) page
function getHomePage(fp: File) {
	writePageHeader(fp, "Home");
	fp << "<nav><ul>"
		"<li><a href=\"/\">home</a></li><li class=\"sep\">|</li>"
		"<li><a href=\"/modules\">modules</a></li>"
		"</ul></nav><main>\r\n"
		"<h1>Deemon Documentation</h1>\r\n"
		"<a href=\"/modules\">List of all modules</a><br />\r\n"
		"</main>";
	writePageFooter(fp);
}


@@Get a page, given its @path
function getPage(fp: File, path: string) {
	path = path.strip("/").strip();
	path = path.split("/");
	if (!path)
		return getHomePage(fp);
	if (path[0] == "modules") {
		if (#path >= 2) {
			return getModuleRootSubPage(fp, path[1:]);
		}
		return getModulesPage(fp);
	}
	throw Error("Missing page: {!r}".format({ path }));
}


@@The thread main function for 
function ClientThreadMain(con: socket) {
	print "New connection:", con;
	try {
		try {
			try {
				for (;;) {
					local msg = con.recv();
					if (!msg)
						break; /* The other end disconnected gracefully */
					local command = msg.splitlines()[0];
					local fp = File.Writer();
					local protocol = command[#command - 8:];
					if (!command.startswith("GET") ||
					     protocol !in ["HTTP/1.1", "HTTP/1.0"]) {
						print "Bad command:", repr command;
						fp << protocol << " 400 Bad Request\r\n";
					} else {
						command = command[3:#command - 8].strip();
						local content;
						local content_type = "text/html";
						if (command == "/style.css") {
							content = File.open(
								fs.headof(__FILE__) + "/style.css",
								"r").read();
							content_type = "text/css";
						} else {
							content = File.Writer();
							getPage(content, command);
							content = content.string.encode("utf-8");
						}
						fp << protocol << " 200 OK\r\n"
							"Content-Length: {}\r\n"
							"Content-Type: {}; charset=UTF-8\r\n"
							"\r\n".format({ #content, content_type });
						fp.write(content);
					}
					con.send(fp.string.encode("UTF-8"));
					if (protocol == "HTTP/1.0") {
						/* Don't allow for connection re-use.
						 * If the we didn't do this, the client wouldn't get the
						 * memo on the entire document having been delivered. */
						break;
					}
				}
			} catch (e...) {
				File.Writer outputFp;
				File.Writer errorFp;
				writePageHeader(errorFp, e);
				errorFp <<
					"<main>\r\n"
					"<h2>DOC Server crashed</h2><br />"
					"<hr>";
				if (e !is string)
					errorFp << "<b>" << str(type e) << "</b>: ";
				errorFp
					<< (e is string ? e : repr e).replace("\n", "<br />\r\n")
					<< "<hr>"
					<< repr(Traceback.current).replace("\n", "<br />\r\n")
					<< "<hr></main>\r\n";
				writePageFooter(errorFp);
				errorFp = errorFp.string.encode("utf-8");
				outputFp <<
					"HTTP/1.1 200 OK\r\n"
					"Content-Length: {}\r\n"
					"Content-Type: text/html; charset=UTF-8\r\n"
					"\r\n".format({ #errorFp });
				outputFp.write(errorFp);
				con.send(outputFp.string);
				throw;
			}
		} finally {
			con.close();
			print "Disconnected:", con;
		}
	} catch (e...) {
		print "Client thread crashed:";
		print repr e;
		print repr Traceback.current;
	}

}


#ifdef __MAIN__
local s;
try {
	s = socket("INET6", none, none);
	s.bind("[::]:8080");
} catch (...) {
	s = socket("INET", none, none);
	s.bind("0.0.0.0:8080");
	print "Cannot use IPv6 to run server (using IPv4)";
}
s.listen();

print "Doc Server is up & running.";
print "Open your Web Brower and navigate to:";
print "127.0.0.1:8080";
print;
print;

try {
	for (;;) {
		local con = s.accept();
		local th = Thread(ClientThreadMain, pack con);
		th.start();
		th.detach();
	}
} finally {
	docObjectCache.clear();
}
#endif




