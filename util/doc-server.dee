/* Copyright (c) 2018 Griefer@Work                                            *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement in the product documentation would be  *
 *    appreciated but is not required.                                        *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

import * from doc;
import * from net;
import * from deemon;
import deemon;
import util;
import fs;

function write_page_head(fp,title) {
	fp <<
		"<!DOCTYPE HTLM>\r\n"
		"<html>\r\n"
		"<head>\r\n"
			"<meta charset=\"UTF-8\">"
			"<link rel=\"stylesheet\" href=\"/style.css\">"
			"<title>{}</title>"
		"</head>\r\n"
		"<body>\r\n"
		.format({
		title
	});
}
function write_page_tail(fp) {
	fp << "</body>\r\n</html>\r\n";
}
function escape_html(text) {
	return text
		.replace("<","&lt;")
		.replace(">","&gt;")
		.replace("\n","<br />\r\n");
}

global doc_cache = deemon.dict();
function get_doc_path(path) {
	path = path.lstrip("/");
	local result = doc_cache.get(path);
	if (result is none)
		doc_cache[path] = result = Doc(path);
	return result;
}

@@Print a type reference
function print_typeref(fp: file, t: TypeRef) {
	local p = t.path;
	local s = escape_html(str t);
	if (p is none) {
		fp << s;
	} else {
		fp << "<a href=" << repr("/modules" + p) << ">" << s << "</a>";
	}
}

@@Print a type reference
function print_typeexpr(fp: file, t: TypeExpr) {
	switch (t.kind) {
	case "E":
		return print_typeref(fp,t.Etyperef);
	case "C":
		print_typeexpr(fp,t.Ccelltype);
		fp << " with ";
		print_typeexpr(fp,t.Citemtype);
		break;
	case "T":
		if (#t.Ttypes == 1) {
			fp << "(";
			print_typeexpr(fp,t.Ttypes[0]);
			fp << ",)";
		} else {
			fp << "(";
			local is_first = true;
			for (local x: t.Ttypes) {
				if (!is_first) fp << ",";
				is_first = false;
				print_typeexpr(fp,x);
			}
			fp << ")";
		}
		break;
	case "X": {
		local is_first = true;
		for (local x: t.Xtypes) {
			if (!is_first) fp << " | ";
			is_first = false;
			print_typeexpr(fp,x);
		}
	}	break;
	case "S":
		fp << "{";
		print_typeexpr(fp,t.Stype);
		fp << "...}";
		break;
	default:
		fp << "<div class=\"broken_link\"><i>"
		   << escape_html(t.docstring)
		   << "</i></div>";
		break;
	}
}

@@Print a doc expression
function print_expr(fp: file, t: Expression) {
	/* TODO */
	fp << escape_html(str t);
}

@@Print Declaration parameters (if any), as well as the return type
function print_decl_params(fp: file, decl: Declaration) {
	if (decl.isdeleted) {
		fp << " = del";
		return;
	}
	if (decl.isinherited) {
		fp << " = super";
		return;
	}
	local params = decl.parameters;
	if (params !is none) {
		fp << "(";
		local is_first = true;
		for (local par: params) {
			if (!is_first) fp << ", ";
			is_first = false;
			if (par.iskwargs)
				fp << "**";
			fp << "<i>" << escape_html(par.name) << "</i>";
			if (par.isvarargs)
				fp << "...";
			else if (par.isoptional)
				fp << "?";
			fp << ": ";
			print_typeexpr(fp,par.typ);
			local def = par.defexpr;
			if (def !is none) {
				fp << " = ";
				print_expr(fp,def);
			}
		}
		fp << ")";
	}
	local ret = decl.ret;
	if (decl.istypeexplicit || !ret.isnone) {
		fp << " -> ";
		print_typeexpr(fp,ret);
	}
}

@@Print a given text segment
function print_text(fp: file, t: TextSegment) {
	fp << escape_html(t.docstring);
}


function get_module_page(fp: file, path: {string...}) {
	local d = get_doc_path("/".join(path));
	write_page_head(fp,d.prettypath);
	fp << "<nav><ul>"
		"<li><a href=\"/\">home</a></li><li class=\"sep\">|</li>"
		"<li><a href=\"/modules\">modules</a></li>";
	local link_path = "/modules";
	for (local x: path[:-1]) {
		link_path = "{}/{}".format({ link_path, x });
		local name_start = x.find(":");
		fp << "<li><a href=\"{}\">&gt;{}</a></li>".format({
			link_path,
			name_start >= 0 ? x[name_start+1:] : x
		});
	}
	fp << "<li><a href=\"/modules{}\">&gt;{}</a></li>".format({
		d.path,
		d.prettypathname
	});
	fp << "</ul></nav><main>\r\n";
	fp << "<h2><b>" << d.kind << "</b>: " << d.name;
	if (d.istype) {
		//TODO:local basetype = d.objectbase;
		//TODO:if (basetype !is none) {
		//TODO:	local basenode = d.objectbasenode;
		//TODO:	fp << " extends <b>";
		//TODO:	if (basenode !is none) {
		//TODO:		fp	<< "<a href=\"/modules"
		//TODO:			<< basenode.path
		//TODO:			<< "\">"
		//TODO:			<< basenode.name
		//TODO:			<< "</a>";
		//TODO:	} else {
		//TODO:		fp	<< basetype.__name__;
		//TODO:	}
		//TODO:	fp << "</b>";
		//TODO:}
	}
	fp << "</h2><hr>\r\n<div>";
	local pretty_name = d.name;
	for (local sect: d.docsections) {
		for (local seg: sect.segments) {
			if (seg is Declaration) {
				fp << "<div><code>" << d.kind << " ";
				fp << pretty_name;
				if (!pretty_name[#pretty_name-1].issymcont())
					fp << " ";
				print_decl_params(fp,seg);
				fp << "</code></div>\r\n";
			} else {
				print_text(fp,seg);
			}
		}
	}
	fp << "</div><hr>\r\n<div><table>";
	local children = list(d);
	children.sort();
	for (local child: children) {
		if (child.isprivate)
			continue; /* Don't enumerate private members. */
		local child_link = "/modules" + child.path;
		local pretty_name = child.name;
		local has_descls = false;
		//TODO:local tooltip = get_tooltip_text(d,text);
		for (local d: child.decls) {
			has_descls = true;
			fp << "<tr><td>" << child.kind << "</td><td><div><code>";
			//TODO:if (tooltip !is none)
			//TODO:	fp << "<div class=\"tooltip\">";
			fp << "<a href=" << repr child_link << ">" << escape_html(pretty_name) << "</a>";
			//TODO:if (tooltip !is none) {
			//TODO:	fp	<< "<span class=\"tooltiptext\">"
			//TODO:		<< tooltip
			//TODO:		<< "</span></div>";
			//TODO:}
			if (!pretty_name[#pretty_name-1].issymcont())
				fp << " ";
			print_decl_params(fp,d);
			fp << "</code></div></td></tr>\r\n";
		}
		if (!has_descls) {
			fp << "<tr><td>" << child.kind << "</td><td><div><code>";
			fp << "<a href=" << repr child_link << ">" << escape_html(pretty_name) << "</a>";
			fp << "</code></div></td></tr>\r\n";
		}
	}
	fp << "</table></div></main>\r\n";
	write_page_tail(fp);
}

function ls_modules_path(p: string, prefix: string): {string...} {
	import fs;
	try {
		for (local f: fs.dir(p)) {
			local path = fs.joinpath(p,f);
			if (f.startswith("_"))
				continue; /* Hidden symbol (e.g. `_codecs') */
			if (fs.stat.isdir(path)) {
				/* Skip files found in /include-folders. */
				if (f == "include")
					continue;
				local new_prefix = "{}{}.".format({ prefix, f });
				for (local x: ls_modules_path(path,prefix))
					yield new_prefix + x;
				continue;
			}
			if (f.startswith(".") && f.startswith(".dec"))
				yield f[1:#f-4];
			else if (f.endswith(".so"))
				yield f[:#f-3];
			else if (f.endswith(".dll"))
				yield f[:#f-4];
			else if (f.endswith(".dee"))
				yield f[:#f-4];
		}
	} catch (...) {
	}
}

function ls_modules(): {string...} {
	yield "deemon";
	for (local p: deemon.module.path) {
		yield ls_modules_path(p,"")...;
	}
}

function get_modules_list(fp: file) {
	write_page_head(fp,"Modules");
	fp << "<nav><ul>"
		"<li><a href=\"/\">home</a></li><li class=\"sep\">|</li>"
		"<li><a href=\"/modules\">modules</a></li>"
		"</ul></nav><main>\r\n";
	for (local name: ls_modules()) {
		fp	<< "<div class=\"module_item\"><a href=\"/modules/"
			<< name
			<< "\">"
			<< name
			<< "</a></div>";
	}
	fp << "</main>";
	write_page_tail(fp);
}

function get_home_page(fp: file) {
	write_page_head(fp,"Home");
	fp << "<nav><ul>"
		"<li><a href=\"/\">home</a></li><li class=\"sep\">|</li>"
		"<li><a href=\"/modules\">modules</a></li>"
		"</ul></nav><main>\r\n"
		"<h1>Deemon Documentation</h1>\r\n"
		"<a href=\"/modules\">List of all modules</a><br />\r\n"
		"</main>";
	write_page_tail(fp);
}


function get_page(fp: file, path: string) {
	path = path.strip("/").strip();
	path = path.split("/");
	if (path[0] == "modules") {
		if (#path >= 2) {
			return get_module_page(fp,path[1:]);
		}
		return get_modules_list(fp);
	}
	if (path[0] == "") {
		return get_home_page(fp);
	}
	throw "Missing page: {!r}".format({ path });
}


function ClientThreadMain(con) {
	print "New connection:",con;
	try {
		try {
			try for (;;) {
				local msg = con.recv();
				if (!msg)
					break; /* The other end disconnected gracefully */
				local command = msg.splitlines()[0];
				local fp = file.writer();
				local protocol = command[#command-8:];
				if (!command.startswith("GET") ||
				     protocol !in ["HTTP/1.1","HTTP/1.0"]) {
					print "Bad command:",repr command;
					fp << protocol << " 400 Bad Request\r\n";
				} else {
					command = command[3:#command-8].strip();
					local content;
					if (command == "/style.css") {
						content = file.open(fs.headof(__FILE__) + "/style.css","r").read();
					} else {
						content = file.writer();
						get_page(content,command);
						content = content.string.encode("utf-8");
					}
					fp << protocol << " 200 OK\r\n"
						"Content-Length: {}\r\n"
						"Content-Type: text/html; charset=UTF-8\r\n"
						"\r\n".format({ #content });
					fp.write(content);
				}
				con.send(fp.string.encode("UTF-8"));
				if (protocol == "HTTP/1.0") {
					/* Don't allow for connection re-use.
					 * If the we didn't do this, the client wouldn't get the
					 * memo on the entire document having been delivered. */
					break;
				}
			} catch (e...) {
				local err_out = file.writer();
				local err_content = file.writer();
				write_page_head(err_content,e);
				err_content <<
					"<main>\r\n"
					"<h2>DOC Server crashed</h2><br />"
					"<hr>";
				if (e !is string) {
					err_content
						<< "<b>"
						<< str(type e)
						<< "</b>: ";
				}
				err_content
					<< (e is string ? e : repr e).replace("\n","<br />\r\n")
					<< "<hr>"
					<< repr(deemon.traceback.current).replace("\n","<br />\r\n")
					<< "<hr></main>\r\n";
				write_page_tail(err_content);
				err_content = err_content.string.encode("utf-8");
				err_out <<
					"HTTP/1.1 200 OK\r\n"
					"Content-Length: {}\r\n"
					"Content-Type: text/html; charset=UTF-8\r\n"
					"\r\n".format({ #err_content });
				err_out.write(err_content);
				con.send(err_out.string);
				throw;
			}
		} finally {
			con.close();
			print "Disconnected:",con;
		}
	} catch (e...) {
		print "Client thread crashed:";
		print repr e;
		print repr deemon.traceback.current;
	}

}


#ifdef __MAIN__
local s;
try {
	s = socket("INET6",none,none);
	s.bind("[::]:8080");
} catch (...) {
	s = socket("INET",none,none);
	s.bind("0.0.0.0:8080");
	print "Cannot use IPv6 to run server (using IPv4)";
}
s.listen();

print "Doc Server is up & running.";
print "Open your Web Brower and navigate to:";
print "127.0.0.1:8080";
print;
print;

try {
	for (;;) {
		local con = s.accept();
		local th = thread(ClientThreadMain,pack con);
		th.start();
		th.detach();
	}
} finally {
	doc_cache.clear();
}
#endif




