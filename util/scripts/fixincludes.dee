/* Copyright (c) 2018-2026 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2018-2026 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

import * from deemon;
import posix;
import functools;

local final ROOTDIR = posix.joinpath(posix.headof(__FILE__), r"../..");

global final HEADER_KWDS: {string: {string...}} = {
	/* Standard headers that are assumed present by deemon, as well
	 * as symbols that must be defined by those headers in order for
	 * deemon to be compilable. */
	"<stdarg.h>": {
		"va_list",
		"va_start",
		"va_arg",
		"va_end",
	},
	"<stddef.h>": {
		"NULL",
		"size_t",
		"ptrdiff_t",
		"offsetof",
	},
	"<stdint.h>": {
		"int8_t", "int16_t", "int32_t", "int64_t", "intptr_t",
		"uint8_t", "uint16_t", "uint32_t", "uint64_t", "uintptr_t",
		"INT8_C", "INT16_C", "INT32_C", "INT64_C",
		"UINT8_C", "UINT16_C", "UINT32_C", "UINT64_C",
		"INT8_MIN", "INT16_MIN", "INT32_MIN", "INT64_MIN",
		"INT8_MAX", "INT16_MAX", "INT32_MAX", "INT64_MAX",
		"UINT8_MAX", "UINT16_MAX", "UINT32_MAX", "UINT64_MAX",
	},
	"<stdbool.h>": {
		"bool",
		"true",
		"false",
	},


	/* Hybrid headers taken from KOS */
	"<hybrid/__alloca.h>": {
		"__hybrid_alloca",
		"__hybrid_alloca_IS_alloca",
	},
	"<hybrid/__assert.h>": {
		"__hybrid_assert",
		"__hybrid_assertf",
	},
	"<hybrid/__atomic.h>": {
		"__ATOMIC_RELAXED",
		"__ATOMIC_CONSUME",
		"__ATOMIC_ACQUIRE",
		"__ATOMIC_RELEASE",
		"__ATOMIC_ACQ_REL",
		"__ATOMIC_SEQ_CST",
#define FOREACH_N2(x, y)  x y, x "8" y, x "16" y, x "32" y, x "64" y
#define FOREACH_Nn2(x, y)      x "8" y, x "16" y, x "32" y, x "64" y
#define FOREACH_N(x)      x,   x "8",   x "16",   x "32",   x "64"
#define FOREACH_Nn(x)          x "8",   x "16",   x "32",   x "64"
		FOREACH_N("__hybrid_atomic_load"),
		FOREACH_N("__hybrid_atomic_store"),
		FOREACH_N("__hybrid_atomic_xch"),
		FOREACH_N("__hybrid_atomic_fetchinc"),
		FOREACH_N("__hybrid_atomic_fetchdec"),
		FOREACH_N("__hybrid_atomic_fetchadd"),
		FOREACH_N("__hybrid_atomic_fetchsub"),
		FOREACH_N("__hybrid_atomic_fetchand"),
		FOREACH_N("__hybrid_atomic_fetchxor"),
		FOREACH_N("__hybrid_atomic_fetchor"),
		FOREACH_N("__hybrid_atomic_fetchnand"),
		FOREACH_N("__hybrid_atomic_incfetch"),
		FOREACH_N("__hybrid_atomic_decfetch"),
		FOREACH_N("__hybrid_atomic_addfetch"),
		FOREACH_N("__hybrid_atomic_subfetch"),
		FOREACH_N("__hybrid_atomic_andfetch"),
		FOREACH_N("__hybrid_atomic_xorfetch"),
		FOREACH_N("__hybrid_atomic_orfetch"),
		FOREACH_N("__hybrid_atomic_nandfetch"),
		FOREACH_N("__hybrid_atomic_inc"),
		FOREACH_N("__hybrid_atomic_dec"),
		FOREACH_N("__hybrid_atomic_add"),
		FOREACH_N("__hybrid_atomic_sub"),
		FOREACH_N("__hybrid_atomic_and"),
		FOREACH_N("__hybrid_atomic_xor"),
		FOREACH_N("__hybrid_atomic_or"),
		FOREACH_N("__hybrid_atomic_nand"),
		FOREACH_N("__hybrid_atomic_cmpxch"),
		FOREACH_N("__hybrid_atomic_cmpxch_weak"),
		FOREACH_N("__hybrid_atomic_cmpxch_val"),
		"__hybrid_atomic_thread_fence",
		"__hybrid_atomic_signal_fence",
	},
	"<hybrid/__bit.h>": {
		FOREACH_N("__hybrid_ffs"),
		FOREACH_N("__hybrid_clz"),
		FOREACH_N("__hybrid_ctz"),
		FOREACH_N("__hybrid_popcount"),
		FOREACH_N("__hybrid_parity"),
		FOREACH_N("__hybrid_clrsb"),
		FOREACH_N("__hybrid_pdep"),
		FOREACH_N("__hybrid_pext"),
	},
	"<hybrid/__bitfield.h>": {
		"__HYBRID_BITFIELD8_T",
		"__HYBRID_BITFIELD16_T",
		"__HYBRID_BITFIELD32_T",
		"__HYBRID_BITFIELD64_T",
	},
#if 0 /* Would add unnecessary comment bloat */
	"<hybrid/__bitset.h>": {
		"__HYBRID_BITSET_WORD_BMAX",
		"__HYBRID_BITSET_WORD_BITS",
		"__HYBRID_BITSET_WORD_BMSK",
		"__HYBRID_BITSET_WORD_SHFT",
		"__HYBRID_BITSET_WORD",
		"__HYBRID_BITSET_MASK",
		"__HYBRID_BITSET_LENGTHOF",
		"__HYBRID_BITSET_SIZEOF",
		"__HYBRID_BITSET_LO_MASKIN",
		"__HYBRID_BITSET_LO_MASKOU",
		"__HYBRID_BITSET_HI_MASKIN",
		"__HYBRID_BITSET_HI_MASKOU",
		"__HYBRID_BITSET_LO_MASKIN_P1",
		"__HYBRID_BITSET_LO_MASKOU_P1",
		"__HYBRID_BITSET_HI_MASKIN_P1",
		"__HYBRID_BITSET_HI_MASKOU_P1",
		"__hybrid_bitset_decl",
		"__hybrid_bitset_t",
		"__hybrid_bitset_test",
		"__hybrid_bitset_set",
		"__hybrid_bitset_clear",
		"__hybrid_bitset_flip",
		"__hybrid_bitset_setall",
		"__hybrid_bitset_clearall",
		"__hybrid_bitset_flipall",
		"__hybrid_bitset_nclear_r",
		"__hybrid_bitset_nclear",
		"__hybrid_bitset_nset_r",
		"__hybrid_bitset_nset",
		"__hybrid_bitset_nflip_r",
		"__hybrid_bitset_nflip",
		"__hybrid_bitset_ffc_i",
		"__hybrid_bitset_ffs_i",
		"__hybrid_bitset_ffc",
		"__hybrid_bitset_ffs",
		"__hybrid_bitset_flc",
		"__hybrid_bitset_fls",
		"__hybrid_bitset_nffc_r",
		"__hybrid_bitset_nffc",
		"__hybrid_bitset_nffs_r",
		"__hybrid_bitset_nffs",
		"__hybrid_bitset_nflc_r",
		"__hybrid_bitset_nflc",
		"__hybrid_bitset_nfls_r",
		"__hybrid_bitset_nfls",
		"__hybrid_bitset_anyset",
		"__hybrid_bitset_allset",
		"__hybrid_bitset_nanyset_r",
		"__hybrid_bitset_nanyset",
		"__hybrid_bitset_nallset_r",
		"__hybrid_bitset_nallset",
		"__hybrid_bitset_popcount",
		"__hybrid_bitset_npopcount_r",
		"__hybrid_bitset_npopcount",
		"__hybrid_bitset_clz",
		"__hybrid_bitset_ctz",
		"__hybrid_bitset_rawclz",
		"__hybrid_bitset_rawctz",
		"__hybrid_bitset_ncopy",
		"__hybrid_bitset_ncopy0",
		"__HYBRID_BITSET_OP_AND",
		"__HYBRID_BITSET_OP_OR",
		"__HYBRID_BITSET_OP_XOR",
		"__hybrid_bitset_nbitop",
		"__hybrid_bitset_nbitop0",
		"__hybrid_bitset_ncmpeq",
		"__hybrid_bitset_ncmpne",
		"__hybrid_bitset_ncmplo",
		"__hybrid_bitset_ncmple",
		"__hybrid_bitset_ncmpgr",
		"__hybrid_bitset_ncmpge",
		"__hybrid_bitset_ncmpeq0",
		"__hybrid_bitset_ncmpne0",
		"__hybrid_bitset_ncmplo0",
		"__hybrid_bitset_ncmple0",
		"__hybrid_bitset_ncmpgr0",
		"__hybrid_bitset_ncmpge0",
		"__hybrid_bitset_foreach",
		"__hybrid_bitset_nforeach",
		"__hybrid_bitset_nforeach_r",
		"__hybrid_bitset_atomic_set",
		"__hybrid_bitset_atomic_clear",
		"__hybrid_bitset_atomic_flip",
		"__hybrid_bitset_atomic_fetchset",
		"__hybrid_bitset_atomic_fetchclear",
		"__hybrid_bitset_atomic_fetchflip",
	},
#endif
	"<hybrid/__byteswap.h>": {
		"__hybrid_bswap16_c",
		"__hybrid_bswap32_c",
		"__hybrid_bswap64_c",
		"__hybrid_bswap128_c",
		"__hybrid_bswap16",
		"__hybrid_bswap32",
		"__hybrid_bswap64",
		"__hybrid_bswap128",
		"__HYBRID_HTOLE_IS_LETOH",
		"__HYBRID_HTOBE_IS_BETOH",
		"__hybrid_htole16",
		"__hybrid_htobe16",
		"__hybrid_letoh16",
		"__hybrid_betoh16",
		"__hybrid_htole32",
		"__hybrid_htobe32",
		"__hybrid_letoh32",
		"__hybrid_betoh32",
		"__hybrid_htole64",
		"__hybrid_htobe64",
		"__hybrid_letoh64",
		"__hybrid_betoh64",
		"__hybrid_htole128",
		"__hybrid_htobe128",
		"__hybrid_letoh128",
		"__hybrid_betoh128",
		"__hybrid_htole16_c",
		"__hybrid_htobe16_c",
		"__hybrid_letoh16_c",
		"__hybrid_betoh16_c",
		"__hybrid_htole32_c",
		"__hybrid_htobe32_c",
		"__hybrid_letoh32_c",
		"__hybrid_betoh32_c",
		"__hybrid_htole64_c",
		"__hybrid_htobe64_c",
		"__hybrid_letoh64_c",
		"__hybrid_betoh64_c",
		"__hybrid_htole128_c",
		"__hybrid_htobe128_c",
		"__hybrid_letoh128_c",
		"__hybrid_betoh128_c",
	},
	"<hybrid/__debug-alignment.h>": {
		"__NO_hybrid_dbg_alignment",
		"__hybrid_dbg_alignment_enable",
		"__hybrid_dbg_alignment_disable",
	},
	"<hybrid/__minmax.h>": {
#define FOREACH_MINMAX(x) \
		x, x "1", x "2", x "3", x "4", x "5", x "6", x "6", x "7", x "8", x "9", \
		x "10", x "11", x "12", x "13", x "14", x "15", x "16", x "16", x "17", \
		x "18", x "19", x "20"
		FOREACH_MINMAX("__hybrid_min"),
		FOREACH_MINMAX("__hybrid_min_c"),
		FOREACH_MINMAX("__hybrid_max"),
		FOREACH_MINMAX("__hybrid_max_c"),
#undef FOREACH_MINMAX
	},
	"<hybrid/__overflow.h>": {
		FOREACH_N("__hybrid_overflow_uadd"),
		FOREACH_N("__hybrid_overflow_sadd"),
		FOREACH_N("__hybrid_overflow_usub"),
		FOREACH_N("__hybrid_overflow_ssub"),
		FOREACH_N("__hybrid_overflow_umul"),
		FOREACH_N("__hybrid_overflow_smul"),
		FOREACH_N("__hybrid_overflow_sneg"),
		FOREACH_N("__hybrid_overflow_scast"),
		FOREACH_N("__hybrid_overflow_ucast"),
	},
	"<hybrid/__rotate.h>": {
		FOREACH_Nn("__hybrid_rol"), FOREACH_Nn2("__hybrid_rol", "_c"),
		FOREACH_Nn("__hybrid_ror"), FOREACH_Nn2("__hybrid_ror", "_c"),
	},
	"<hybrid/__unaligned.h>": {
		FOREACH_N("__hybrid_unaligned_get"),
		FOREACH_N2("__hybrid_unaligned_get", "_swap"),
		FOREACH_N("__hybrid_unaligned_getle"),
		FOREACH_N("__hybrid_unaligned_getbe"),
		FOREACH_N("__hybrid_unaligned_set"),
		FOREACH_N2("__hybrid_unaligned_set", "_swap"),
		FOREACH_N("__hybrid_unaligned_setle"),
		FOREACH_N("__hybrid_unaligned_setbe"),
	},
	"<hybrid/__va_size.h>": {
		"__VA_SIZE",
	},
	"<hybrid/__wordbits.h>": {
		"__INT16_I8",
		"__INT32_I8",
		"__INT64_I8",
		"__INT32_I16",
		"__INT64_I16",
		"__INT64_I32",
		"__ENCODE_INT16",
		"__ENCODE_INT32",
		"__ENCODE_INT64",
		"__INT16_BYTE",
		"__INT32_BYTE",
		"__INT64_BYTE",
		"__INT32_WORD",
		"__INT64_WORD",
		"__INT64_DWORD",
	},
	"<hybrid/align.h>": {
		"IS_ALIGNED",
		"IS_POWER_OF_TWO",
		"CEIL_ALIGN",
		"FLOOR_ALIGN",
		"FLOORDIV",
		"CEILDIV",
	},
	"<hybrid/alloca.h>": {
		"ALLOCA",
		"__ALLOCA",
	},
	"<hybrid/bit.h>": {
		"FFS",
		"CLZ",
		"CTZ",
		"POPCOUNT",
		"PARITY",
		"CLRSB",
		"PEXT",
		"PDEP",
	},
#if 0 /* Would add unnecessary comment bloat */
	"<hybrid/bitset.h>": {
		"_BITSET_WORD_BMAX",
		"_BITSET_WORD_BITS",
		"_BITSET_WORD_BMSK",
		"_BITSET_WORD_SHFT",
		"_BITSET_WORD",
		"_BITSET_MASK",
		"BITSET_LENGTHOF",
		"BITSET_SIZEOF",
		"_BITSET_LO_MASKIN",
		"_BITSET_LO_MASKOU",
		"_BITSET_HI_MASKIN",
		"_BITSET_HI_MASKOU",
		"_BITSET_LO_MASKIN_P1",
		"_BITSET_LO_MASKOU_P1",
		"_BITSET_HI_MASKIN_P1",
		"_BITSET_HI_MASKOU_P1",
		"bitset_decl",
		"bitset_t",
		"bitset_test",
		"bitset_set",
		"bitset_clear",
		"bitset_flip",
		"bitset_setall",
		"bitset_clearall",
		"bitset_flipall",
		"bitset_nclear_r",
		"bitset_nclear",
		"bitset_nset_r",
		"bitset_nset",
		"bitset_nflip_r",
		"bitset_nflip",
		"bitset_ffc_i",
		"bitset_ffs_i",
		"bitset_ffc",
		"bitset_ffs",
		"bitset_flc",
		"bitset_fls",
		"bitset_nffc_r",
		"bitset_nffc",
		"bitset_nffs_r",
		"bitset_nffs",
		"bitset_nflc_r",
		"bitset_nflc",
		"bitset_nfls_r",
		"bitset_nfls",
		"bitset_anyset",
		"bitset_allset",
		"bitset_nanyset_r",
		"bitset_nanyset",
		"bitset_nallset_r",
		"bitset_nallset",
		"bitset_popcount",
		"bitset_npopcount_r",
		"bitset_npopcount",
		"bitset_clz",
		"bitset_ctz",
		"bitset_rawclz",
		"bitset_rawctz",
		"bitset_ncopy",
		"bitset_ncopy0",
		"BITSET_OP_AND",
		"BITSET_OP_OR",
		"BITSET_OP_XOR",
		"bitset_nbitop",
		"bitset_nbitop0",
		"bitset_ncmpeq",
		"bitset_ncmpne",
		"bitset_ncmplo",
		"bitset_ncmple",
		"bitset_ncmpgr",
		"bitset_ncmpge",
		"bitset_ncmpeq0",
		"bitset_ncmpne0",
		"bitset_ncmplo0",
		"bitset_ncmple0",
		"bitset_ncmpgr0",
		"bitset_ncmpge0",
		"bitset_foreach",
		"bitset_nforeach",
		"bitset_nforeach_r",
		"bitset_atomic_set",
		"bitset_atomic_clear",
		"bitset_atomic_flip",
		"bitset_atomic_fetchset",
		"bitset_atomic_fetchclear",
		"bitset_atomic_fetchflip",
	},
#endif
	"<hybrid/byteorder.h>": {
		"__ORDER_LITTLE_ENDIAN__",
		"__ORDER_BIG_ENDIAN__",
		"__ORDER_PDP_ENDIAN__",
		"__BYTE_ORDER__",
		"__FLOAT_WORD_ORDER__",
	},
#if 0 /* TODO: Deal with overlap with <hybrid/unaligned.h> */
	"<hybrid/byteswap.h>": {
		"BSWAP16_C",
		"BSWAP32_C",
		"BSWAP64_C",
		"BSWAP128_C",
		"BSWAP16",
		"BSWAP32",
		"BSWAP64",
		"BSWAP128",
		"HTOBE16",
		"HTOLE16",
		"BETOH16",
		"LETOH16",
		"HTOBE32",
		"HTOLE32",
		"BETOH32",
		"LETOH32",
		"HTOBE16_C",
		"HTOLE16_C",
		"BETOH16_C",
		"LETOH16_C",
		"HTOBE32_C",
		"HTOLE32_C",
		"BETOH32_C",
		"LETOH32_C",
		"HTOBE64",
		"HTOLE64",
		"BETOH64",
		"LETOH64",
		"HTOBE64_C",
		"HTOLE64_C",
		"BETOH64_C",
		"LETOH64_C",
		"HTOBE128",
		"HTOLE128",
		"BETOH128",
		"LETOH128",
		"HTOBE128_C",
		"HTOLE128_C",
		"BETOH128_C",
		"LETOH128_C",
		"UNALIGNED_GETLE",
		"UNALIGNED_SETLE",
		"UNALIGNED_GETBE",
		"UNALIGNED_SETBE",
		"UNALIGNED_GETLE8",
		"UNALIGNED_SETLE8",
		"UNALIGNED_GETBE8",
		"UNALIGNED_SETBE8",
		"UNALIGNED_GETLE16",
		"UNALIGNED_SETLE16",
		"UNALIGNED_GETBE16",
		"UNALIGNED_SETBE16",
		"UNALIGNED_GETLE32",
		"UNALIGNED_SETLE32",
		"UNALIGNED_GETBE32",
		"UNALIGNED_SETBE32",
		"UNALIGNED_GETLE64",
		"UNALIGNED_SETLE64",
		"UNALIGNED_GETBE64",
		"UNALIGNED_SETBE64",
		"UNALIGNED_GETLE128",
		"UNALIGNED_SETLE128",
		"UNALIGNED_GETBE128",
		"UNALIGNED_SETBE128",
	},
#endif
	"<hybrid/debug-alignment.h>": {
		"NO_DBG_ALIGNMENT",
		"DBG_ALIGNMENT_ENABLE",
		"DBG_ALIGNMENT_DISABLE",
	},
	"<hybrid/host.h>": {
		"__pic__",
		"__DJGPP__",
		"__MSDOS__",
		"_WIN64",
		"_WIN32",
		"_WIN16",
		"__WINNT__",
		"__linux__",
		"__hpux__",
		"__phoenix__",
		"__unix__",
		"__x86_64__",
		"__i686__",
		"__i586__",
		"__i486__",
		"__i386__",
		"__bfin__",
		"__TMS320C6X__",
		"__csky__",
		"__ckcore__",
		"__aarch64__",
		"__arm__",
		"__alpha__",
		"__m32r__",
		"__mcore__",
		"__microblaze__",
		"__mips64",
		"__mips__",
		"__m68k__",
		"__ia64__",
		"__fr30__",
		"__mmix__",
		"__mn10300__",
		"__nds32__",
		"__or1k__",
		"__hp800__",
		"__hp9000__",
		"__hp9000s700__",
		"__hp9000s800__",
		"__hppa__",
		"__pdp11__",
		"__xstormy16__",
		"__vxworks",
		"__xtensa__",
		"__vms__",
		"__v850__",
		"__nios2__",
		"__moxie__",
		"__sparc_v9__",
		"__sparc64__",
		"__sparc__",
		"__sparc64__",
		"__powerpc__",
		"__powerpc64__",
		"__ARCH_HAVE_UNALIGNED_MEMORY_ACCESS",
		"__ARCH_VA_LIST_IS_STACK_POINTER",
		"__ARCH_STACK_GROWS_UPWARDS",
		"__ARCH_STACK_GROWS_DOWNWARDS",
		"__ARCH_STACK_ALIGNMENT",
		"__ARCH_PAGESIZE",
	},
	"<hybrid/limitcore.h>": {
		"__SCHAR_MIN__",
		"__SCHAR_MAX__",
		"__UCHAR_MAX__",
		"__CHAR_MIN__",
		"__CHAR_MAX__",
		"__SHRT_MIN__",
		"__SHRT_MAX__",
		"__USHRT_MAX__",
		"__INT_MIN__",
		"__INT_MAX__",
		"__UINT_MAX__",
		"__LONG_MIN__",
		"__LONG_MAX__",
		"__ULONG_MAX__",
		"__LONG_LONG_MIN__",
		"__LONG_LONG_MAX__",
		"__ULONG_LONG_MAX__",
		"__SIZE_MIN__",
		"__SIZE_MAX__",
		"__SSIZE_MIN__",
		"__SSIZE_MAX__",
		"__INTMAX_MIN__",
		"__INTMAX_MAX__",
		"__UINTMAX_MAX__",
		"__INT8_MIN__",
		"__INT16_MIN__",
		"__INT32_MIN__",
		"__INT8_MAX__",
		"__INT16_MAX__",
		"__INT32_MAX__",
		"__UINT8_MAX__",
		"__UINT16_MAX__",
		"__UINT32_MAX__",
		"__INT64_MIN__",
		"__INT64_MAX__",
		"__UINT64_MAX__",
		"__INT128_MIN__",
		"__INT128_MAX__",
		"__UINT128_MAX__",
		"__INT_LEAST8_MIN__",
		"__INT_LEAST16_MIN__",
		"__INT_LEAST32_MIN__",
		"__INT_LEAST8_MAX__",
		"__INT_LEAST16_MAX__",
		"__INT_LEAST32_MAX__",
		"__UINT_LEAST8_MAX__",
		"__UINT_LEAST16_MAX__",
		"__UINT_LEAST32_MAX__",
		"__INT_LEAST64_MIN__",
		"__INT_LEAST64_MAX__",
		"__UINT_LEAST64_MAX__",
		"__INT_FAST8_MIN__",
		"__INT_FAST16_MIN__",
		"__INT_FAST32_MIN__",
		"__INT_FAST8_MAX__",
		"__INT_FAST16_MAX__",
		"__INT_FAST32_MAX__",
		"__UINT_FAST8_MAX__",
		"__UINT_FAST16_MAX__",
		"__UINT_FAST32_MAX__",
		"__INT_FAST64_MIN__",
		"__INT_FAST64_MAX__",
		"__UINT_FAST64_MAX__",
		"__INTPTR_MIN__",
		"__INTPTR_MAX__",
		"__UINTPTR_MAX__",
		"__PTRDIFF_MIN__",
		"__PTRDIFF_MAX__",
		"__SIG_ATOMIC_MIN__",
		"__SIG_ATOMIC_MAX__",
		"__WCHAR_MIN__",
		"__WCHAR_MAX__",
		"__WINT_MIN__",
		"__WINT_MAX__",
	},
	"<hybrid/minmax.h>": {
		"MIN",
		"MAX",
		"MIN_C",
		"MAX_C",
	},
	"<hybrid/overflow.h>": {
		"OVERFLOW_UADD",
		"OVERFLOW_SADD",
		"OVERFLOW_USUB",
		"OVERFLOW_SSUB",
		"OVERFLOW_UMUL",
		"OVERFLOW_SMUL",
		"OVERFLOW_SENG",
		"OVERFLOW_SENG_P2N",
		"OVERFLOW_SENG_N2P",
		"OVERFLOW_UCAST",
		"OVERFLOW_SCAST",
	},
	"<hybrid/spcall.h>": {
		"SPCALL_CC",
		"SPCALL_NORETURN_SP",
		"SPCALL_NORETURN",
	},
	"<hybrid/typecore.h>": {
		"__SIZEOF_INT__",
		"__SIZEOF_LONG__",
		"__SIZEOF_LONG_LONG__",
		"__INT128_TYPE__",
		"__UINT128_TYPE__",
		"__INT8_C_SUFFIX__",
		"__INT16_C_SUFFIX__",
		"__INT32_C_SUFFIX__",
		"__INT64_C_SUFFIX__",
		"__UINT8_C_SUFFIX__",
		"__UINT16_C_SUFFIX__",
		"__UINT32_C_SUFFIX__",
		"__UINT64_C_SUFFIX__",
		"__INTMAX_C_SUFFIX__",
		"__UINTMAX_C_SUFFIX__",
		"__INT8_C",
		"__INT16_C",
		"__INT32_C",
		"__INT64_C",
		"__UINT8_C",
		"__UINT16_C",
		"__UINT32_C",
		"__UINT64_C",
		"__INT128_C_SUFFIX__",
		"__UINT128_C_SUFFIX__",
		"__INT128_C",
		"__UINT128_C",
		"__CHAR_BIT__",
		"__SIZEOF_CHAR__",
		"__SIZEOF_SHORT__",
		"__INTMAX_C",
		"__UINTMAX_C",
		"__SIZEOF_POINTER__",
		"__SIZEOF_PTRDIFF_T__",
		"__SIZEOF_SIZE_T__",
		"__INTPTR_C",
		"__UINTPTR_C",
		"__SIZE_C",
		"__SSIZE_C",
		"__SIZEOF_INT_FAST8_T__",
		"__SIZEOF_INT_FAST16_T__",
		"__SIZEOF_INT_FAST32_T__",
		"__SIZEOF_INT_FAST64_T__",
		"__SIZEOF_SIG_ATOMIC_T__",
		"__SIG_ATOMIC_UNSIGNED__",
		"__SIZEOF_WINT_T__",
		"__WINT_UNSIGNED__",
		"__SIZEOF_WCHAR_T__",
		"__WCHAR_UNSIGNED__",
		"__CHAR_UNSIGNED__",
		"__CHAR8_TYPE__",
		"__INT8_TYPE__",
		"__INT16_TYPE__",
		"__INT32_TYPE__",
		"__UINT8_TYPE__",
		"__UINT16_TYPE__",
		"__UINT32_TYPE__",
		"__INT64_TYPE__",
		"__UINT64_TYPE__",
		"__SIZEOF_INT_LEAST64_T__",
		"__SIZEOF_INT_LEAST32_T__",
		"__SIZEOF_INT_LEAST16_T__",
		"__SIZEOF_INT_LEAST8_T__",
		"__INT_LEAST8_TYPE__",
		"__INT_LEAST16_TYPE__",
		"__INT_LEAST32_TYPE__",
		"__INT_LEAST64_TYPE__",
		"__UINT_LEAST8_TYPE__",
		"__UINT_LEAST16_TYPE__",
		"__UINT_LEAST32_TYPE__",
		"__UINT_LEAST64_TYPE__",
		"__INT_FAST8_TYPE__",
		"__INT_FAST16_TYPE__",
		"__INT_FAST32_TYPE__",
		"__INT_FAST64_TYPE__",
		"__UINT_FAST8_TYPE__",
		"__UINT_FAST16_TYPE__",
		"__UINT_FAST32_TYPE__",
		"__UINT_FAST64_TYPE__",
		"__INTPTR_TYPE__",
		"__UINTPTR_TYPE__",
		"__SIZE_TYPE__",
		"__PTRDIFF_TYPE__",
		"__SIZEOF_INTMAX_T__",
		"__INTMAX_TYPE__",
		"__UINTMAX_TYPE__",
		"__LONGPTR_TYPE__",
		"__ULONGPTR_TYPE__",
		"__SIZEOF_INTPTR_HALF_T__",
		"__INTPTR_HALF_TYPE__",
		"__UINTPTR_HALF_TYPE__",
		"__SIZEOF_INTPTR_QUARTER_T__",
		"__INTPTR_QUARTER_TYPE__",
		"__UINTPTR_QUARTER_TYPE__",
		"__SBYTE_TYPE__",
		"__BYTE_TYPE__",
		"__WCHAR_TYPE__",
		"__WCHAR16_TYPE__",
		"__WCHAR32_TYPE__",
		"__WINT_TYPE__",
		"__WINT16_TYPE__",
		"__WINT32_TYPE__",
		"__CHAR16_TYPE__",
		"__CHAR32_TYPE__",
		"__SIZEOF_SHIFT_T__",
		"__SHIFT_TYPE__",
		"__SIG_ATOMIC_TYPE__",
		"__SIZEOF_FLOAT__",
		"__SIZEOF_DOUBLE__",
		"__INTSIZE_TYPE__",
		"__INTSSIZE_TYPE__",
		"__LONGSIZE_TYPE__",
		"__LONGSSIZE_TYPE__",
		"__LONG32_TYPE__",
		"__ULONG32_TYPE__",
		"__LONG64_TYPE__",
		"__ULONG64_TYPE__",
		"__SIZEOF_REGISTER__",
		"__REGISTER_TYPE__",
		"__SREGISTER_TYPE__",
		"__SIZEOF_BUSINT__",
		"__BUSINT_TYPE__",
		"__UBUSIINT_TYPE__",
		"__ALIGNOF_INT128__",
		"__ALIGNOF_INT64__",
		"__ALIGNOF_INT32__",
		"__ALIGNOF_INT16__",
		"__ALIGNOF_INT8__",
		"__ALIGNOF_FLOAT__",
		"__ALIGNOF_DOUBLE__",
		"__SIZEOF_LONG_DOUBLE__",
		"__ARCH_LONG_DOUBLE_IS_DOUBLE",
		"__ALIGNOF_LONG_DOUBLE__",
		"__ALIGNOF_LONG_LONG__",
		"__ALIGNOF_LONG__",
		"__ALIGNOF_INT__",
		"__ALIGNOF_SHORT__",
		"__ALIGNOF_CHAR__",
		"__ALIGNOF_POINTER__",
		"__ALIGNOF_SIZE_T__",
		"__ALIGNOF_WCHAR_T__",
		"__ALIGNOF_MAX_ALIGN_T__",
		"__SIZEOF_MAX_ALIGN_T__",
		"__MAX_ALIGN_TYPE__",
		"__SIZE_TYPE_IS_LONG_LONG__",
		"__PTRDIFF_TYPE_IS_LONG_LONG__",
		"__INTPTR_TYPE_IS_LONG_LONG__",
		"__SIZE_TYPE_IS_INT__",
		"__PTRDIFF_TYPE_IS_INT__",
		"__INTPTR_TYPE_IS_INT__",
		"__PTRDIFF_TYPE_IS_LONG__",
		"__INTPTR_TYPE_IS_LONG__",
		"__INT8_TYPE_IS_CHAR__",
		"__INT16_TYPE_IS_SHORT__",
		"__INT32_TYPE_IS_INT__",
		"__INT32_TYPE_IS_LONG__",
		"__INT64_TYPE_IS_LONG__",
		"__INT64_TYPE_IS_LONG_LONG__",
		"__INT8_TYPE_IS_SHORT__",
		"__INT8_TYPE_IS_INT__",
		"__INT8_TYPE_IS_LONG__",
		"__INT8_TYPE_IS_LONG_LONG__",
		"__INT16_TYPE_IS_INT__",
		"__INT16_TYPE_IS_LONG__",
		"__INT16_TYPE_IS_LONG_LONG__",
		"__INT16_TYPE_IS_CHAR__",
		"__INT32_TYPE_IS_LONG_LONG__",
		"__INT32_TYPE_IS_SHORT__",
		"__INT32_TYPE_IS_CHAR__",
		"__INT64_TYPE_IS_INT__",
		"__INT64_TYPE_IS_SHORT__",
		"__INT64_TYPE_IS_CHAR__",
		"__SIZE_TYPE_IS_LONG__",
		"__SIZE_TYPE_IS_SHORT__",
		"__SIZE_TYPE_IS_CHAR__",
		"__PTRDIFF_TYPE_IS_SHORT__",
		"__PTRDIFF_TYPE_IS_CHAR__",
		"__INTPTR_TYPE_IS_SHORT__",
		"__INTPTR_TYPE_IS_CHAR__",
		"__SIZEOF_FIFTHINT__",
		"__FIFTHINT_TYPE__",
		"__UFIFTHINT_TYPE__",
		"__FIFTHINT_ALIAS_TYPE__",
		"__UFIFTHINT_ALIAS_TYPE__",
		"__SSIZE_TYPE__",
		"__SCHAR_WIDTH__",
		"__SHRT_WIDTH__",
		"__INT_WIDTH__",
		"__LONG_WIDTH__",
		"__LONG_LONG_WIDTH__",
		"__PTRDIFF_WIDTH__",
		"__SIG_ATOMIC_WIDTH__",
		"__SIZE_WIDTH__",
		"__WCHAR_WIDTH__",
		"__WINT_WIDTH__",
		"__INT_LEAST8_WIDTH__",
		"__INT_LEAST16_WIDTH__",
		"__INT_LEAST32_WIDTH__",
		"__INT_LEAST64_WIDTH__",
		"__INT_FAST8_WIDTH__",
		"__INT_FAST16_WIDTH__",
		"__INT_FAST32_WIDTH__",
		"__INT_FAST64_WIDTH__",
		"__INTPTR_WIDTH__",
		"__INTMAX_WIDTH__",
		"__HYBRID_ALIGNOF",
		"__ARCH_HAVE_ALIGNED_WRITES_ARE_ATOMIC",
	},
#if 0 /* TODO: Deal with overlap with <hybrid/byteswap.h> */
	"<hybrid/unaligned.h>": {
		FOREACH_N("UNALIGNED_GET"),
		FOREACH_N2("UNALIGNED_GET", "_SWAP"),
		FOREACH_N("UNALIGNED_SET"),
		FOREACH_N2("UNALIGNED_SET", "_SWAP"),
		FOREACH_N("UNALIGNED_GETLE"),
		FOREACH_N("UNALIGNED_GETBE"),
		FOREACH_N("UNALIGNED_SETLE"),
		FOREACH_N("UNALIGNED_SETBE"),
	},
#endif
	"<hybrid/wordbits.h>": {
		"INT16_I8",
		"INT32_I8",
		"INT64_I8",
		"INT32_I16",
		"INT64_I16",
		"INT64_I32",
		"ENCODE_INT16",
		"ENCODE_INT32",
		"ENCODE_INT64",
		"INT16_BYTE",
		"INT32_BYTE",
		"INT64_BYTE",
		"INT32_WORD",
		"INT64_WORD",
		"INT64_DWORD",
	},
	"<hybrid/sched/__gettid.h>": {
		"__HYBRID_SIZEOF_TID__",
		"__HYBRID_GETTID_INVALID_IS_ZERO",
		"__HYBRID_GETTID_INVALID",
		"__HYBRID_GETTID_PRINTF_FMT",
		"__HYBRID_GETTID_PRINTF_ARG",
		"__hybrid_gettid",
		"__hybrid_tid_t",
		"__hybrid_gettid_equal",
		"__hybrid_tid_t_IS_NUMERIC",
		"__hybrid_gettid_iscaller",
	},
	"<hybrid/sched/__preemption.h>": {
		"__hybrid_preemption_flag_t",
		"__hybrid_preemption_pushoff",
		"__hybrid_preemption_pop",
		"__hybrid_preemption_ison",
		"__hybrid_preemption_wason",
		"__hybrid_preemption_tryyield",
		"__hybrid_preemption_tryyield_f",
		"__hybrid_preemption_tryyield_nopr",
		"__HYBRID_PREEMPTION_NO_SMP",
		"__HYBRID_PREEMPTION_NO_CONTROL",
		"__hybrid_preemption_flagvar",
		"__hybrid_preemption_acquire_smp_r",
		"__hybrid_preemption_release_smp_r",
		"__hybrid_preemption_acquire_smp",
		"__hybrid_preemption_acquire_smp_b",
		"__hybrid_preemption_release_smp_b",
		"__hybrid_preemption_release_smp",
	},
	"<hybrid/sched/__yield.h>": {
		"__hybrid_yield_IS_SleepEx",
		"__hybrid_yield_IS_sched_yield",
		"__hybrid_yield_IS_pthread_yield",
		"__hybrid_yield_IS_thrd_yield",
		"__NO_hybrid_yield",
		"__hybrid_yield",
		"__NO_hybrid_yield_nx",
		"__hybrid_yield_nx",
	},
	"<hybrid/sched/preemption.h>": {
		"preemption_flag_t",
		"preemption_pushoff",
		"preemption_pop",
		"preemption_ison",
		"preemption_wason",
		"preemption_tryyield",
		"preemption_tryyield_f",
		"preemption_tryyield_nopr",
		"PREEMPTION_NO_SMP",
		"PREEMPTION_NO_CONTROL",
		"preemption_flagvar",
		"preemption_acquire_smp_r",
		"preemption_release_smp_r",
		"preemption_acquire_smp",
		"preemption_acquire_smp_b",
		"preemption_release_smp_b",
		"preemption_release_smp",
	},
	"<hybrid/sched/yield.h>": {
		"SCHED_YIELD",
	},
	/* TODO: <hybrid/sequence/bsearch.h> */
	/* TODO: <hybrid/sequence/list.h> */
	/* TODO: <hybrid/sequence/rbtree.h> */
#undef FOREACH_N
#undef FOREACH_N2
};

global final KWD2HEADER: {string: string} = Dict.Frozen(
	for (local header, kwds: HEADER_KWDS)
		for (local kwd: kwds)
			(kwd, header)
);


class YamlParser {
	this = default;
	public member filename: string;
	public member data: Bytes;
	public member iter: int;
	public member end: int;

	private lc(offset: int): (int, int) {
		local sol = data.rfind("\n", 0, offset) + 1;
		local lno = data.count("\n", 0, sol) + 1;
		return (lno, 1 + offset - sol);
	}

	private skipCommentLines() {
again:
		while (iter < end && data.islf(iter))
			++iter;
		local afterSpace = iter;
		while (afterSpace < end && data.isspace(afterSpace))
			++afterSpace;
		if (data.startswith("#", afterSpace) || (afterSpace < end && data.islf(afterSpace))) {
			iter = (data.find("\n", afterSpace) + 1) ?: end;
			goto again;
		}
	}

	public function parseBlock(
			minIndent: int = 0,
			atStartOfLine: bool = true
	): Dict | List | string | int | none {
		if (!atStartOfLine) {
			while (iter < end && data.isspacexlf(iter))
				++iter;
			if (iter < end && data.islf(iter)) {
				atStartOfLine = true;
				++iter;
			}
		}
		local indentEnd: int;
		local indent: int;
		if (atStartOfLine) {
			skipCommentLines();
			indentEnd = iter;
			while (indentEnd < end && data.isspace(indentEnd))
				++indentEnd;
			indent = indentEnd - iter;
			if (indent < minIndent)
				return none;
		} else {
			indent = 0;
			indentEnd = iter;
		}
		if (indentEnd >= end)
			return none;
		local result;
		local indentEndCh: string = string.chr(data[indentEnd]);
		local blockPrefix: string = " " * indent;
		if (data.startswith("- ", indentEnd)) {
			/* List */
			local listItemPrefix = blockPrefix + "- ";
			result = List();
			indent += 2;
			do {
				iter += #listItemPrefix;
				local item = parseBlock(indent, false);
				if (item is none)
					break;
				result.append(item);
			} while (data.startswith(listItemPrefix, iter));
		} else if (data.issymstrt(indentEnd)) {
			/* Object */
			result = Dict();
			for (;;) {
				local identEnd = indentEnd + 1;
				while (identEnd < end && data.issymcont(identEnd))
					++identEnd;
				local key = data[indentEnd:identEnd].decode("utf-8");
				while (identEnd < end && data.isspacexlf(identEnd))
					++identEnd;
				if (identEnd >= end || data[identEnd] != ':'.ord()) {
					if (!result && identEnd < end) {
						/* Might be an unquoted string! */
						if (data.islf(identEnd) || data.startswith("#", identEnd)) {
							result = key;
							iter = identEnd;
							goto done;
						}
					}
					local d = lc(identEnd);
					throw Error(f"{filename}({d[0]}, {d[1]}) : Expected ':' after {repr key}");
				}
				++identEnd;
				while (identEnd < end && data.isspacexlf(identEnd))
					++identEnd;
				local value;
				if (!indent) {
					indent = minIndent;
					blockPrefix = " " * indent;
				}
				if (identEnd < end && (data.islf(identEnd) || data.startswith("#", identEnd))) {
					iter = identEnd + 1;
					value = parseBlock(indent + 1, true);
				} else {
					local valueIndent = identEnd - iter;
					iter = identEnd;
					value = parseBlock(valueIndent, false);
				}
				result[key] = value;
				if (!data.startswith(blockPrefix, iter))
					break;
				indentEnd = iter + indent;
				if (indentEnd >= end)
					break;
				if (!data.issymstrt(indentEnd))
					break;
			}
		} else if (data.isdigit(indentEnd) || indentEndCh in "-+") {
			local digitEnd = indentEnd + 1;
			while (digitEnd < end && data.isdigit(digitEnd))
				++digitEnd;
			result = int(data[indentEnd:digitEnd]);
			iter = digitEnd;
skip_comment_after_literal:
			while (iter < end && data.isspacexlf(iter))
				++iter;
			if (data.startswith("#", iter)) {
				skipCommentLines();
			} else if (iter >= end) {
				/* OK */
			} else if(data.islf(iter)) {
				++iter;
			} else {
				local d = lc(indentEnd);
				local eol = data.find("\n", iter);
				if (eol < 0)
					eol = end;
				local untilEol = data[iter:eol];
				local d = lc(iter);
				throw Error(f"{filename}({d[0]}, {d[1]}) : encountered garbage {
					repr untilEol.decode("utf-8")} after literal {repr result}");
			}
		} else if (indentEndCh == '"') {
			local stop = data[indentEnd];
			local stringStart = indentEnd + 1;
			local stringEnd = stringStart;
			while (stringEnd < end && (data[stringEnd] != '"'.ord() || data[stringEnd - 1] == '\\'.ord()))
				++stringEnd;
			iter = stringEnd + 1;
			result = data[stringStart:stringEnd].decode("c-escape");
			goto skip_comment_after_literal;
		} else if (indentEndCh == "'") {
			local stop = data[indentEnd];
			local stringStart = indentEnd + 1;
			local stringEnd = stringStart;
			while (stringEnd < end && data[stringEnd] != "'".ord())
				++stringEnd;
			iter = stringEnd + 1;
			result = data[stringStart:stringEnd].decode("utf-8");
			goto skip_comment_after_literal;
		} else {
			local d = lc(indentEnd);
			throw Error(f"{filename}({d[0]}, {d[1]}) : Unexpected character {
				repr string.chr(data[indentEnd])}");
		}
done:
		skipCommentLines();
		return result;
	}

	public function parse(): Dict {
		local result = parseBlock();
		if (iter < end) {
			local d = lc(iter);
			throw Error(f"{filename}({d[0]}, {d[1]}) : Unable to parse from this point forth");
		}
		if (result !is Mapping)
			throw Error(f"{filename}(1, 0) : Yaml contents do not parse as an object");
		return result;
	}
}


function parseYaml(filename: string): Dict {
	local data: Bytes;
	with (local fp = File.open(filename, "rb"))
		data = fp.read();
	return YamlParser(
		filename: filename,
		data: data,
		iter: 0,
		end: #data,
	).parse();
}

function getClangFormat(): Dict {
	static local clangFormatConfig = parseYaml(ROOTDIR + "/.clang-format");
	return clangFormatConfig;
}


function getClangIncludeCategoryRegexPriorities(): {string: int} {
	static local regexToPriority: {string: int} = (
		for (local desc: getClangFormat()["IncludeCategories"])
			(desc["Regex"], desc["Priority"])
	).asmap.frozen;
	return regexToPriority;
}

function getClangIncludePriorty(includeString: string): int {
	local regexToPriority = getClangIncludeCategoryRegexPriorities();
	for (local regex, priority: regexToPriority) {
		if (includeString.rematch(regex))
			return priority;
	}
	throw Error(f"Unable to match include string {repr includeString} to "
	            f"any priority via clang-format's 'IncludeCategories'");
}





class IncludeInfo {
	this = default;
	public final member include: string;
	public member includeStringOffset: int;
	public member includeStringEndOffset: int;
	public member commentStartOffset: int | none;
	public member commentEndOffset: int | none;
	public member comment: Bytes | string | none;

	public patchOffsets(deltaStart: int, deltaOffset: int) {
		if (includeStringOffset >= deltaStart)
			includeStringOffset += deltaOffset;
		if (includeStringEndOffset >= deltaStart)
			includeStringEndOffset += deltaOffset;
		if (commentStartOffset !is none &&
		    commentStartOffset >= deltaStart)
			commentStartOffset += deltaOffset;
		if (commentEndOffset !is none &&
		    commentEndOffset >= deltaStart)
			commentEndOffset += deltaOffset;
	}
};

class IncludeGroup {
	this = default;
	public final member includes: {IncludeInfo...} = [];
	public member groupStartOffset: int;
	public member groupEndOffset: int;

	public patchOffsets(deltaStart: int, deltaOffset: int) {
		if (groupStartOffset >= deltaStart)
			groupStartOffset += deltaOffset;
		if (groupEndOffset >= deltaStart)
			groupEndOffset += deltaOffset;
	}

	public function containsIncludePriority(priority: int) {
		for (local include: includes) {
			if (priority == getClangIncludePriorty(include.include))
				return true;
		}
		return false;
	}

	public function reformat(): Bytes | none {
		if (!includes)
			return none;
		local regexToPriority: {string: int} = getClangIncludeCategoryRegexPriorities();
		local includesByPriority: {int: {IncludeInfo...}} = Dict();
		for (local include: includes) {
			local priority = getClangIncludePriorty(include.include);
			includesByPriority.setdefault(priority, []).append(include);
		}
		if (getClangFormat()["SortIncludes"] == "true") {
			for (local none, includes: includesByPriority)
				includes.sort();
		}
		File.Writer result;
		for (local prio: includesByPriority.keys.sorted()) {
			local includes = includesByPriority[prio];
			local maxIncludeStringLength = includes.each.include.length > ...;
			for (local include: includes) {
				local includeString = include.include;
				result << "#include " << includeString;
				if (include.comment !is none) {
					result << " " * (maxIncludeStringLength - #includeString);
					result << " /* " << include.comment << " */";
				}
				result << "\n";
			}
			result << "\n"; /* Group separator */
		}
		return result.string.encode("utf-8").rstrip(); /* Strip unnecessary, trailing linefeeds */
	}

	public function addInclude(include: string, comment: string) {
		includes.append(IncludeInfo(
			include: include,
			includeStringOffset: -1,
			includeStringEndOffset: -1,
			commentStartOffset: none,
			commentEndOffset: none,
			comment: comment,
		));
	}
}

function simplifyKeywordUseList(usedKwds: Set with string) {
	for (local repGroup, repWith: {
		{ {"int8_t", "int16_t", "int32_t", "int64_t"}, "intN_t" },
		{ {"uint8_t", "uint16_t", "uint32_t", "uint64_t"}, "uintN_t" },
		{ {"INT8_C", "INT16_C", "INT32_C", "INT64_C"}, "INTn_C" },
		{ {"UINT8_C", "UINT16_C", "UINT32_C", "UINT64_C"}, "UINTn_C" },
		{ {"INT8_MIN", "INT16_MIN", "INT32_MIN", "INT64_MIN"}, "INTn_MIN" },
		{ {"INT8_MAX", "INT16_MAX", "INT32_MAX", "INT64_MAX"}, "INTn_MAX" },
		{ {"UINT8_MAX", "UINT16_MAX", "UINT32_MAX", "UINT64_MAX"}, "UINTn_MAX" },
		{ {"__INT8_MIN__", "__INT16_MIN__", "__INT32_MIN__", "__INT64_MIN__"}, "__INTn_MIN__" },
		{ {"__INT8_MAX__", "__INT16_MAX__", "__INT32_MAX__", "__INT64_MAX__"}, "__INTn_MAX__" },
		{ {"__UINT8_MAX__", "__UINT16_MAX__", "__UINT32_MAX__", "__UINT64_MAX__"}, "__UINTn_MAX__" },
		{ {"__INT8_C_SUFFIX__", "__INT16_C_SUFFIX__", "__INT32_C_SUFFIX__", "__INT64_C_SUFFIX__"}, "__INTn_C_SUFFIX__" },
		{ {"__UINT8_C_SUFFIX__", "__UINT16_C_SUFFIX__", "__UINT32_C_SUFFIX__", "__UINT64_C_SUFFIX__"}, "__UINTn_C_SUFFIX__" },
		{ {"__INT8_C", "__INT16_C", "__INT32_C", "__INT64_C"}, "__INTn_C" },
		{ {"__UINT8_C", "__UINT16_C", "__UINT32_C", "__UINT64_C"}, "__UINTn_C" },
		{ {"__SIZEOF_INT_FAST8_T__", "__SIZEOF_INT_FAST16_T__", "__SIZEOF_INT_FAST32_T__", "__SIZEOF_INT_FAST64_T__"}, "__SIZEOF_INT_FASTn_T__" },
		{ {"__INT8_TYPE__", "__INT16_TYPE__", "__INT32_TYPE__", "__INT64_TYPE__"}, "__INTn_TYPE__" },
		{ {"__UINT8_TYPE__", "__UINT16_TYPE__", "__UINT32_TYPE__", "__UINT64_TYPE__"}, "__UINTn_TYPE__" },
		{ {"__SIZEOF_INT_LEAST8_T__", "__SIZEOF_INT_LEAST16_T__", "__SIZEOF_INT_LEAST32_T__", "__SIZEOF_INT_LEAST64_T__"}, "__SIZEOF_INT_LEASTn_T__" },
		{ {"__INT_LEAST8_TYPE__", "__INT_LEAST16_TYPE__", "__INT_LEAST32_TYPE__", "__INT_LEAST64_TYPE__"}, "__INT_LEASTn_TYPE__" },
		{ {"__UINT_LEAST8_TYPE__", "__UINT_LEAST16_TYPE__", "__UINT_LEAST32_TYPE__", "__UINT_LEAST64_TYPE__"}, "__UINT_LEASTn_TYPE__" },
		{ {"__INT_FAST8_TYPE__", "__INT_FAST16_TYPE__", "__INT_FAST32_TYPE__", "__INT_FAST64_TYPE__"}, "__INT_FASTn_TYPE__" },
		{ {"__UINT_FAST8_TYPE__", "__UINT_FAST16_TYPE__", "__UINT_FAST32_TYPE__", "__UINT_FAST64_TYPE__"}, "__UINT_FASTn_TYPE__" },
		{ {"__ALIGNOF_INT8__", "__ALIGNOF_INT16__", "__ALIGNOF_INT32__", "__ALIGNOF_INT64__"}, "__ALIGNOF_INTn__" },
		{ {"__INT_LEAST8_WIDTH__", "__INT_LEAST16_WIDTH__", "__INT_LEAST32_WIDTH__", "__INT_LEAST64_WIDTH__"}, "__INT_LEASTn_WIDTH__" },
		{ {"__INT_FAST8_WIDTH__", "__INT_FAST16_WIDTH__", "__INT_FAST32_WIDTH__", "__INT_FAST64_WIDTH__"}, "__INT_FASTn_WIDTH__" },
	}) {
		if (repGroup.map(usedKwds.contains) && ...) {
			for (local g: repGroup)
				usedKwds.remove(g);
			usedKwds.insert(repWith);
		}
	}
}

class FileInfo {
	this = default;
	public final member filename: string;
	public final member includes: {string: IncludeInfo};
	public final member keywords: {string...};
	public final member noFormatRegions: {(int, int)...};
	public member data: Bytes;
	public member dataChanged: bool = false;

	private member m_includeGroups: {IncludeGroup...};

	private function getIncludeLineStart(inc: IncludeInfo): int {
		return data.rfind("\n", 0, inc.includeStringOffset) + 1;
	}
	private function getIncludeLineEnd(inc: IncludeInfo): int {
		local result;
		if (inc.commentEndOffset is none) {
			result = inc.includeStringEndOffset;
		} else {
			result = data.index("*/", inc.commentEndOffset) + 2;
		}
		while (result < #data && data.isspacexlf(result))
			++result;
		return result;
	}

	public property includeGroups: {IncludeGroup...} = {
		get(): {IncludeGroup...} {
			if (m_includeGroups is bound)
				return m_includeGroups;
			local sortedIncludes: {IncludeInfo...} = includes.values.sorted(e -> e.includeStringOffset);
			local result: {IncludeGroup...} = List();
			local currentGroup = IncludeGroup();
			for (local inc: sortedIncludes) {
				if (!currentGroup.includes) {
insert_first_include:
					currentGroup.includes.append(inc); /* First include of group */
					currentGroup.groupStartOffset = getIncludeLineStart(inc);
					currentGroup.groupEndOffset = getIncludeLineEnd(inc);
				} else {
					local prevIncludeEnd = currentGroup.groupEndOffset;
					local thisIncludeLine = getIncludeLineStart(inc);
					while (prevIncludeEnd < thisIncludeLine && data.isspace(prevIncludeEnd))
						++prevIncludeEnd;
					if (prevIncludeEnd >= thisIncludeLine) {
						/* Same group */
						currentGroup.includes.append(inc);
						currentGroup.groupEndOffset = getIncludeLineEnd(inc);
					} else {
//						print "NEW GROUP:";
//						print "	prev:", prevIncludeEnd, repr lc(prevIncludeEnd);
//						print "	curr:", thisIncludeLine, repr lc(thisIncludeLine);
//						print "	data:", repr data[prevIncludeEnd:thisIncludeLine];

						/* New group */
						result.append(currentGroup);
						currentGroup = IncludeGroup();
						goto insert_first_include;
					}
				}
			}
			if (currentGroup.includes)
				result.append(currentGroup);
			m_includeGroups = result;
			return result;
		}
	}

	public function isFormattingDisabledAt(offset: int): bool {
		for (local start, end: noFormatRegions) {
			if (offset >= start && offset < end)
				return true;
		}
		return false;
	}

	@@Return mapping {include: {keyword...}}
	public function getMissingIncludesAndKeywords(): {string: {string...}} {
		local result: {string: {string...}} = Dict();
		for (local kwd: keywords) {
			local hdr = KWD2HEADER.get(kwd);
			if (hdr !is none && hdr !in includes.keys)
				result.setdefault(hdr, []).append(kwd);
		}
		return result;
	}

	private patchOffsets(deltaStart: int, deltaOffset: int) {
		for (local inc: includes.values) {
			inc.patchOffsets(deltaStart, deltaOffset);
		}
		if (m_includeGroups is bound) {
			for (local group: m_includeGroups)
				group.patchOffsets(deltaStart, deltaOffset);
		}
		for (local i: [:#noFormatRegions]) {
			local start, end = noFormatRegions[i]...;
			if (start >= deltaStart)
				start += deltaOffset;
			if (end >= deltaStart)
				end += deltaOffset;
			noFormatRegions[i] = (start, end);
		}
	}

	private overwrite(offset: int, count: int, more: string | Bytes): bool {
		if (count || more) {
			if (more is string)
				more = more.encode("utf-8");
			local oldData = data[offset:offset + count];
			if (oldData != more) {
				data = data[:offset] + more + data[offset+count:];
				dataChanged = true;
				patchOffsets(offset, #more - count);
				return true;
			}
		}
		return false;
	}

	private insert(offset: int, more: string | Bytes) {
		return overwrite(offset, 0, more);
	}

	private delete(offset: int, count: int) {
		return overwrite(offset, count, "");
	}

	private lc(offset: int): (int, int) {
		local sol = data.rfind("\n", 0, offset) + 1;
		local lno = data.count("\n", 0, sol) + 1;
		return (lno, 1 + offset - sol);
	}

	public fix() {
		local removedIncludes: {string...} = HashSet();
		for (local inc: includes.values) {
			local kwds = HEADER_KWDS.get(inc.include);
			if (kwds !is none) {
				local usedKwds = HashSet(
					for (local k: kwds)
						if (k in this.keywords)
							k
				);
				if (!usedKwds) {
					if (!isFormattingDisabledAt(inc.includeStringOffset)) {
						print(filename, ": Removing unnecessary include ", inc.include);
						local sol = getIncludeLineStart(inc);
						local eol = getIncludeLineEnd(inc);
						if (eol < #data && data.islf(eol))
							++eol;
						delete(sol, eol - sol);
						removedIncludes.insert(inc.include);
					}
				} else {
					simplifyKeywordUseList(usedKwds);
					local correctKwdsComment = ", ".join(usedKwds.sorted(
						functools.predcmp2key(string.vercompare)
					));
					local actualKwdsComment = "";
					if (inc.commentStartOffset !is none) {
						actualKwdsComment = data[
							inc.commentStartOffset:
							inc.commentEndOffset
						].decode("utf-8");
					}
					if (actualKwdsComment != correctKwdsComment &&
					    !isFormattingDisabledAt(inc.commentStartOffset)) {
						print(filename, ": Fixing bad comment for ", inc.include,
							": ", repr actualKwdsComment, " -> ", repr correctKwdsComment);
						if (inc.commentStartOffset !is none) {
							overwrite(
								inc.commentStartOffset,
								inc.commentEndOffset - inc.commentStartOffset,
								correctKwdsComment);
						} else {
							local data = f" /* {correctKwdsComment} */".encode("utf-8");
							local index = inc.includeStringEndOffset;
							insert(index, data);
							inc.commentStartOffset = index + 4;
							inc.commentEndOffset = index + #data - 3;
						}
						inc.comment = correctKwdsComment;
					}
				}
			}
		}
		for (local x: removedIncludes)
			del includes[x];

		/* Check for missing includes, insert into groups, and re-format groups */
		local missing = getMissingIncludesAndKeywords();
		local includeGroups = this.includeGroups;
		for (local include, keywords: missing) {
			keywords = HashSet(keywords);
			simplifyKeywordUseList(keywords);
			local comment = ", ".join(keywords.sorted(
				functools.predcmp2key(string.vercompare)
			));
			local preferredIncludeGroup: IncludeGroup | none = none;
			local includePriority: int | none = none;
			for (local grp: includeGroups) {
				if (isFormattingDisabledAt(grp.groupStartOffset))
					continue;
				if (includePriority is none)
					includePriority = getClangIncludePriorty(include);
				if (grp.containsIncludePriority(includePriority)) {
					preferredIncludeGroup = grp;
					break;
				}
				if (preferredIncludeGroup is none)
					preferredIncludeGroup = grp;
			}
			if (preferredIncludeGroup is none) {
				print(filename, ": Cannot automatically add missing include: #include ",
					include, " /* ", comment, " */");
			} else {
				preferredIncludeGroup.addInclude(include, comment);
				print(filename, ": Adding missing include: #include ",
					include, " /* ", comment, " */");
			}
		}

		/* Re-format groups */
		for (local grp: includeGroups) {
			if (isFormattingDisabledAt(grp.groupStartOffset))
				continue;
			local reformattedBytes = grp.reformat();
			if (reformattedBytes !is none) {
				if (overwrite(
						grp.groupStartOffset,
						grp.groupEndOffset - grp.groupStartOffset,
						reformattedBytes
				)) {
					local d = lc(grp.groupStartOffset);
					print(f"{filename}({d[0]}, {d[1]}): Re-formatted #include group");
				}
			}
		}

		if (dataChanged) {
			with (local fp = File.open(filename, "wb"))
				fp.write(data);
		}
	}
}

function scanFile(filename: string): FileInfo {
	local data: Bytes;
	with (local fp = File.open(filename, "rb"))
		data = fp.readall();
	local i = 0, len = #data;
	local includes: {string: IncludeInfo} = Dict();
	local keywords: {string...} = HashSet();
	local noFormatRegions: {(int, int)...} = List();
	local currentNoFormatRegionStart: int | none = none;
	while (i < len) {
		if (data.isspace(i)) {
			++i;
			continue;
		} else if (data.startswith("//", i)) {
			i += 2;
seek_eol:
			i = data.find("\n", i);
			if (i < 0)
				break;
			++i;
		} else if (data.startswith("/*", i)) {
			if (data.startswith("/* clang-format off */", i)) {
				currentNoFormatRegionStart = i;
			} else if (data.startswith("/* clang-format on */", i)) {
				if (currentNoFormatRegionStart !is none) {
					noFormatRegions.append((currentNoFormatRegionStart, i));
					currentNoFormatRegionStart = none;
				}
			}
			i = data.find("*/", i + 2);
			if (i < 0)
				break;
			i += 2;
		} else if (data.startswith("#", i)) {
			local sol = data.rfind("\n", 0, i) + 1;
			if ((sol >= i) || data.isspace(sol, i)) {
				do {
					++i;
				} while (i < len && data.isspace(i));
				if (data.startswith("include ", i)) {
					i += #"include ";
					while (i < len && data.isspace(i))
						++i;
					local includeStart = i;
					if (data.startswith('"', i)) {
						i = data.find('"', i + 1);
						if (i < 0)
							break;
					} else if (data.startswith('<', i)) {
						i = data.find('>', i + 1);
						if (i < 0)
							break;
					} else {
						goto seek_eol;
					}
					++i;
					local includeEnd = i;
					local includeString = data[includeStart:includeEnd].decode("utf-8");
					while (i < len && data.isspacexlf(i))
						++i;
					local commentStartOffset: int | none = none;
					local commentEndOffset: int | none = none;
					if (data.startswith("/*", i)) {
						i += 2;
						commentStartOffset = i;
						i = data.find("*/", i);
						if (i < 0)
							break;
						commentEndOffset = i;
						i += 2;
					} else if (data.startswith("//", i)) {
						i += 2;
						commentStartOffset = i;
						i = data.find("\n", i);
						if (i < 0)
							break;
						commentEndOffset = i;
						i += 1;
					}
					local comment = none;
					if (commentStartOffset !is none) {
						while (commentStartOffset < commentEndOffset && data.isspace(commentStartOffset))
							++commentStartOffset;
						while (commentEndOffset > commentStartOffset && data.isspace(commentEndOffset - 1))
							--commentEndOffset;
						comment = data[commentStartOffset:commentEndOffset];
					}
					if (includeString !in includes) {
						includes[includeString] = IncludeInfo(
							include: includeString,
							includeStringOffset: includeStart,
							includeStringEndOffset: includeEnd,
							commentStartOffset: commentStartOffset,
							commentEndOffset: commentEndOffset,
							comment: comment,
						);
					}
					goto seek_eol;
				}
			}
			++i;
		} else if (data.issymstrt(i)) {
			local kwdStart = i;
			do {
				++i;
			} while (i < len && data.issymcont(i));
			keywords.insert(data[kwdStart:i].decode("utf-8"));
		} else {
			++i;
		}
	}

	return FileInfo(
		filename: filename,
		includes: includes,
		keywords: keywords.frozen,
		data: data,
		noFormatRegions: noFormatRegions,
	);
}


function fixFile(filename: string) {
	scanFile(filename).fix();
}

function fixPath(path: string) {
	if (path.endswith("src/dex/ctypes/ffi"))
		return;
	if (path.endswith("src/deemon/method-hints"))
		return;
	if (path.endswith("src/dex/hashlib/algorithms"))
		return;
	if (path.endswith("include/deemon/kos-headers"))
		return;
	if (path.endswith("src/dex/_hostasm/libgen86"))
		return;
	for (local ent: posix.opendir(path)) {
		local name = ent.d_fullname.replace(r"\", "/");
		if (ent.d_type == posix.DT_REG) {
			if (name.rpartition(".").last in ["c", "h", "inl"])
				fixFile(name);
		} else if (ent.d_type == posix.DT_DIR) {
			fixPath(name);
		}
	}
}


function main() {
	fixPath(ROOTDIR + r"/src/deemon");
	fixPath(ROOTDIR + r"/src/dex");
	fixPath(ROOTDIR + r"/include");
}

#ifdef __MAIN__
main();
#endif /* __MAIN__ */
