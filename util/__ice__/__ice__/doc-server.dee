/* Copyright (c) 2018 Griefer@Work                                            *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement in the product documentation would be  *
 *    appreciated but is not required.                                        *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

import * from doc;
import * from net;
import * from deemon;
import deemon;
import util;

chdir from fs(headof from fs(__FILE__));

global opname_to_symbol_map = {
	"lo" : "<",
	"le" : "<=",
	"eq" : "==",
	"ne" : "!=",
	"gr" : ">",
	"ge" : ">=",
	"add" : "+",
	"sub" : "-",
	"mul" : "*",
	"div" : "/",
	"mod" : "%",
	"shl" : "<<",
	"shr" : ">>",
	"size" : "#",
	"iterself" : "iter",
	"iternext" : "next",
	"getitem" : "[]",
	"delitem" : "del[]",
	"setitem" : "[]=",
	"getrange" : "[:]",
	"delrange" : "del[:]",
	"setrange" : "[:]=",
};

global default_return_types = {
	"length" : "int",
	"any" : "bool",
};
global default_param_list = {
	"reduce" : "(callable merger)",
};
global syntax_highlight = {
	"pack" : "h_kwd",
	"str" : "h_kwd",
	"repr" : "h_kwd",
	"copy" : "h_kwd",
	"deepcopy" : "h_kwd",
	"type" : "h_kwd",
	"try" : "h_kwd",
	"catch" : "h_kwd",
	"throw" : "h_kwd",
	"finally" : "h_kwd",
	"in" : "h_kwd",
	"is" : "h_kwd",
	"as" : "h_kwd",
	"from" : "h_kwd",
	"import" : "h_kwd",
	"print" : "h_kwd",
	"del" : "h_kwd",
	"return" : "h_kwd",
	"yield" : "h_kwd",
	"break" : "h_kwd",
	"continue" : "h_kwd",
	"goto" : "h_kwd",
	"for" : "h_kwd",
	"foreach" : "h_kwd",
	"while" : "h_kwd",
	"do" : "h_kwd",
	"switch" : "h_kwd",
	"case" : "h_kwd",
	"default" : "h_kwd",
	"assert" : "h_kwd",
	"with" : "h_kwd",
	"if" : "h_kwd",
	"else" : "h_kwd",
	"elif" : "h_kwd",
	"true" : "h_kwd",
	"false" : "h_kwd",
	"none" : "h_kwd",
	"this" : "h_kwd",
	"super" : "h_kwd",
	"bound" : "h_kwd",
	"function" : "h_kwd2",
	"global" : "h_kwd2",
	"local" : "h_kwd2",
	"static" : "h_kwd2",
	"__nth" : "h_kwd2",
	"__stack" : "h_kwd2",
	"final" : "h_kwd2",
	"class" : "h_kwd2",
	"extends" : "h_kwd2",
	"private" : "h_kwd2",
	"public" : "h_kwd2",
	"operator" : "h_kwd2",
	"property" : "h_kwd2",
	"member" : "h_kwd2",
};


local error_type_links = deemon.dict();
{	/* Recursively detect all errors, as well as their names. */
	function find_error_links(links,error_type,path) {
		path = "{}/{}".format({ path, str error_type });
		links[str error_type] = path;
		print "Found error class:",str error_type,"=",path;
		for (local attr: deemon.enumattr(error_type)) {
			if (attr.decl != error_type) break;
			if (attr.attrtype != type deemon.object) break;
			if (!attr.isclass) continue;
			find_error_links(links,error_type.operator . (attr.name),path);
		}
		return none;
	}
	find_error_links(error_type_links,deemon.Error,"/modules/deemon");
}

function recursive_hasattr(obj,attr) {
	if ("." !in attr)
		return deemon.hasattr(obj,attr);
	local parts = deemon.list(attr.split("."));
	try {
		for (local x: parts[:#parts-1])
			obj = obj.operator . (x);
	} catch (...) {
		return false;
	}
	return deemon.hasattr(obj,parts.back());
}

@"Formats parameter, or return types in prototypes, as well as \\:{...} links"
function format_type_link(mod,d,fp,name) {
	local name_link = "";
	local name_start = name.find(":");
	/* Most powerful case: an explicit module name is contained. */
	if (name_start >= 0) {
		local module_name = name[:name_start].rstrip();
		name = name[name_start+1:].lstrip();
		name_link = "/modules/{}/{}".format({
			module_name.replace(".","/"),
			name
		});
		goto has_link;
	}
	/* No `:' is contained in the type name. */
	/* #1: Search the module containing `d' */
	if (recursive_hasattr(mod,name)) {
		name_link = "/modules/{}/{}".format({
			mod.name,
			name.replace(".","/")
		});
		goto has_link;
	}
	/* #2: Search all modules imported by that module, but don't do so recursively. */
	for (local imp: mod.__imports__) {
		if (recursive_hasattr(imp,name)) {
			name_link = "/modules/{}/{}".format({
				imp.name,
				name.replace(".","/")
			});
			goto has_link;
		}
	}
	/* #3: Search the builtin `deemon' module if it wasn't already searched. */
	if (recursive_hasattr(deemon,name)) {
		name_link = "/modules/deemon/" + name.replace(".","/");
		goto has_link;
	}
	/* #4: Recursively search all builtin errors reachable
	 *     from `Error from deemon' and `Signal from deemon' */
	name_link = error_type_links.get(name,"");

	if (name_link) {
has_link:
		fp.write("<a href=\"");
		fp.write(name_link);
		fp.write("\">");
		fp.write(name);
		fp.write("</a>");
	} else {
		fp.write(name);
	}
}


global format_sourcecode;
function format_function_param(mod,d,fp,index,param) {
	local default_value = "";
	local param_type = "";
	local param_name = "";
	local temp = param.find("=");
	if (temp >= 0) {
		default_value = param[temp+1:].lstrip();
		param = param[:temp].rstrip();
	}
	temp = param.find(" ");
	if (temp >= 0) {
		param_type = param[:temp].rstrip();
		param_name = param[temp+1:].lstrip();
	} else {
		param_type = "object";
		param_name = param;
	}
	format_type_link(mod,d,fp,param_type);
	fp.write(" ");
	fp.write(param_name);
	if (default_value) {
		fp.write(" = ");
		format_sourcecode(mod,d,fp,default_value);
	}
}

function format_prototype(mod,d,fp,name,proto) {
	local item_type = d.typeof();
	proto = proto.strip().rstrip("; ");
	if (proto.startswith("function"))
		proto = proto[#"function":].lstrip();
	if (proto.startswith(name))
		proto = proto[#name:].lstrip();
	local is_type_object = item_type == type object;
	local is_callable = (is_type_object ||
		(try deemon.callable.baseof(item_type) catch (...) false));
	if (is_type_object && !proto.startswith("(") && !proto.startswith("->"))
		proto = "operator "+proto;
	if (proto.startswith("operator")) {
		name  = "operator ";
		proto = proto[#"operator":].lstrip();
		if (proto.startswith("()")) {
			local fwd = proto[2:].lstrip();
			if (fwd.startswith("(")) {
				name += "()";
				proto = fwd;
				goto got_name;
			}
		}
		local param_start = proto.find("(");
		if (param_start < 0)
			param_start = proto.find("->");
		if (param_start < 0) {
			name = proto;
			proto = "()";
			goto got_name;
		}
		name += proto[:param_start].replace(" ","");
		proto = proto[param_start:].lstrip();
	}
got_name:
	local return_type = "";
	local param_list = "";
	if (proto.startswith("(")) {
		local paren_endpos = proto.find(")");
		if (paren_endpos >= 0) {
			param_list = proto[:paren_endpos+1];
			proto = proto[paren_endpos+1:].lstrip();
		}
	}
	local arrow_pos = proto.find("->");
	if (arrow_pos >= 0) {
		return_type = proto[arrow_pos+2:].lstrip();
		proto = proto[:arrow_pos].rstrip();
	}

	if (is_callable) {
		/* Unify operator names. */
		if (name.startswith("operator ")) {
			local opname = name[#"operator ":];
			opname = opname.strip().strip("_");
			opname = opname_to_symbol_map.get(opname,opname);
			name = "operator " + opname;
		}
		if (!return_type) {
			if (name == d.name()) {
				/* Special case: constructor. */
				return_type = name;
			} else if (name.startswith("operator ")) {
				/* Default return types for operators. */
				local opname = name[#"operator ":];
				if (opname in ["+","*","/","%","<<",">>","&","|","^","**"])
					return_type = d.name();
				else if (opname in ["<","<=","==","!=",">",">=","bool","contains"])
					return_type = "bool";
				else if (opname in ["repr","str"])
					return_type = "string";
				else if (opname == "#")
					return_type = "int";
				else if (opname == "iter")
					return_type = "iterator";
			}
		}
		if (!param_list) {
			if (name.startswith("operator ")) {
				/* Default argument lists for operators. */
				local opname = name[#"operator ":];
				if (opname in ["+","*","/","%","<<",">>","&","|","^",
				               "**","<","<=","==","!=",">",">="])
					param_list = "("+d.name()+" other)";
				else if (opname in ["repr","str","bool","#"])
					param_list = "()";
				else if (opname in ["[]","del[]"])
					param_list = "(int index)";
				else if (opname in ["[]="])
					param_list = "(int index,object item)";
				else if (opname in ["[:]","del[:]"])
					param_list = "(int start,int end)";
				else if (opname in ["[:]="])
					param_list = "(int start,int end,sequence items)";
				else if (opname in ["contains"])
					param_list = "(object elem)";
			}
		}
	}
	if (!return_type) {
		return_type = default_return_types.get(name,"");
		/* If the user documented an actual parameter list,
		 * assume that the lack of a return type means that
		 * they intended the function to return `none' */
		if (!return_type)
			return_type = param_list ? "none" : "object";
	}
	if (!param_list && is_callable)
		param_list = default_param_list.get(name,"()");

	fp.write(name);
	if (!name.back().issymbol()) fp.write(" ");
	if (param_list) {
		fp.write("(");
		if (param_list.startswith("("))
			param_list = param_list[1:];
		if (param_list.endswith(")"))
			param_list = param_list[:#param_list-1];
		param_list = param_list.strip();
		if (param_list) {
			local params = deemon.list(param_list.split(","));
			for (local i,param: util.enumerate(params)) {
				format_function_param(mod,d,fp,i,param.strip());
				if (i != #params-1) fp.write(", ");
			}
		}
		fp.write(")");
	}
	fp.write(" -> ");
	format_type_link(mod,d,fp,return_type);
}

local replacements = {
	{ "\\\\", "\\{s}" },
	{ "\\\n", "\\{l}" },
	{ "\\@",  "\\{a}" },
	{ "\\:",  "\\{c}" },
	{ "\\#",  "\\{h}" },
	{ "\\$",  "\\{C}" },
	{ "\\%",  "\\{p}" },
};
function encode_escape(x) {
	for (local o,n: replacements)
		x = x.replace(o,n);
	return x;
}
function decode_escape(x) {
	for (local o,n: replacements)
		x = x.replace(n,o[1:]);
	return x;
}


function emit_human_text(fp,text) {
	text = decode_escape(text);
	text = text.replace("<","&lt;");
	text = text.replace(">","&gt;");
	text = text.replace("\n","");
	fp.write(text);
}

function find_first(s,items) {
	local tag = none;
	local result = #s;
	for (local i: items) {
		local temp = s.find(i);
		if (temp < 0) continue;
		if (temp < result) {
			tag = i;
			result = temp;
		}
	}
	return tag,result;
}

global format_sourcecode;
global format_human_doctext;
function format_human_content(mod,d,fp,prefix,content) {
	switch (prefix) {

	case ":":
		format_type_link(mod,d,fp,decode_escape(content));
		break;

	case "$":
		fp.write("<div class=\"inline_source\">");
		format_sourcecode(mod,d,fp,content);
		fp.write("</div>");
		break;

	case "@":
		fp.write("<i>");
		fp.write(content);
		fp.write("</i>");
		break;

	case "#":
		fp.write("<i>");
		/* TODO: Link to member documentation. */
		fp.write(content);
		fp.write("</i>");
		break;

	case "@":
		fp.write("<i>");
		format_human_doctext(mod,d,fp,content);
		fp.write("</i>");
		break;

	{
	case "%":
		local name;
		name,none,content = content.partition(" ")...;
		switch (name) {

		case "table":
			fp.write("<br>\r\n<table>\r\n");
			local is_first_line = true;
			for (local line: content.splitlines()) {
				line = line.strip().lstrip("- ");
				if (line) {
					fp.write("<tr>");
					for (local entry: line.split("|")) {
						fp.write(is_first_line ? "<th>" : "<td>");
						format_human_doctext(mod,d,fp,entry.strip());
						fp.write(is_first_line ? "</th>" : "</td>");
					}
					fp.write("</tr>\r\n");
				}
				is_first_line = false;
			}
			fp.write("</table>\r\n");
			break;

		case "link":
			local target;
			target,none,content = content.partition(" ")...;
			fp.write("<a href={!r}>".format({ target }));
			fp.write(content.strip());
			fp.write("</a>");
			break;

		default:
			fp.write("UNKNOWN_COMMAND(");
			fp.write(repr name);
			fp.write(",");
			fp.write(repr content);
			fp.write(")");
			break;
		}
	} break;

	default:
		fp.write("UNKNOWN_TAG(");
		fp.write(repr prefix);
		fp.write(",");
		format_human_doctext(mod,d,fp,content);
		fp.write(")");
		break;
	}
}

function format_human_doctext(mod,d,fp,text) {
	/* Encode escaped characters. */
	text = encode_escape(text);
	for (;;) {
		local st,i = find_first(text,{
			":", "@", "#", "$", "%"
		})...;
		if (st is none)
			break;
		emit_human_text(fp,text[:i]);
		text = text[i+1:];
		if (text.startswith("{")) {
			local cend = text.findmatch("{","}",1);
			if (cend < 0) cend = #text;
			format_human_content(mod,d,fp,st,text[1:cend]);
			text = text[cend+1:];
		} else {
			local cend = 1;
			while (cend < #text &&
			      (text.issymstrt(cend) ||
			       text[cend] in [".",":"]))
				++cend;
			format_human_content(mod,d,fp,st,text[:cend]);
			text = text[cend:];
		}
	}
	emit_human_text(fp,text);
}

function split_tokens(text) {
	local length = #text;
	local i = 0;
	for (;;) {
		if (i >= length) break;
		local tok_start = i;
		while (i < length && text.issymstrt(i)) ++i;
		if (i != tok_start) yield text[tok_start:i];
		if (i >= length) break;
		tok_start = i;
		if (text[i] in ["\"","\'"]) {
			local find_end = text[i];
			do ++i;
			while (i < length && (text[i] != find_end || text[i-1] == "\\"));
			if (i < length) ++i;
		} else if (text[i:i+2] == "/*") {
			i = text.find("*/",i+2);
			if (i < 0)
				i = #text;
			else
				i += 2;
		} else if (text[i:i+2] == "//") {
			i = text.find("\n",i+2);
			if (i < 0)
				i = #text;
			else
				++i;
		} else {
			++i;
		}
		if (i != tok_start)
			yield text[tok_start:i];
	}
}

function strip_common_linehead(text) {
	local lines = list(
		for (local x: text.expandtabs().splitlines())
			if (x) x);
	if (!lines) return "";
	local first_line = lines[0];
	local common_head = "";
	while (first_line && first_line[0] in [">"," "]) {
		common_head += first_line[0];
		first_line = first_line[1:];
	}
	if (common_head) {
		for (local i = 0; i < #lines; ++i) {
			local common = 0;
			local line = lines[i];
			while (common < #common_head && line[common] == common_head[common])
				++common;
			line = line[common:];
			lines[i] = line;
		}
	}
	return "\n".join(lines);
}

function format_sourcecode(mod,d,fp,text) {
	text = strip_common_linehead(text);
	for (local tok: split_tokens(text)) {
		if (!tok) continue;
		local fmt = syntax_highlight.get(tok,none);
		if (fmt is none) {
			if (tok[0] in ["\"","\'"])
				fmt = "h_string";
			else if (tok.startswith("//") || tok.startswith("/*"))
				fmt = "h_comment";
			else if (tok[0].isdigit())
				fmt = "h_number";
			else if (tok[0] in [
				"=","<",">","?",":","+","-","*","/","%",".",",",";",
				"#","(",")","[","]","{","}","~","@","&","|","^","!"]) {
				fmt = "h_symbol";
			}
		}
		tok = tok.replace("<","&lt;");
		tok = tok.replace(">","&gt;");
		tok = tok.replace(" ","&nbsp;");
		tok = tok.replace("\n","<br>\r\n");
		if (fmt !is none) {
			tok = "<var class=\"{}\">{}</var>".format({ fmt, tok });
		}
		fp.write(tok);
	}
}

@"format_doctag(module mod, DocItem d, file fp, string tag_name, string descr)"
@"@param tag_name The name of the tag. e.g. ${\"param\"}"
@"@param descr The description of the tag. e.g. ${\"descr The description of the tag\"}"
@"Format a documentation tag"
function format_doctag(mod,d,fp,tag_name,descr) {
	/* Tag names are case-insensitive */
	tag_name = tag_name.lower();
	/* Special case: The @interrupt tag is a short-hand of this. */
	if (tag_name == "interrupt") {
		tag_name = "throw";
		descr = "Signal.Interrupt: The calling :thread was interrupted";
	}
	fp.write("<var class=\"doc_tag\">");
	switch (tag_name) {

	{
	case "throw":
	case "throws":
		fp.write("Throws");
		fp.write("</var> ");
		local type_end = 0;
		while (type_end < #descr &&
		      (descr.issymstrt(type_end) ||
		       descr[type_end] in [".",":"]))
			++type_end;
		local error_typename = descr[:type_end].rstrip(":");
		descr = descr[type_end:].lstrip();
		format_type_link(mod,d,fp,error_typename);
		fp.write(" ");
		format_human_doctext(mod,d,fp,descr);
		fp.write("<br>\r\n");
	}	break;

	default:
		fp.write("UNKNOWN_TAG(<code>");
		fp.write(repr tag_name);
		fp.write("</code>):");
		fp.write("</var> ");
		format_human_doctext(mod,d,fp,descr);
		fp.write("<br>\r\n");
		break;
	}
}

@"format_doctext_part(module mod, DocItem d, file fp, string prefix, string text)"
function format_doctext_part(mod,d,fp,prefix,text) {
	if (!text) return;
	if (prefix == "@") {
		local tag_name_end = 0;
		while (tag_name_end < #text &&
		      (text.issymstrt(tag_name_end) ||
		       text[tag_name_end] in [".",":"]))
			++tag_name_end;
		local tag_name = text[:tag_name_end].rstrip(":");
		text = text[tag_name_end:].lstrip();
		format_doctag(mod,d,fp,tag_name,text.replace("\n",""));
	} else if (prefix in [">","$"]) {
		fp.write("<div class=\"source\">");
		format_sourcecode(mod,d,fp,text);
		fp.write("</div>\r\n");
	} else {
		/* Default case: emit as human-text. */
		format_human_doctext(mod,d,fp,text);
		fp.write("<br>\r\n");
	}
}

function format_doctext(mod,d,fp,text) {
	local current_line = "";
	local current_prefix = "";
	local current_prefix_length = 0;
	for (local l: text.splitlines()) {
		l = l.rstrip();
		local stripped_l;
		if (current_line.endswith("\\") && !current_line.endswith("\\\\")) {
			/* Escaped linefeed is prevents detection of special sections. */
			current_line = current_line[:#current_line-1]; /* Delete the backslash. */
			stripped_l = "";
			goto append_to_current_line;
		}
		stripped_l = l.lstrip();
		if (!stripped_l) continue; /* Skip empty lines. */
		if (current_prefix == "@" &&
		   (#l-#stripped_l) >= current_prefix_length) {
			/* Continuation of the current tag. */
			goto append_to_current_line;
		}
		if (stripped_l[0] == "@" ||
		   (current_prefix && stripped_l[0] != current_prefix) ||
		   (!current_prefix && stripped_l[0] in ["$",">"])) {
			/* Specially prefixed text. */
			format_doctext_part(mod,d,fp,current_prefix,current_line);
			current_prefix = "";
			current_prefix_length = 0;
			if (stripped_l[0] in ["$",">"]) {
				current_prefix = stripped_l[0];
				stripped_l = stripped_l[1:];
			} else if (stripped_l[0] == "@") {
				/* Figure out how long the current tag is. */
				current_prefix = "@";
				current_prefix_length = 1;
				while (current_prefix_length < #stripped_l &&
				      (stripped_l.issymstrt(current_prefix_length) ||
				       stripped_l[current_prefix_length] in [".",":"]))
					++current_prefix_length;
				/* Account for an optional, trailing ':' following the tag name. */
				if (current_prefix_length < #stripped_l &&
				    stripped_l[current_prefix_length] == ":")
					++current_prefix_length;
				stripped_l = stripped_l[1:];
			}
			current_line = stripped_l;
		} else if (current_prefix in ["$",">"]) {
			current_line += "\n";
			current_line += stripped_l[1:];
		} else {
append_to_current_line:
			if (current_line) {
				/* Append a dot at the end of a line, if the
				 * next line starts with an uppercase letter. */
				if (stripped_l[0].isupper() && current_line &&
				   !current_line.endswith(".") &&
				    current_line.isalnum(#current_line-1))
					current_line += ".";
				current_line += " \n";
			}
			current_line += stripped_l;
		}
	}
	/* Format all unwritten data. */
	format_doctext_part(mod,d,fp,current_prefix,current_line);
}

function do_typename(tp) {
	if (deemon.callable.baseof(tp))
		return "callable";
	return str tp;
}

@"format_object_attribute(module mod, DocItem d, file fp, DocItem attrib_doc)"
function format_object_attribute(mod,d,fp,attrib_doc) {
	fp.write("<a href=\"/modules/{}\">".format({
		attrib_doc.path("/")
	}));
	fp.write("{}</a>: {} -- {}".format({
		attrib_doc.name(),
		do_typename(attrib_doc.typeof()),
		attrib_doc
	}));
}

function write_page_head(fp,title) {
	fp.write(
		"<!DOCTYPE HTLM>\r\n"
		"<html>\r\n"
		"<head>\r\n"
			"<meta charset=\"UTF-8\">"
			"<link rel=\"stylesheet\" href=\"/style.css\">"
			"<title>{}</title>"
		"</head>\r\n"
		"<body>\r\n"
		.format({ title }));
}
function write_page_tail(fp) {
	fp.write("</body>\r\n</html>\r\n");
}

function get_module_page(fp,path) {
	local mod = import(path[0]);
	local d = DocItem(mod);
	for (local x: path[1:]) {
		if (!x) continue;
		d = d[x];
	}
	if (!d.hasdoc())
		d = d.deref();
	write_page_head(fp,d);
	local path = d.path("/");
	fp.write("<nav><ul>"
		"<li><a href=\"/\">home</a></li><li class=\"sep\">|</li>"
		"<li><a href=\"/modules\">modules</a></li>"
		);
	local full_path = "/modules";
	for (local x: path.split("/")) {
		full_path += "/";
		full_path += x;
		fp.write("<li><a href=\"");
		fp.write(full_path);
		fp.write("\">&gt;");
		fp.write(x);
		fp.write("</a></li>");
	}
	fp.write("</ul></nav>\r\n"
	         "<main>\r\n"
	         "<div class=\"type_proto\">\r\n");
	for (local tok: d.tokenize()) {
		fp.write("<div class=\"doc_token\">");
		if (tok.header) {
			local name = d.name();
			fp.write("<div class=\"proto_header\">");
			for (local head: tok.header.strip().splitlines(false)) {
				fp.write("<div class=\"code\">");
				format_prototype(mod,d,fp,name,head);
				fp.write("</div>");
				fp.write("\r\n");
			}
			fp.write("</div>");
		}
		fp.write("<div class=\"proto_text\">");
		format_doctext(mod,d,fp,tok.text.strip());
		fp.write("</div></div><br>\r\n");
	}
	fp.write("</div>\r\n");
	local attr = list(d.enumerate());
	local class_attr = list(attr.filter([](x) -> x.attr().isclass && !x.attr().isinstance));
	local instance_attr = list(attr.filter([](x) -> !x.attr().isclass || x.attr().isinstance));
	if (class_attr) {
		class_attr.sort([](a,b) -> a.name() < b.name());
		fp.write("<div><div class=\"category_title\">Class Attributes</div>\r\n");
		for (local x: class_attr) {
			format_object_attribute(mod,d,fp,x);
			fp.write("<br>\r\n");
		}
		fp.write("</div>\r\n");
	}
	if (instance_attr) {
		instance_attr.sort([](a,b) -> a.name() < b.name());
		fp.write("<div><div class=\"category_title\">Instance Attributes</div>\r\n");
		for (local x: instance_attr) {
			format_object_attribute(mod,d,fp,x);
			fp.write("<br>\r\n");
		}
		fp.write("</div>\r\n");
	}
	fp.write("</main>\r\n");
	write_page_tail(fp);
}

function ls_modules_path(p,prefix) {
	import fs;
	try {
		for (local f: fs.dir(p)) {
			local path = fs.joinpath(p,f);
			if (fs.stat.isdir(path)) {
				/* Skip files found in /include-folders. */
				if (f == "include")
					continue;
				local new_prefix = "{}{}.".format({ prefix, f });
				for (local x: ls_modules_path(path,prefix))
					yield new_prefix + x;
				continue;
			}
			if (f.startswith(".") && f.startswith(".dec"))
				yield f[1:#f-4];
			else if (f.endswith(".so"))
				yield f[:#f-3];
			else if (f.endswith(".dll"))
				yield f[:#f-4];
			else if (f.endswith(".dee"))
				yield f[:#f-4];
		}
	} catch (...) {
	}
}
function ls_modules() {
	yield "deemon";
	for (local p: deemon.module.path) {
		yield ls_modules_path(p,"")...;
	}
}

function get_modules_list(fp) {
	write_page_head(fp,"Modules");
	fp.write("<nav><ul>"
		"<li><a href=\"/\">home</a></li><li class=\"sep\">|</li>"
		"<li><a href=\"/modules\">modules</a></li>"
		"</ul></nav><main>\r\n");
	for (local name: ls_modules()) {
		fp.write("<div class=\"module_item\">");
		fp.write("<a href=\"/modules/");
		fp.write(name);
		fp.write("\">");
		fp.write(name);
		fp.write("</a>");
		fp.write("</div>");
	}
	fp.write("</main>");
	write_page_tail(fp);
}

function get_home_page(fp) {
	write_page_head(fp,"Home");
	fp.write("<nav><ul>"
		"<li><a href=\"/\">home</a></li><li class=\"sep\">|</li>"
		"<li><a href=\"/modules\">modules</a></li>"
		"</ul></nav><main>\r\n");
	fp.write("<h1>Deemon Documentation</h1>\r\n");
	fp.write("<a href=\"/modules\">List of all modules</a><br>\r\n");
	fp.write("</main>");
	write_page_tail(fp);
}


function get_page(fp,path) {
	path = path.strip("/").strip();
	path = path.split("/");
	if (path[0] == "modules") {
		if (#path >= 2) {
			return get_module_page(fp,path[1:]);
		}
		return get_modules_list(fp);
	}
	if (path[0] == "") {
		return get_home_page(fp);
	}
	throw "Missing page: {!r}".format({ path });
}


function ClientThreadMain(con) {
	print "New connection:",repr con;
	try {
		try {
			try for (;;) {
				local msg = con.recv();
				if (!msg)
					break; /* The other end disconnected gracefully */
				local command = msg.splitlines()[0];
				local fp = file.writer();
				if (!command.startswith("GET") ||
					!command.endswith("HTTP/1.1")) {
					print "Bad command:",repr command;
					fp.write("HTTP/1.1 400 Bad Request\r\n");
				} else {
					command = command[3:#command-8].strip();
					local content;
					if (command == "/style.css") {
						content = deemon.file.open("style.css","r").read();
					} else {
						content = file.writer();
						get_page(content,command);
						content = content.string;
					}
					fp.write(
						"HTTP/1.1 200 OK\r\n"
						"Content-Length: {}\r\n"
						"Content-Type: text/html; charset=iso-8859-1\r\n"
						"\r\n".format({ #content }));
					fp.write(content);
				}
				con.send(fp.string);
			} catch (e...) {
				local err_out = file.writer();
				local err_content = file.writer();
				write_page_head(err_content,e);
				err_content.write("<main>\r\n");
				err_content.write("<h2>DOC Server crashed</h2><br>");
				err_content.write("<hr>");
				if (e !is string) {
					err_content.write("<b>");
					err_content.write(str(type e));
					err_content.write("</b>: ");
				}
				err_content.write((e is string ? e : repr e).replace("\n","<br>\r\n"));
				err_content.write("<hr>");
				err_content.write((repr deemon.traceback.current()).replace("\n","<br>\r\n"));
				err_content.write("<hr>");
				err_content.write("</main>\r\n");
				write_page_tail(err_content);
				err_content = err_content.string;
				err_out.write(
					"HTTP/1.1 200 OK\r\n"
					"Content-Length: {}\r\n"
					"Content-Type: text/html; charset=iso-8859-1\r\n"
					"\r\n".format({ #err_content }));
				err_out.write(err_content);
				con.send(err_out.string);
				throw;
			}
		} finally {
			con.close();
			print "Disconnected:",repr con;
		}
	} catch (e...) {
		print "Client thread crashed:";
		print repr e;
		print repr deemon.traceback.current();
	}

}



local s = socket("INET6",none,none);
s.bind("localhost:8080");
s.listen();

print "Doc Server is up & running.";
print "Open your Web Brower and navigate to:";
print "127.0.0.1:8080";
print;
print;

for (;;) {
	local con = s.accept();
	local th = thread(ClientThreadMain,pack con);
	th.start();
	th.detach();
}





















