/* Copyright (c) 2018-2025 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2018-2025 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

import * from deemon;
import * from errors;
import * from "rt.hints.method";
import * from "rt.hints.operator";
import int, * from ctypes;
import deemon;
import ipc;
import rt;

/* Tests for stuff that only works under "CONFIG_EXPERIMENTAL_UNIFIED_METHOD_HINTS" */
if (!hasattr(rt, "SeqEnumWithSeqOperatorSizeAndGetItemIndexFast"))
	return; // "CONFIG_EXPERIMENTAL_UNIFIED_METHOD_HINTS" isn't enabled; don't run this test


local final DeeObject_ptr = void.ptr;
local final Dee_funptr_t = try void.func(void).ptr catch (NotImplemented) ({
	/* NotImplemented: ctypes was built without C-functions being enabled */
	return;
});
local final deemonExe = ShLib(ipc.Process.current.exe);
local final DeeType_GetMethodHint = (Dee_funptr_t(DeeObject_ptr, int).ptr)(
	Mapping.get(deemonExe, "DeeType_GetMethodHint") ??
	Mapping.get(deemonExe, "_DeeType_GetMethodHint") ??
	Mapping.get(deemonExe, "_DeeType_GetMethodHint@8") ??
	none
);

local final DeeType_GetNativeOperatorWithoutUnsupported = (Dee_funptr_t(DeeObject_ptr, int).ptr)(
	Mapping.get(deemonExe, "DeeType_GetNativeOperatorWithoutUnsupported") ??
	Mapping.get(deemonExe, "_DeeType_GetNativeOperatorWithoutUnsupported") ??
	Mapping.get(deemonExe, "_DeeType_GetNativeOperatorWithoutUnsupported@8") ??
	none
);

/* If neither of these methods could be loaded, then don't run this test. */
if (!DeeType_GetMethodHint && !DeeType_GetNativeOperatorWithoutUnsupported)
	return;

function _addr2name(addr: void.ptr): string | none {
	if (!addr)
		return "NULL";
	local nameAndDelta: (string, int) | none = ShLib.addr2name(addr);
	if (nameAndDelta is none)
		return none;
	local name, delta = nameAndDelta...;
	if (delta == 0)
		return name;
	return none;
}

@@Returns the name of the function used to implement method hint @hint of @type
@@If name cannot be determined (e.g. debug info not available/supported), return @none
@@If the hint isn't supported, return @"NULL"
function _Type_getMethodHintName(typ: Type, hint: string): string | none {
	if (!DeeType_GetMethodHint)
		return none;
	local typAddr: void.ptr = rt.ctypes_addrof(typ);
	local hintAddr = DeeType_GetMethodHint(typAddr, TMH_BYNAME[hint]);
	return _addr2name(hintAddr);
}


@@Returns the name of the function used to implement native operator @op of @type
@@If name cannot be determined (e.g. debug info not available/supported), return @none
@@If the operator isn't supported, return @"NULL"
function _Type_getNativeOperatorName(typ: Type, op: string): string | none {
	if (!DeeType_GetNativeOperatorWithoutUnsupported)
		return none;
	local typAddr: void.ptr = rt.ctypes_addrof(typ);
	local hintAddr = DeeType_GetNativeOperatorWithoutUnsupported(typAddr, TNO_BYNAME[op]);
	return _addr2name(hintAddr);
}


@@Combination of @_Type_getMethodHintName and @_Type_getNativeOperatorName
function Type_getImplName(typ: Type, hintOrOperator: string): string | none {
	if (hintOrOperator.startswith("tp_"))
		return _Type_getNativeOperatorName(typ, hintOrOperator[3:]);
	if (hintOrOperator.startswith("mh_"))
		return _Type_getMethodHintName(typ, hintOrOperator[3:]);
	return none;
}

function Type_assert(typ: Type, impls: {string: string}) {
	for (local hintOrOperator, expectedImpl: impls) {
		local actualImpl: string | none = Type_getImplName(typ, hintOrOperator);
		if (actualImpl !is none) {
			assert expectedImpl in actualImpl,
				f"'{typ}.<native>.{hintOrOperator}' should be "
				f"'{expectedImpl}', but is '{actualImpl}'";
		}
	}
}


#ifndef __MAIN__

/* Assert that operators that are inherited also have their  */

//@[nobuiltin] // TODO: New compiler tag
class MyCell: Cell {
	this = super;
}
Type_assert(MyCell, {
	"tp_compare":       "cell_compare",
	"tp_compare_eq":    "cell_compare", /* Used to be "default__compare_eq__with__compare" */
	"tp_trycompare_eq": "cell_trycompare_eq", /* Used to be "default__trycompare_eq__with__compare_eq" */
	"tp_eq":            "default__eq__with__compare_eq",
	"tp_ne":            "default__ne__with__compare_eq",
	"tp_lo":            "default__lo__with__compare",
	"tp_le":            "default__le__with__compare",
	"tp_gr":            "default__gr__with__compare",
	"tp_ge":            "default__ge__with__compare",
});


Type_assert(deemon.Dict, {
	/* TODO */
});




#endif  /* !__MAIN__ */

#ifdef __MAIN__
function getAllImpls(typ: Type): {(string, string)...} {
	for (local tnoName: TNO_BYNAME.keys) {
		local symName = _Type_getNativeOperatorName(typ, tnoName);
		if (symName !is none)
			yield ("tp_" + tnoName, symName);
	}
	for (local tmhName: TMH_BYNAME.keys) {
		local symName = _Type_getMethodHintName(typ, tmhName);
		if (symName !is none)
			yield ("mh_" + tmhName, symName);
	}
}

function dumpType(typ: Type) {
	local allImpls = Dict(
		for (local name, impl: getAllImpls(typ))
			if (impl.startswith("default_"))
				(name, impl)
	);
	print(f"Type_assert({repr typ}, \{");
	local longestNameLen = allImpls.keys.each.length > ...;
	for (local a, b: allImpls) {
		print("	", f"{repr a}:".ljust(longestNameLen + 3), " ", repr b, ",");
	}
	print(f"\});");
}

dumpType(Dict);

#endif /* __MAIN__ */

