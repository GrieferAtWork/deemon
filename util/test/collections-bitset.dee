#!/usr/bin/deemon
/* Copyright (c) 2018-2024 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2018-2024 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

import * from deemon;
import * from collections;

function intbits(i: int): BitsetView {
	local iBytes = i.tobytes(byteorder: "little", signed: false);
	local view = BitsetView(iBytes, "w", 0, i.bitcount(signed: false));
	assert view.bytes() == iBytes;
	assert Bitset(view).bytes() == iBytes;
	return view;
}

function assertBitsetOk(b: Bitset | BitsetView) {
	local orig = copy b;
	assert orig == b;
	b &= b;
	assert orig == b;
	b |= b;
	assert orig == b;
	b ^= b;
	assert {} == b;
}

function assertBitsetImpl2(expected: {int...}, actual: Bitset | BitsetView | Bitset.Frozen) {
	assert expected == actual;
	assert !(expected != actual);
	assert expected <= actual;
	assert expected >= actual;
	assert !(expected < actual);
	assert !(expected > actual);
	for (local x: expected) {
		assert actual[x];
		assert x in actual;
	}
}

function assertBitsetImpl(expected: {int...}, actual: BitsetView) {
	assertBitsetImpl2(expected, actual);
	assertBitsetImpl2(expected, actual.frozen);
	assertBitsetImpl2(expected, Bitset(actual));
	assertBitsetImpl2(expected, Bitset(actual).frozen);
	assertBitsetImpl2(expected, Bitset.Frozen(actual));
	assertBitsetImpl2(expected, Bitset.Frozen(actual).frozen);
	assertBitsetImpl2(expected, BitsetView(actual));
	assertBitsetImpl2(expected, BitsetView(actual).frozen);
	assertBitsetImpl2(expected, BitsetView(actual.frozen));
	assertBitsetImpl2(expected, BitsetView(actual.frozen).frozen);
	assertBitsetImpl2(expected, BitsetView(actual.bytes()));
	assertBitsetImpl2(expected, BitsetView(actual.bytes()).frozen);
	assertBitsetImpl2(expected, BitsetView(Bitset(actual).bytes()));
	assertBitsetImpl2(expected, BitsetView(Bitset(actual).bytes()).frozen);
	assertBitsetImpl2(expected, BitsetView(Bitset(actual).frozen.bytes()));
	assertBitsetImpl2(expected, BitsetView(Bitset(actual).frozen.bytes()).frozen);
}

function assertBitset(expected: {int...}, actual: BitsetView) {
	/* Ensure that trying to open a frozen bitset for writing throws a BufferError */
	assert (try BitsetView(actual.frozen, "w") catch (e...) e) is BufferError from errors;
	assertBitsetOk(Bitset(actual));
	assertBitsetOk(BitsetView(Bitset(actual), "w"));
	assertBitsetImpl(expected, actual);
	assertBitsetImpl(Bitset(expected), actual);
	assertBitsetImpl(Bitset(expected).frozen, actual);
	assertBitsetImpl(Bitset.Frozen(expected), actual);
	assertBitsetImpl(Bitset.Frozen(expected).frozen, actual);
}

assertBitset({},      intbits(0));
assertBitset({0},     intbits(1));
assertBitset({1},     intbits(2));
assertBitset({0,1},   intbits(3));
assertBitset([:8],    intbits(0xff));
assertBitset([1:8],   intbits(0xfe));
assertBitset([8:16],  intbits(0xff00));
assertBitset([16:24], intbits(0xff0000));
assertBitset([24:32], intbits(0xff000000));
assertBitset([4:8],   intbits(0xf0));
assertBitset([12:16], intbits(0xf000));
assertBitset([20:24], intbits(0xf00000));
assertBitset([28:32], intbits(0xf0000000));
assertBitset([:64],   intbits(0xffffffffffffffff));
assertBitset([:128],  intbits(0xffffffffffffffffffffffffffffffff));
assertBitset([:252],  intbits(0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff));
assertBitset([:256],  intbits(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff));
assertBitset([1:256], intbits(0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe));
assertBitset(
	{0,3,4,7,8,10,12,14,15,17,21},
	intbits(0b1000101101010110011001));
assertBitset({0,63},  intbits(0x8000000000000001));
assertBitset(
	{0,3,4,6,8,9,10,11,13,14,16,18,20,21,22,29,33,34,37,38,40,41,
	 42,43,45,46,48,50,52,53,54,57,58,59,61,62,66,69,70,77,82,84,
	 85,86,91,93,94,96,98,101,102,109,112,113,116,117,118,120,122,
	 125,126,128,129,133,134,137,140,141,142,144,146,149,150,154,
	 156,157,158,165,168,169,172,173,174,176,181,182,184,186,188,
	 189,190,192,193,197,198,200,202,205,206,208,213},
	intbits(0x216563756173207465726365732065687420646e756f6620756f59));

function testSetAndClear(setrange, delrange) {
	local b = Bitset(32);
	assertBitset({}, b);
	setrange(b, 0, 0);
	assertBitset({}, b);
	delrange(b, 0, 0);
	assertBitset({}, b);
	setrange(b, 0, 1);
	assertBitset({0}, b);
	setrange(b, 0, -1);
	assertBitset([:31], b);
	setrange(b, 0, 32);
	assertBitset([:32], b);
	delrange(b, 1, 31);
	assertBitset({0,31}, b);
	delrange(b, 0, 32);
	assertBitset({}, b);
	setrange(b, 9999, 9999);
	assertBitset({}, b);
	setrange(b, -1, 9999);
	assertBitset({31}, b);
	setrange(b, 0, 9999);
	assertBitset([:32], b);
	delrange(b, -1, 9999);
	assertBitset([:31], b);
	delrange(b, -8, 9999);
	assertBitset([:24], b);
	delrange(b, -30, -9);
	assertBitset({0,1,23}, b);
	delrange(b, -32, -31);
	assertBitset({1,23}, b);
	delrange(b, -32, -30);
	assertBitset({23}, b);
	b[23] = false;
	assertBitset({}, b);
	b[7] = true;
	b[9] = true;
	assertBitset({7,9}, b);
	del b[9];
	assertBitset({7}, b);
	del b[8];
	assertBitset({7}, b);
}

testSetAndClear((b, s, e) -> { b[s:e] = true; }, (b, s, e) -> { del b[s:e]; });
testSetAndClear((b, s, e) -> { b[s:e] = true; }, (b, s, e) -> { b[s:e] = false; });
testSetAndClear((b, s, e) -> { b[s:e] = true; }, (b, s, e) -> { b[s:e] = none; });
