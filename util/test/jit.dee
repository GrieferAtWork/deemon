#!/usr/bin/deemon
/* Copyright (c) 2018-2020 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2018-2020 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

/* Assert correct evaluation of some basic JIT expressions. */

import deemon;
import * from deemon;

function identical(a, b) {
	return type a === type b
		/* Make sure that the comparison works in every way */
		&& (a == b)
		&& (b == a)
		&& !(a != b)
		&& !(b != a)
		;
}

/* Basic literal / constant parsing. */
assert identical(exec(r'1'),          1);
assert identical(exec(r'1.0'),        1.0);
assert identical(exec(r'"foo"'),      "foo");
assert identical(exec(r"'foo'"),      "foo");
assert identical(exec(r'true'),       true);
assert identical(exec(r'false'),      false);
assert identical(exec(r'none'),       none);
assert identical(exec(r'1;'),         1);
assert identical(exec(r'1.0;'),       1.0);
assert identical(exec(r'"foo";'),     "foo");
assert identical(exec(r"'foo';"),     "foo");
assert identical(exec(r'true;'),      true);
assert identical(exec(r'false;'),     false);
assert identical(exec(r'none;'),      none);

/* Simple arithmetic. */
assert identical(exec(r'10*2 + 11*3'),  53);
assert identical(exec(r'10/2*5'),       25);
assert identical(exec(r'10/(2*5)'),     1);
assert identical(exec(r'10*2 + 11*3;'), 53);
assert identical(exec(r'10/2*5;'),      25);
assert identical(exec(r'10/(2*5);'),    1);

/* Simple unary instructions */
assert identical(exec(r'str 1'),       "1");
assert identical(exec(r'str 1.0'),     "1.0");
assert identical(exec(r'type true'),   bool);
assert identical(exec(r'type(true)'),  bool);
assert identical(exec(r'str(true)'),   "true");
assert identical(exec(r'str 1;'),      "1");
assert identical(exec(r'str 1.0;'),    "1.0");
assert identical(exec(r'type true;'),  bool);
assert identical(exec(r'type(true);'), bool);
assert identical(exec(r'str(true);'),  "true");

/* Parenthesis vs. tuples, as well as expand-Sequence casting. */
assert identical(exec(r'(1)'),          1);
assert identical(exec(r'(1,)'),         Tuple { 1 });
assert identical(exec(r'(1, 2)'),       Tuple { 1, 2 });
assert identical(exec(r'()'),           Tuple { });
assert identical(exec(r'([]...)'),      Tuple { });
assert identical(exec(r'([]...,)'),     Tuple { });
assert identical(exec(r'([1]...)'),     Tuple { 1 });
assert identical(exec(r'([1]...,)'),    Tuple { 1 });
assert identical(exec(r'([1, 2]...)'),  Tuple { 1, 2 });
assert identical(exec(r'([1, 2]...,)'), Tuple { 1, 2 });
assert identical(exec(r'[]'),           List { });
assert identical(exec(r'[1]'),          List { 1 });
assert identical(exec(r'[1,]'),         List { 1 });
assert identical(exec(r'[1, 2]'),       List { 1, 2 });
assert identical(exec(r'[()...]'),      List { });
assert identical(exec(r'[()...,]'),     List { });
assert identical(exec(r'[(1,)...]'),    List { 1 });
assert identical(exec(r'[(1,)...,]'),   List { 1 });
assert identical(exec(r'[(1, 2)...]'),  List { 1, 2 });
assert identical(exec(r'[(1, 2)...,]'), List { 1, 2 });
assert identical(exec(r'(Tuple from deemon)([:5])'), Tuple { 0, 1, 2, 3, 4 });
assert identical(exec(r'Tuple from deemon([:5])'), Tuple { 0, 1, 2, 3, 4 });

/* Range expressions. */
assert identical(exec(r'[:20]'),      Sequence.range(0, 20));
assert identical(exec(r'[:20, 2]'),   Sequence.range(0, 20, 2));
assert identical(exec(r'[10:20]'),    Sequence.range(10, 20));
assert identical(exec(r'[10:20, 2]'), Sequence.range(10, 20, 2));

/* Attribute lookup. */
assert identical(exec(r'(string from deemon).center'), string.center);

/* The builtin import() function. */
assert exec(r'import("deemon")') === deemon;

/* Bound expressions. */
assert identical(exec(r'"foo".find is bound'), true);
assert identical(exec(r'"foo".nonexisting_symbols is bound'), false);
assert identical(exec(r'"foo".find !is bound'), false);
assert identical(exec(r'"foo".nonexisting_symbols !is bound'), true);
assert identical(exec(r'"foo".find !!is bound'), true);
assert identical(exec(r'"foo".nonexisting_symbols !!is bound'), false);
assert identical(exec(r'bound("foo".find)'), true);
assert identical(exec(r'bound("foo".nonexisting_symbols)'), false);
assert identical(exec(r'bound("foo".nonexisting_symbols);'), false);

assert identical(exec(r'10'), 10);
assert identical(exec(r'10;'), 10);
assert identical(exec(r'[10, 20, "foo", false, none]'), [10, 20, "foo", false, none]);
assert identical(exec(r'[10, 20, "foo", false, none];'), [10, 20, "foo", false, none]);
assert identical(#exec(r'[10, 20, "foo", false, none]'), #[10, 20, "foo", false, none]);
assert identical(#exec(r'[10, 20, "foo", false, none];'), #[10, 20, "foo", false, none]);
assert identical(exec(r'#[10, 20, "foo", false, none]'), #[10, 20, "foo", false, none]);
assert identical(exec(r'#[10, 20, "foo", false, none];'), #[10, 20, "foo", false, none]);
assert identical(exec(r'({ 10; })'), 10);
assert identical(exec(r'({ 10; });'), 10);
assert identical(exec(r'{ 10; }'), 10);
assert identical(exec(r'{ 10; };'), none);
assert exec(r'{ 10 }') == { 10 };
assert exec(r'{ 10 };') == { 10 };
assert exec(r'{ 10, }') == { 10 };
assert exec(r'{ 10, };') == { 10 };
assert identical(exec(r'{ 10, 20, "foo", false, none; }'), none);
assert identical(exec(r'({ 10, 20, "foo", false, none; })'), none);
assert identical(exec(r'{ 10, 20, "foo", false, none; }'), ({ 10, 20, "foo", false, none; }));
assert identical(exec(r'({ 10, 20, "foo", false, none; })'), ({ 10, 20, "foo", false, none; }));

for (local code: {
	r'{ 10, 20, "foo", false, none }',
	r'{ 10, 20, "foo", false, none };',
	r'({ 10, 20, "foo", false, none })',
	r'({ 10, 20, "foo", false, none });',
}) {
	assert exec(code) == { 10, 20, "foo", false, none };
}

for (local code: {
	r'{ 10: 20, 20: 30, "foo": "bar" }',
	r'({ 10: 20, 20: 30, "foo": "bar" })',
	r'({ 10: 20, 20: 30, "foo": "bar" });',
}) {
	local map = exec(code);
	assert identical(#map, 3);
	assert identical(map.get(10), 20);
	assert identical(map.get(20), 30);
	assert identical(map.get("foo"), "bar");
	assert identical(map[10], 20);
	assert identical(map[20], 30);
	assert identical(map["foo"], "bar");
}

for (local code: {
	r'local x = { 10, 20, 30 };x;',
	r'global x = { 10, 20, 30 };x;',
	r'x = { 10, 20, 30 };x;',
}) {
	assert exec(code) == { 10, 20, 30 };
}

for (local code: {
	r'x = 42;',
	r'x = 42',
	r'global x = 42;',
	r'global x = 42',
}) {
	local glob = Dict();
	exec(code, globals: glob);
	assert identical(glob["x"], 42);
}

for (local code: {
	r'x = { 10, 20, 30 };',
	r'x = { 10, 20, 30 }',
	r'global x = { 10, 20, 30 };',
	r'global x = { 10, 20, 30 }',
}) {
	local glob = Dict();
	exec(code, globals: glob);
	assert glob["x"] == { 10, 20, 30 };
}


/* Conditional execution containing an errorous dead branch. */
assert identical(exec(r'true ? "ok" : "foo".bar.baz.bim'), "ok");

{
	local glob = Dict {
		"x" : "foo",
		"y" : 20,
	};
	exec(r'result = x.center(y - 5)', globals: glob);
	assert identical(glob["result"], "foo".center(15));
}

assert identical(exec(r'x = 2'), 2);
assert identical(exec(r'x = 2;'), 2);
assert identical(exec(r'global x = 2'), 2);
assert identical(exec(r'global x = 2;'), 2);
assert identical(exec(r'local x = 2'), 2);
assert identical(exec(r'local x = 2;'), 2);

assert identical(exec(r'function foo(x) -> x * 2')(7), 14);
assert identical(exec(r'function foo(x) -> x * 2;')(7), 14);
assert identical(exec(r'function foo(x) { return x * 2; }')(7), 14);
assert identical(exec(r'function foo(x) { return x * 2; };')(7), none);
assert identical(exec(r'global function foo(x) -> x * 2')(7), 14);
assert identical(exec(r'global function foo(x) -> x * 2;')(7), 14);
assert identical(exec(r'global function foo(x) { return x * 2; }')(7), 14);
assert identical(exec(r'global function foo(x) { return x * 2; };')(7), none);
assert identical(exec(r'local function foo(x) -> x * 2')(7), 14);
assert identical(exec(r'local function foo(x) -> x * 2;')(7), 14);
assert identical(exec(r'local function foo(x) { return x * 2; }')(7), 14);
assert identical(exec(r'local function foo(x) { return x * 2; };')(7), none);
assert identical(exec(r'function(x) -> x * 2')(7), 14);
assert identical(exec(r'function(x) -> x * 2;')(7), 14);
assert identical(exec(r'function(x) { return x * 2; }')(7), 14);
assert identical(exec(r'function(x) { return x * 2; };')(7), none);
assert identical(exec(r'[](x) -> x * 2')(7), 14);
assert identical(exec(r'[](x) -> x * 2;')(7), 14);
assert identical(exec(r'[](x) { return x * 2; }')(7), 14);
/* Syntactic difference: `[]() { }' is an expression, so `[]() { };' still
 * evaluates to that same expression. `function() { }' is a pseudo-statement
 * that doesn't expect a trailing `;'-character, so `function() { };' are
 * actually 2 statements `function() { }' and `;', with the later (`;')
 * evaluating to `none'! */
assert identical(exec(r'[](x) { return x * 2; };')(7), 14);


/* Test simple lambda expressions */
{
	local lmb = exec(r'[](x) -> x.startswith("foo")');
	local items = ["foz", "foo", "bar", "foobar"];
	items.removeif(lmb);
	assert items == ["foz", "bar"];
}
/* Also re-try the test with a block-lambda */
{
	local lmb = exec(r'[](x) { return x.startswith("foo"); }');
	local items = ["foz", "foo", "bar", "foobar"];
	items.removeif(lmb);
	assert items == ["foz", "bar"];
}

{
	local glob = Dict();
	/* Execute a piece of code to define some globals,
	 * as well as create and return a JIT function. */
	local x = exec(r'
		bar = "foobar";
		function foo(x?, y = 3) {
			if (x !is bound)
				return bar;
			return x + y;
		}
	', globals: glob);

	/* Ensure that globals were created correctly */
	assert glob["bar"] == "foobar";
	assert glob["foo"] === x;

	/* Ensure that invocations of the function behave properly */
	assert x() === glob["bar"];
	assert x(10) == 13;
	assert x(10, 20) == 30;

	/* Ensure that the correct meta-data is available for the function */
	assert x.__name__ == "foo";
	assert x.__kwds__ == { "x", "y" };
	assert x.__argc_min__ == 0;
	assert x.__argc_max__ == 2;
	assert x.__globals__ === glob;
}

/* C-style cast expressions */
assert identical(exec(r'(import("deemon").int)"42"'), 42);
assert identical(exec(r'(import("deemon").int)42'), 42);
assert identical(exec(r'(import("deemon").List){ 10, 20, 30 }'), [10, 20, 30]);


for (local typ: { Tuple, List, Dict, HashSet }) {
	for (local code: {
		r'import("deemon").{typ}(())',
		r'import("deemon").{typ}(());',
		r'import("deemon").{typ}(none)',
		r'import("deemon").{typ}(none);',
		r'import("deemon").{typ}()',
		r'import("deemon").{typ}();',
//		r'local x = import("deemon").{typ}; x()', /* Not allowed! */
		r'local x = import("deemon").{typ}; x();',
		/* NOTE: Double-`{{' and `}}' is only here because that's how
		 *       `{' and `}' characters are escaped in string.format() */
		r'({{ local x = import("deemon").{typ}; x(); }})',
		r'({{ local x = import("deemon").{typ}; x(); }});',
		r'(import("deemon").{typ})(())',
		r'(import("deemon").{typ})(());',
		r'(import("deemon").{typ})(none)',
		r'(import("deemon").{typ})(none);',
		r'(import("deemon").{typ})()',
		r'(import("deemon").{typ})();',
		r'(import("deemon").{typ})none',
		r'(import("deemon").{typ})none;',
//TODO:		r'import("deemon").{typ} pack',
//TODO:		r'import("deemon").{typ} pack;',
//TODO:		r'import("deemon").{typ} pack()',
//TODO:		r'import("deemon").{typ} pack();',
	}) {
		code = code.format({ "typ" : typ });
		assert identical(exec(code), typ(()));
		assert identical(exec(code), typ());
	}
}

assert identical(exec(r'"{{foo{bar}}}".format({ "bar" : 42 })'), "{foo42}");
assert identical(exec(r'"{{{bar}foo{bar}}}".format({ "bar" : 42 })'), "{42foo42}");
assert identical(exec(r'"{{{baz}foo{bar}}}".format({ "bar" : 42, "baz" : 43 })'), "{43foo42}");







