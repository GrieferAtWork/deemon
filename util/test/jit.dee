#!/usr/bin/deemon
/* Copyright (c) 2019 Griefer@Work                                            *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement in the product documentation would be  *
 *    appreciated but is not required.                                        *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

/* Assert correct evaluation of some basic JIT expressions. */

import deemon;
import * from deemon;

function identical(a, b) {
	return type a === type b
		/* Make sure that the comparison works in every way */
		&& (a == b)
		&& (b == a)
		&& !(a != b)
		&& !(b != a)
		;
}

/* Basic literal / constant parsing. */
assert identical(exec(r'1'),          1);
assert identical(exec(r'1.0'),        1.0);
assert identical(exec(r'"foo"'),      "foo");
assert identical(exec(r"'foo'"),      "foo");
assert identical(exec(r'true'),       true);
assert identical(exec(r'false'),      false);
assert identical(exec(r'none'),       none);

/* Simple arithmetic. */
assert identical(exec(r'10*2 + 11*3'), 53);
assert identical(exec(r'10/2*5'),      25);
assert identical(exec(r'10/(2*5)'),    1);

/* Simple unary instructions */
assert identical(exec(r'str 1'),      "1");
assert identical(exec(r'str 1.0'),    "1.0");
assert identical(exec(r'type true'),  bool);
assert identical(exec(r'type(true)'), bool);
assert identical(exec(r'str(true)'),  "true");

/* Parenthesis vs. tuples, as well as expand-Sequence casting. */
assert identical(exec(r'(1)'),          1);
assert identical(exec(r'(1,)'),         Tuple { 1 });
assert identical(exec(r'(1, 2)'),       Tuple { 1, 2 });
assert identical(exec(r'()'),           Tuple { });
assert identical(exec(r'([]...)'),      Tuple { });
assert identical(exec(r'([]...,)'),     Tuple { });
assert identical(exec(r'([1]...)'),     Tuple { 1 });
assert identical(exec(r'([1]...,)'),    Tuple { 1 });
assert identical(exec(r'([1, 2]...)'),  Tuple { 1, 2 });
assert identical(exec(r'([1, 2]...,)'), Tuple { 1, 2 });
assert identical(exec(r'[]'),           List { });
assert identical(exec(r'[1]'),          List { 1 });
assert identical(exec(r'[1,]'),         List { 1 });
assert identical(exec(r'[1, 2]'),       List { 1, 2 });
assert identical(exec(r'[()...]'),      List { });
assert identical(exec(r'[()...,]'),     List { });
assert identical(exec(r'[(1,)...]'),    List { 1 });
assert identical(exec(r'[(1,)...,]'),   List { 1 });
assert identical(exec(r'[(1, 2)...]'),  List { 1, 2 });
assert identical(exec(r'[(1, 2)...,]'), List { 1, 2 });
assert identical(exec(r'(Tuple from deemon)([:5])'), Tuple { 0, 1, 2, 3, 4 });
assert identical(exec(r'Tuple from deemon([:5])'), Tuple { 0, 1, 2, 3, 4 });

/* Range expressions. */
assert identical(exec(r'[:20]'),      Sequence.range(0, 20));
assert identical(exec(r'[:20, 2]'),   Sequence.range(0, 20, 2));
assert identical(exec(r'[10:20]'),    Sequence.range(10, 20));
assert identical(exec(r'[10:20, 2]'), Sequence.range(10, 20, 2));

/* Attribute lookup. */
assert identical(exec(r'(string from deemon).center'), string.center);

/* The builtin import() function. */
assert exec(r'import("deemon")') === deemon;

/* Bound expressions. */
assert identical(exec(r'"foo".find is bound'), true);
assert identical(exec(r'"foo".nonexisting_symbols is bound'), false);
assert identical(exec(r'"foo".find !is bound'), false);
assert identical(exec(r'"foo".nonexisting_symbols !is bound'), true);
assert identical(exec(r'"foo".find !!is bound'), true);
assert identical(exec(r'"foo".nonexisting_symbols !!is bound'), false);
assert identical(exec(r'bound("foo".find)'), true);
assert identical(exec(r'bound("foo".nonexisting_symbols)'), false);

assert identical(exec(r'[10, 20, "foo", false, none]'), [10, 20, "foo", false, none]);
assert identical(#exec(r'[10, 20, "foo", false, none]'), #[10, 20, "foo", false, none]);
//assert exec(r'{ 10, 20, "foo", false, none }') == { 10, 20, "foo", false, none };
//{
//	local map = exec(r'{ 10: 20, 20: 30, "foo": "bar" }');
//	assert #map == 3;
//	assert identical(map.get(10), 20);
//	assert identical(map.get(20), 30);
//	assert identical(map.get("foo"), "bar");
//	assert identical(map[10], 20);
//	assert identical(map[20], 30);
//	assert identical(map["foo"], "bar");
//}


/* Conditional execution containing an errorous dead branch. */
assert identical(exec(r'true ? "ok" : "foo".bar.baz.bim'), "ok");

{
	local glob = Dict {
		"x" : "foo",
		"y" : 20,
	};
	exec(r'result = x.center(y - 5)', globals: glob);
	assert identical(glob["result"], "foo".center(15));
}


/* Test simple lambda expressions */
{
	local lmb = exec(r'[](x) -> x.startswith("foo")');
	local items = ["foz", "foo", "bar", "foobar"];
	items.removeif(lmb);
	assert items == ["foz", "bar"];
}
/* Also re-try the test with a block-lambda */
{
	local lmb = exec(r'[](x) { return x.startswith("foo"); }');
	local items = ["foz", "foo", "bar", "foobar"];
	items.removeif(lmb);
	assert items == ["foz", "bar"];
}

{
	local glob = Dict();
	/* Execute a piece of code to define some globals,
	 * as well as create and return a JIT function. */
	local x = exec(r'
		bar = "foobar";
		function foo(x?, y = 3) {
			if (x !is bound)
				return bar;
			return x + y;
		}
	', globals: glob);

	/* Ensure that globals were created correctly */
	assert glob["bar"] == "foobar";
	assert glob["foo"] === x;

	/* Ensure that invocations of the function behave properly */
	assert x() === glob["bar"];
	assert x(10) == 13;
	assert x(10, 20) == 30;

	/* Ensure that the correct meta-data is available for the function */
	assert x.__name__ == "foo";
	assert x.__kwds__ == { "x", "y" };
	assert x.__argc_min__ == 0;
	assert x.__argc_max__ == 2;
	assert x.__globals__ === glob;
}










