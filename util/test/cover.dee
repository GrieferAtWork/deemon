#!/usr/bin/deemon
/* Copyright (c) 2018 Griefer@Work                                            *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement in the product documentation would be  *
 *    appreciated but is not required.                                        *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

import * from deemon;
import * from errors;
import * from collections;

assert((try (assert(false),) catch (AssertionError) "here") == "here");

{
	class Foo {
		func() {
			return this.id();
		}
	}
	function func2(x) {
		return x.id();
	}
	local x = Foo();
	assert x.id() == x.func();
	assert x.id() == Foo.func(x);
	assert x.id() == Foo.func.__thiscall__(x);
	assert x.id() == Foo.func.__thiscall__(x,());
	assert x.id() == func2(x);
	assert x.id() == func2(x: x);
	assert x.id() == func2.__thiscall__(x);
	assert x.id() == func2.__thiscall__(x,());
}

{
	function kw0(**kwds) -> kwds;
	function kw1(x,**kwds) -> kwds;
	function kw2(x,y,**kwds) -> kwds;
	function kw3(x,y,z,**kwds) -> kwds;
	/* Assert allowed invocations */
	assert (try kw0() catch (TypeError) "nope") == {};
	assert (try kw0(10) catch (TypeError) "nope") == "nope";
	assert (try kw0(10,20) catch (TypeError) "nope") == "nope";
	assert (try kw0(10,20,30) catch (TypeError) "nope") == "nope";
	assert (try kw1() catch (TypeError) "nope") == "nope";
	assert (try kw1(10) catch (TypeError) "nope") == {};
	assert (try kw1(10,20) catch (TypeError) "nope") == "nope";
	assert (try kw1(10,20,30) catch (TypeError) "nope") == "nope";
	assert (try kw2() catch (TypeError) "nope") == "nope";
	assert (try kw2(10) catch (TypeError) "nope") == "nope";
	assert (try kw2(10,20) catch (TypeError) "nope") == {};
	assert (try kw2(10,20,30) catch (TypeError) "nope") == "nope";
	assert (try kw3() catch (TypeError) "nope") == "nope";
	assert (try kw3(10) catch (TypeError) "nope") == "nope";
	assert (try kw3(10,20) catch (TypeError) "nope") == "nope";
	assert (try kw3(10,20,30) catch (TypeError) "nope") == {};
	/* Assert keyword blacklisting */
	assert !(kw0(x: 0, y: 1, z: 2, foo: 10) != { "x" : 0, "y" : 1, "z" : 2, "foo" : 10 });
	assert kw0(x: 0, y: 1, z: 2, foo: 10) == { "x" : 0, "y" : 1, "z" : 2, "foo" : 10 };
	assert kw1(x: 0, y: 1, z: 2, foo: 10) == { "y" : 1, "z" : 2, "foo" : 10 };
	assert kw2(x: 0, y: 1, z: 2, foo: 10) == { "z" : 2, "foo" : 10 };
	assert kw3(x: 0, y: 1, z: 2, foo: 10) == { "foo" : 10 };
	assert kw0(**{ "x": 0, "y": 1, "z": 2, "foo": 10 }) == { "x" : 0, "y" : 1, "z" : 2, "foo" : 10 };
	assert kw1(**{ "x": 0, "y": 1, "z": 2, "foo": 10 }) == { "y" : 1, "z" : 2, "foo" : 10 };
	assert kw2(**{ "x": 0, "y": 1, "z": 2, "foo": 10 }) == { "z" : 2, "foo" : 10 };
	assert kw3(**{ "x": 0, "y": 1, "z": 2, "foo": 10 }) == { "foo" : 10 };
}

{
	local x = dict {
		"foo" : "bar",
		11 : 22
	};
	local map_reprs = {
		'{ "foo": "bar", 11: 22 }',
		'{ 11: 22, "foo": "bar" }',
	};
	local seq_reprs = {
		'{ ["foo", "bar"], [11, 22] }',
		'{ [11, 22], ["foo", "bar"] }',
		'{ ("foo", "bar"), (11, 22) }',
		'{ (11, 22), ("foo", "bar") }',
		'{ { "foo", "bar" }, { 11, 22 } }',
		'{ { 11, 22 }, { "foo", "bar" } }',
		'(["foo", "bar"], [11, 22])',
		'([11, 22], ["foo", "bar"])',
		'(("foo", "bar"), (11, 22))',
		'((11, 22), ("foo", "bar"))',
		'({ "foo", "bar" }, { 11, 22 })',
		'({ 11, 22 }, { "foo", "bar" })',
		'[["foo", "bar"], [11, 22]]',
		'[[11, 22], ["foo", "bar"]]',
		'[("foo", "bar"), (11, 22)]',
		'[(11, 22), ("foo", "bar")]',
		'[{ "foo", "bar" }, { 11, 22 }]',
		'[{ 11, 22 }, { "foo", "bar" }]',
	};
	local key_reprs = {
		'{ "foo", 11 }',
		'{ 11, "foo" }',
		'("foo", 11)',
		'(11, "foo")',
		'["foo", 11]',
		'[11, "foo"]',
	};
	local value_reprs = {
		'{ "bar", 22 }',
		'{ 22, "bar" }',
		'("bar", 22)',
		'(22, "bar")',
		'["bar", 22]',
		'[22, "bar"]',
	};
	function check_mapping(x) {
		assert repr(x) in map_reprs;
		assert repr(x as mapping) in map_reprs;
		assert repr(x as sequence) in seq_reprs;
		assert repr(x.items) in seq_reprs;
		assert repr(x.items as sequence) in seq_reprs;
		assert repr(x.keys) in key_reprs;
		assert repr(x.keys as sequence) in key_reprs;
		assert repr(x.values) in value_reprs;
		assert repr(x.values as sequence) in value_reprs;
		assert x.keys is x.class.keys;
		assert x.values is x.class.values;
		assert x.items is x.class.items;
		assert x.keys.operator iter() is x.class.keys.iterator;
		assert x.values.operator iter() is x.class.values.iterator;
		assert x.items.operator iter() is x.class.items.iterator;
		assert x.get("foo") == "bar";
		assert x.get(11) == 22;
		assert x.get("MISSING") === none;
		assert x.get("MISSING",true) === true;
		assert x.get("MISSING",false) === false;
	}
	function check_iterators(x) {
		str(x);
		repr(x);
		assert x is sequence;
		local a = x.operator iter();
		assert a is iterator, "" + type(a);
		local b = x.operator iter();
		assert a !== b;
		assert a == b;
		assert !(a != b);
		assert !(a > b);
		assert !(a < b);
		assert a >= b;
		assert a <= b;
		if (x) {
			assert a;
			assert copy a;
			b.operator next();
			assert !(a == b);
			assert a != b;
			assert !(a > b), "" + type(a) + " -- " + type(b);
			assert !(a >= b);
			assert a < b;
			assert a <= b;
		}
	}
	function check_iterators_cast(x) {
		check_iterators(x);
		check_iterators(tuple(x));
		check_iterators(list(x));
		check_iterators(list(x).frozen);
		check_iterators(hashset(x));
		check_iterators(hashset(x).frozen);
		check_iterators(Deque(x));
		check_iterators(Deque(x).frozen);
		check_iterators(FixedList(x));
		check_iterators(FixedList(x).frozen);
	}
	function check_generic_sequence(x) {
		check_iterators(x);
	}
	function check_generic_set(x) {
		check_iterators(x);
	}
	local split_markers = {
		"",
		"|",
		",",
		"A",
		"b",
		"oo",
		"{}",
		"}{",
		"a8rochrb",
	};
	local builtin_codecs = {
		"ascii",
		"backslash-escape",
		"latin-1",
		"utf-8",
	};
	function check_string(x) {
		check_iterators(x);
		for (local s: split_markers) {
			check_generic_sequence(x.split(s));
			check_generic_sequence(x.casesplit(s));
			check_generic_sequence(x.findall(s));
			check_generic_sequence(x.casefindall(s));
		}
		check_generic_sequence(x.scanf("%s"));
		check_generic_sequence(x.scanf(" %s"));
		for (local r: [1:8])
			check_generic_sequence(x.segments(r));
		check_generic_sequence(x.splitlines(true));
		check_generic_sequence(x.splitlines(false));
		if (x is string) {
			for (local pattern: [
				r"\|",
				r"assert?",
			]) {
				check_generic_sequence(x.refindall(pattern));
				check_generic_sequence(x.relocateall(pattern));
				check_generic_sequence(x.resplit(pattern));
			}
		}
	}

	assert x is dict;
	assert x.frozen is dict.frozen;
	assert type(x) == dict;
	assert type(x.frozen) == dict.frozen;
	check_mapping(x);
	check_mapping(x as mapping);
	check_mapping(x.frozen);
	check_mapping((x as mapping).frozen);

	check_iterators_cast(x);
	check_iterators_cast(x.keys);
	check_iterators_cast(x.values);
	check_iterators_cast(x.items);
	check_iterators_cast(x.frozen);
	check_iterators_cast(x.frozen.keys);
	check_iterators_cast(x.frozen.values);
	check_iterators_cast(x.frozen.items);
	check_iterators_cast((x as mapping).frozen);
	check_iterators_cast((x as mapping).frozen.keys);
	check_iterators_cast((x as mapping).frozen.values);
	check_iterators_cast((x as mapping).frozen.items);
	local strings = {
		"",
		"123",
		"foobar",
		"barfoo",
		"1234567890",
		"a8rochrb sq3duw9owx vsozqogcoabap295 azq",
		"a8rochrb sq3duw9owx vsozqogcoabap295 azq"
		"a8rochrb sq3duw9owx vsozqogcoabap295 azq"
		"a8rochrb sq3duw9owx vsozqogcoabap295 azq"
		"a8rochrb sq3duw9owx vsozqogcoabap295 azq"
		"a8rochrb sq3duw9owx vsozqogcoabap295 azq",
		"AbCCAUssdagOASFDAFhlhASTOHAfhfdhasufdh&&&A/",
		string(file.open(__FILE__).read().decode("ascii"))
	};

	for (local s: strings) {
		for (local c: builtin_codecs) {
			local enc = s.encode(c);
			check_string(enc);
			assert enc.decode(c) == s;
		}
		check_string(s);
		check_string(s.bytes());
		check_generic_sequence(s.ordinals);
		check_generic_sequence(s as sequence);
		check_generic_sequence(s.bytes() as sequence);
		check_generic_sequence(s.ordinals as sequence);
		local character_tuple = tuple(s);
		local bytes_tuple = tuple(s.bytes());
		local ord_tuple = tuple(s.ordinals);
		check_generic_sequence(character_tuple);
		check_generic_sequence(character_tuple as sequence);
		check_generic_sequence(bytes_tuple);
		check_generic_sequence(bytes_tuple as sequence);
		check_generic_sequence(ord_tuple);
		check_generic_sequence(ord_tuple as sequence);
		check_generic_sequence(list(character_tuple));
		check_generic_sequence(list(character_tuple) as sequence);
		check_generic_sequence(list(bytes_tuple));
		check_generic_sequence(list(bytes_tuple) as sequence);
		check_generic_sequence(list(ord_tuple));
		check_generic_sequence(list(ord_tuple) as sequence);
		check_generic_set(hashset(character_tuple));
//		check_generic_set(hashset(character_tuple) as set);
		check_generic_set(hashset(bytes_tuple));
//		check_generic_set(hashset(bytes_tuple) as set);
		check_generic_set(hashset(ord_tuple));
//		check_generic_set(hashset(ord_tuple) as set);
		check_generic_sequence(Deque(character_tuple));
		check_generic_sequence(Deque(character_tuple) as sequence);
		check_generic_sequence(Deque(bytes_tuple));
		check_generic_sequence(Deque(bytes_tuple) as sequence);
		check_generic_sequence(Deque(ord_tuple));
		check_generic_sequence(Deque(ord_tuple) as sequence);
		check_generic_sequence(FixedList(character_tuple));
		check_generic_sequence(FixedList(character_tuple) as sequence);
		check_generic_sequence(FixedList(bytes_tuple));
		check_generic_sequence(FixedList(bytes_tuple) as sequence);
		check_generic_sequence(FixedList(ord_tuple));
		check_generic_sequence(FixedList(ord_tuple) as sequence);
	}
	local mb_strings = {
		"\u1234",
		"\u1234\u4321",
		"\U12345678",
		"\U12345678\U87654321",
	};

	for (local s: mb_strings) {
		for (local c: builtin_codecs) {
			if (c in ["ascii","latin-1"])
				continue;
			local enc = s.encode(c);
			check_string(enc);
			assert enc.decode(c) == s;
		}
		check_string(s);
		check_generic_sequence(s.ordinals);
		check_generic_sequence(s as sequence);
		check_generic_sequence(s.ordinals as sequence);
		local character_tuple = tuple(s);
		local ord_tuple = tuple(s.ordinals);
		check_generic_sequence(character_tuple);
		check_generic_sequence(character_tuple as sequence);
		check_generic_sequence(ord_tuple);
		check_generic_sequence(ord_tuple as sequence);
		check_generic_sequence(list(character_tuple));
		check_generic_sequence(list(character_tuple) as sequence);
		check_generic_sequence(list(ord_tuple));
		check_generic_sequence(list(ord_tuple) as sequence);
		check_generic_set(hashset(character_tuple));
//		check_generic_set(hashset(character_tuple) as set);
		check_generic_set(hashset(ord_tuple));
//		check_generic_set(hashset(ord_tuple) as set);
		check_generic_sequence(Deque(character_tuple));
		check_generic_sequence(Deque(character_tuple) as sequence);
		check_generic_sequence(Deque(ord_tuple));
		check_generic_sequence(Deque(ord_tuple) as sequence);
		check_generic_sequence(FixedList(character_tuple));
		check_generic_sequence(FixedList(character_tuple) as sequence);
		check_generic_sequence(FixedList(ord_tuple));
		check_generic_sequence(FixedList(ord_tuple) as sequence);
	}
	
}













