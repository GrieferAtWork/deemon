#!/usr/bin/deemon
/* Copyright (c) 2018-2026 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2018-2026 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */
import deemon, rt;
import * from deemon;
import * from errors;

#define TRY(x) (try x catch (e...) e)

@@Set of types know to be only ==/!= comparable, but not </<=/>/>= comparable
final local CANNOT_COMPARE = Set.frozen({
	Type,
	Module,
	Function,
});

function safeRepr(x: Object): string {
	try {
		return repr x;
	} catch (NotImplemented) {
		return f"<{Object.id(x)}@{type x}>";
	}
}

function canCompare(expected: Object, actual: Object): bool {
	local Texpected = type expected;
	local Tactual = type actual;
	if (Texpected in CANNOT_COMPARE || Tactual in CANNOT_COMPARE)
		return false;
	if (Texpected is Callable || Tactual is Callable)
		return false;
	if (Texpected is Set || Tactual is Set)
		return false;
	if (Texpected.extends(Sequence) && Tactual.extends(Sequence)) {
		if (Texpected == string || Tactual == string)
			return Texpected === Tactual;
		local common = { #expected, #actual } < ...;
		for (local i: [:common]) {
			if (!canCompare(expected[i], actual[i]))
				return false;
		}
		return true;
	}
	if (Texpected !== Tactual)
		return false;
	return true;
}

function concatMessage(base: string, message: Callable | string | none = none): string {
	if (message is Callable && message !is Type)
		message = message();
	if (message is none)
		return base;
	assert message is string;
	return f"{base}: {message}";
}

function assertEquals(expected: Object, actual: Object,
                      message: Callable | string | none = none,
                      compare: bool | none = none) {
	assert deemon.equals(expected, actual), message;
	assert expected == actual, message;
	assert actual == expected, message;
	assert !(expected != actual), concatMessage(f"!({safeRepr(expected)} != {safeRepr(actual)})", message);
	assert !(actual != expected), concatMessage(f"!({safeRepr(actual)} != {safeRepr(expected)})", message);
	if (compare ?? canCompare(expected, actual)) {
		assert !(expected < actual), concatMessage(f"!({safeRepr(expected)} < {safeRepr(actual)})", message);
		assert !(actual < expected), concatMessage(f"!({safeRepr(actual)} < {safeRepr(expected)})", message);
		assert expected <= actual, message;
		assert actual <= expected, message;
		assert !(expected > actual), concatMessage(f"!({safeRepr(expected)} > {safeRepr(actual)})", message);
		assert !(actual > expected), concatMessage(f"!({safeRepr(actual)} > {safeRepr(expected)})", message);
		assert expected >= actual, message;
		assert actual >= expected, message;
		assert deemon.compare(expected, actual) == 0, message;
	}
}

function assertSame(expected: Object, actual: Object,
                    message: Callable | string | none = none) {
	assert expected === actual, message;
}

@@Same as @assertEquals, but also assert identical typing
function assertEqualsTyped(expected: Object, actual: Object,
                           message: Callable | string | none = none,
                           compare: bool | none = none) {
	assertEquals(expected, actual, message, compare);
	assert type(expected) == type(actual), f"type({safeRepr(expected)}) == type({safeRepr(actual)})";
}

function assertNotEquals(unexpected: Object, actual: Object,
                         message: Callable | string | none = none,
                         compare: bool | none = none) {
	assert !deemon.equals(unexpected, actual),
		concatMessage(f"!deemon.equals({safeRepr(unexpected)}, {safeRepr(actual)})", message);
	assert unexpected != actual, message;
	assert actual != unexpected, message;
	assert !(unexpected == actual), concatMessage(f"!({safeRepr(unexpected)} == {safeRepr(actual)})", message);
	assert !(actual == unexpected), concatMessage(f"!({safeRepr(actual)} == {safeRepr(unexpected)})", message);
	if (compare ?? canCompare(unexpected, actual)) {
		assert !(unexpected <= actual), concatMessage(f"!({safeRepr(unexpected)} <= {safeRepr(actual)})", message);
		assert !(actual <= unexpected), concatMessage(f"!({safeRepr(actual)} <= {safeRepr(unexpected)})", message);
		assert !(unexpected >= actual), concatMessage(f"!({safeRepr(unexpected)} >= {safeRepr(actual)})", message);
		assert !(actual >= unexpected), concatMessage(f"!({safeRepr(actual)} >= {safeRepr(unexpected)})", message);
		assert actual < unexpected || actual > unexpected, concatMessage(f"!({safeRepr(actual)} <||> {safeRepr(unexpected)})", message);
		assert unexpected < actual || unexpected > actual, concatMessage(f"!({safeRepr(unexpected)} <||> {safeRepr(actual)})", message);
		assert deemon.compare(unexpected, actual) != 0, message;
	}
}

function assertNotEqualsTyped(unexpected: Object, actual: Object,
                              message: Callable | string | none = none,
                              compare: bool | none = none) {
	if (type(unexpected) == type(actual))
		assertNotEquals(unexpected, actual, message, compare);
}


function assertAttributes(ob: Object, attributes: {string: Object}, typ: Type | none = none) {
	if (typ !is none)
		assert ob is typ;
	for (local name, expected: attributes) {
		local actual = ob.operator . (name);
		assertEquals(expected, actual, () -> f"assertAttributes({
			safeRepr(ob)}, \{ ..., {safeRepr(name)}: {safeRepr(expected)} \})");
	}
}

function _assertIteratorConstructor(iterType: Type, x: Sequence) {
	/* The construct-from-sequence feature isn't actually mandatory for
	 * iterators. As such, don't assert it working for certain types. */
	if (iterType !in {
		rt.IterWithNextValue,
		rt.IterWithNextKey,
		rt.IterWithNextAndUnpackFilter,
		rt.IterWithNextAndCounterAndLimitPair,
		rt.IterWithNextAndCounterPair,
		rt.IterWithIterKeysAndTryGetItemForMap,
		rt.IterWithIterKeysAndGetItemForMap,
		rt.IterWithNextAndLimit,
	}) {
		if (type(x) === Super)
			x = Super.selfof(x);
		local altIter = iterType(x);
		assertEquals(x.operator iter(), altIter);
		assert TRY(iterType(Object())) is Error,
			"When called with something weird, an error should be thrown. "
			"Usually, that would be a TypeError, but generic iterators may "
			"also throw other errors (like NotImplemented)";
	}

	/* The the sake of coverage, also invoke the no-args constructor (if defined) */
	if (iterType.__isnoargconstructible__)
		iterType();
}


@@Assert that @x is a generic sequence in every way, shape, and form
function assertSequence(x: Sequence, expected: {Object...} | none = none) {
	assert x is Sequence;
	assert x !is Set;
	assert x !is Mapping;
	assert x.class.__seqclass__ === Sequence;
	local len = #x;
	if (expected !is none) {
		assertEquals(expected, x);
		assert #expected == len;
		for (local i, v: expected.enumerate()) {
			assertEquals(v, x[i], () -> f"{safeRepr(v)} == {safeRepr(x)}[{safeRepr(i)}]");
		}
	}
	assertEqualsTyped(x, x);
	if (type(x) !== Super) {
		/* FIXME: See "assertSet" */
		assertEqualsTyped(x, copy x);
		assertEqualsTyped(x, deepcopy x);
	}

	local ItemType = try x.class.ItemType catch (...) Object;
	if (ItemType !== Object) {
		for (local it: x)
			assert it is ItemType, type x;
	}

	assert x.length == len;
	local err = TRY(x[len]);
	assertAttributes(err, {
		/* Special case: when "x" is Super, then the "seq" of an IndexError
		 * can be either the Super wrapper, or the self-object being wrapped
		 * (with either being allowed)
		 *
		 * For most types, `x == (x as Sequence)' works as you would expect,
		 * however there is a special case where it doesn't when `x is string',
		 * since "string" (intentionally) doesn't implement `operator == (Sequence)',
		 * since doing so would mean `"foo" == { "f", "o", "o" }', which doesn't
		 * feel right to me...
		 *
		 * Note however that `{ "f", "o", "o" } == "foo"' **does** work (and
		 * correctly returns "true"), but that is because here the Sequence
		 * is in charge of implementing `operator ==', which it does in the
		 * most generic way possible.
		 *
		 * Additionally, `("foo" as Sequence) == { "f", "o", "o" }' also works,
		 * since in this case Sequence is (once again) in charge of implementing
		 * `operator =='.
		 */
		"seq": (type(x) === Super && err is IndexError &&
		        err.seq is bound && type(err.seq) !== Super)
			? Super.selfof(x)
			: x,
		"index": len,
		"length": len,
	}, IndexError);
	if (len) {
		assert x;
		local iterated1 = List(x);
		local iterated2 = Tuple(x);
		local iterated3 = [];
		local iterated4 = [];
		local iterated5 = [];
		local iterated6 = x.cached;
		local iterated7 = x.frozen;
		iterated3.extend(x);
		for (local it: x)
			iterated4.append(it);
		local numUnboundItems = 0;
		for (local i: [:len]) {
			local v;
			try {
				v = x[i];
			} catch (UnboundItem) {
				++numUnboundItems;
				continue;
			}
			iterated5.append(v);
		}
		assert #iterated1 == (len - numUnboundItems);
		if (numUnboundItems) {
			assertEquals(iterated1, iterated2);
			assertEquals(iterated1, iterated3);
			assertEquals(iterated1, iterated4);
			assertEquals(iterated1, iterated5);
		} else {
			assertEquals(x, iterated1);
			assertEquals(x, iterated2);
			assertEquals(x, iterated3);
			assertEquals(x, iterated4);
			assertEquals(x, iterated5);
			assertEquals(x, iterated6); // TODO: Doesn't work with unbound items, yet...
		}
		assertEquals(x, iterated7);

		local first = Cell();
		try {
			first.value = x[0];
		} catch (UnboundItem) {
		}
		if (first) {
			assertEquals(first.value, x.first);
			assertEquals(first.value, Sequence.first(x));
			assertEquals(x.find(first.value), 0);
			assertEquals(x.index(first.value), 0);
		} else {
			assert TRY(x.first) == UnboundAttribute(ob: x, attr: "first");
			assert TRY(Sequence.first(x)) == UnboundAttribute(ob: x, attr: "first");
		}

		local last = Cell();
		try {
			last.value = x[len - 1];
		} catch (UnboundItem) {
		}
		if (last) {
			assertEquals(last.value, x.last);
			assertEquals(last.value, Sequence.last(x));
			assertEquals(x.rfind(last.value), len - 1);
			assertEquals(x.rindex(last.value), len - 1);
		} else {
			assert TRY(x.last) == UnboundAttribute(ob: x, attr: "last");
			assert TRY(Sequence.last(x)) == UnboundAttribute(ob: x, attr: "last");
		}

		local it = x.operator iter();
		if (iterated1) {
			assert it;
		} else {
			assert !it;
		}
		local it2 = x.operator iter();
		assertSame(type(it), type(it2));
		assertEqualsTyped(it, it2);
		if (iterated1) {
			local it2First = it2.operator next();
			if (first)
				assertEquals(first.value, it2First);
		}
		it.operator hash();  /* Only here for coverage */
		it2.operator hash(); /* Only here for coverage */
		local itSeq = TRY(it.seq);
		if (itSeq !is AttributeError) {
			/* This here is needed because "Dict.items.operator iter().seq"
			 * returns "Dict" instead of "Dict.Items" (since the 2 share the
			 * same iterator type for the sake of simplicity) */
			if (type(x) === Super)
				itSeq = itSeq as Super.typeof(x);
			assertEquals(x, itSeq);
		}

		if (iterated1) {
			assert it2 > it, type it;
			assert it < it2, type it;
			assert compare(it2, it) > 0, type it;
			assert compare(it, it2) < 0, type it;
		}

		for (local i, v: iterated7.enumerate()) {
			assert it;
			assertEquals(v, it.operator next());
			assertEquals(v, x[i]);
		}
		assert !it, type it;

		local it = x.operator iter();
		for (local i, v: x.enumerate()) {
			assert it;
			assertEquals(v, it.operator next());
			assertEquals(v, iterated7[i]);
		}
		assert !it;

		for (local it: iterated1)
			assert it in x;

		_assertIteratorConstructor(type it, x);

		/* Assert that deepcopy works on iterators */

		/* Deepcopy while nothing has been enumerated, yet */
		local it = x.operator iter();
		local it2 = deepcopy it;
		if (iterated2) {
			for (local v: iterated2) {
				assert it2;
				assertEquals(v, it2.operator next());
			}
			assert !it2, type it2;
			for (local v: iterated2) {
				assert it;
				assertEquals(v, it.operator next());
			}
			assert !it, type it;
			assert (try ({ it.operator next(); none; }) catch (e...) e) == rt.StopIteration_instance;
			assert (try ({ it2.operator next(); none; }) catch (e...) e) == rt.StopIteration_instance;

			/* Deepcopy while nothing has been enumerated, yet */
			local it = x.operator iter();
			assertEquals(iterated2.first, it.operator next());
			local it2 = deepcopy it;
			local withoutFirst = iterated2[1:];
			for (local v: withoutFirst) {
				assert it2;
				assertEquals(v, it2.operator next());
			}
			assert !it2, type it2;
			for (local v: withoutFirst) {
				assert it;
				assertEquals(v, it.operator next());
			}
			assert !it, type it;
			assert (try ({ it.operator next(); none; }) catch (e...) e) == rt.StopIteration_instance;
			assert (try ({ it2.operator next(); none; }) catch (e...) e) == rt.StopIteration_instance;
		} else {
			assert !it, repr it;
			assert !it2;
			assert (try ({ it.operator next(); none; }) catch (e...) e) == rt.StopIteration_instance;
			assert (try ({ it2.operator next(); none; }) catch (e...) e) == rt.StopIteration_instance;
		}
	} else {
		assert !x;

		local it = x.operator iter();
		assert !it;
		assert TRY(it.operator next()) == StopIteration();

		assert none !in x;
	}
}


function assertSet(x: Set, expected: {Object...} | none = none) {
	assert x is Sequence;
	assert x is Set;
	assert x !is Mapping;
	assert x.class.__seqclass__ === Set;
	local len = #x;
	assert len is int;
	if (expected !is none) {
		assertEquals(expected, x);
		assert #expected == len;
		for (local k: expected)
			assert k in x;
		for (local k: x)
			assert k in expected;
	}
	assertEqualsTyped(x, x);
	if (type(x) !== Super) {
		/* FIXME: "copy(x as Set)" doesn't work as expected (it just returns "Set()")
		 *        Expected behavior would be alias for "Set.frozen(x)", but that would
		 *        require a re-write of how copy operators are invoked. (currently,
		 *        only TP_FVARIABLE types are able to allocate objects with custom
		 *        typing to-be returned by "copy", but "Set" cannot be made variable)
		 * Solution: all types should provide "tp_var" constructors, with types that
		 *           don't explicitly define them being given default impls (similar
		 *           to what was done with "tp_destroy") */
		assertEqualsTyped(x, copy x);
		assertEqualsTyped(x, deepcopy x);
	}

	local ItemType = try x.class.ItemType catch (...) Object;
	if (ItemType !== Object) {
		for (local it: x)
			assert it is ItemType, type x;
	}

	assert x.length == len;
	if (len) {
		assert x;
		local iterated1 = List(x);
		local iterated2 = Tuple(x);
		local iterated3 = [];
		local iterated4 = [];
		local iterated5 = HashSet(x);
		local iterated6 = HashSet.Frozen(x);
		local iterated7 = x.frozen;
//		local iterated8 = x.cached; // TODO
		assert iterated7 is Set;
//		assert iterated8 is Set; // TODO
		iterated3.extend(x);
		for (local it: x)
			iterated4.append(it);
		assertEquals(x, iterated1);
		assertEquals(x, iterated2);
		assertEquals(x, iterated3);
		assertEquals(x, iterated4);
		assertEquals(x, iterated5);
		assertEquals(x, iterated6);
		assertEquals(x, iterated7);
//		assertEquals(x, iterated8); // TODO

		local first = x.first;
		assert first in x;
		assert x.last in x;

		local it = x.operator iter();
		assert it;
		local it2 = x.operator iter();
		assertEqualsTyped(it, it2);
		assertEquals(first, it2.operator next());
		it.operator hash(); /* Only here for coverage */
		local itSeq = it.seq;
		/* This here is needed because "Dict.items.operator iter().seq"
		 * returns "Dict" instead of "Dict.Items" (since the 2 share the
		 * same iterator type for the sake of simplicity) */
		if (type(x) === Super)
			itSeq = itSeq as Super.typeof(x);
		assertEquals(x, itSeq);
		assert it2 > it;
		assert it < it2;
		assert compare(it2, it) > 0;
		assert compare(it, it2) < 0;

		for (local v: iterated1) {
			assert it;
			assertEquals(v, it.operator next());
		}
		assert !it, type it;

		for (local it: iterated1)
			assert it in x;
		_assertIteratorConstructor(type it, x);
	} else {
		assert !x;

		local it = x.operator iter();
		assert !it;
		assert TRY(it.operator next()) == StopIteration();

		assert none !in x;
	}
}

function assertMapping(x: Mapping, expected: {Object: Object} | none = none) {
	assert x is Sequence;
	assert x !is Set;
	assert x is Mapping;
	assert x.class.__seqclass__ === Mapping;
	local len = #x;
	if (expected !is none) {
		assertEquals(expected, x);
		/* May be less if "x" contains unbound items, in
		 * which case mappings may still compare equal. */
		assert #expected <= len;
		for (local key, value: expected)
			assertEquals(value, x[key], () -> f"{safeRepr(value)} == {safeRepr(x)}[{safeRepr(key)}]");
		for (local key, value: x)
			assertEquals(expected[key], value, () -> f"{safeRepr(expected)}[{safeRepr(key)}] == {safeRepr(value)}");
	}
	assertEqualsTyped(x, x);
	if (type(x) !== Super) {
		/* FIXME: See "assertSet" */
		assertEqualsTyped(x, copy x);
		assertEqualsTyped(x, deepcopy x);
	}

	assert x.length == len;
	local badKey = -4405742047502975340;
	assert badKey !in x;
	assertAttributes(TRY(x[badKey]), {
		"seq": x,
		"key": badKey,
	}, UnknownKey);
	assert len is int;

	local keys = x.keys;
	local values = x.values;
	local items = x.items;
	assert len == #keys;
	assert len == #values;

	/* "items" does not include unbound items, so may be smaller */
	assert len >= #items;
	assert #(x as Set) == #items;
	if (expected !is none) {
		assert #expected == #items;
		assertSet(items, expected.items);
		if (len == #expected) {
			assertSet(keys, expected.keys);
			assertSequence(values, expected.values);
		} else {
			assertSet(keys);
			assertSequence(values);
		}
	} else {
		assertSet(items);
		assertSet(keys);
		assertSequence(values);
	}

	local KeyType = try x.class.KeyType catch (...) Object;
	if (KeyType !== Object) {
		for (local k: keys)
			assert k is KeyType, type x;
	}

	local ValueType = try x.class.ValueType catch (...) Object;
	if (ValueType !== Object) {
		for (local v: values)
			assert v is ValueType, type x;
	}

	if (len) {
		assert x;
		local iterated1 = Dict(x);
		local iterated2 = Dict.Frozen(x);
		local iterated3 = Dict();
		local iterated4 = Dict();
		local iterated5 = Dict();
		local iterated6 = Dict();
		local iterated7 = Dict();
		local iterated8 = x.frozen;
		iterated3.update(x);
		for (local k, v: x)
			iterated4[k] = v;
		for (local k, v: items)
			iterated5[k] = v;
		for (local pair: x) {
			local k, v = pair...;
			iterated6[k] = v;
		}
		for (local k: x.keys)
			iterated7[k] = x[k];
		assertEquals(x, iterated1);
		assertEquals(x, iterated2);
		assertEquals(x, iterated3);
		assertEquals(x, iterated4);
		assertEquals(x, iterated5);
		assertEquals(x, iterated6);
		assertEquals(x, iterated7);
		assertEquals(x, iterated8);

		for (local i, k: keys.enumerate()) {
			local item = Sequence.__getitem__(items, i);
			local v = x[k];
			assertEquals(v, values[i]);
			assertEquals((k, v), item);
		}

		local it = x.operator iter();
		assert it;
		local it2 = x.operator iter();
		assertEqualsTyped(it, it2);
		assertEquals(x.first, it2.operator next());
		it.operator hash(); /* Only here for coverage */
		local itSeq = it.seq;
		/* This here is needed because "Dict.items.operator iter().seq"
		 * returns "Dict" instead of "Dict.Items" (since the 2 share the
		 * same iterator type for the sake of simplicity) */
		if (type(x) === Super)
			itSeq = itSeq as Super.typeof(x);
		assertEquals(x, itSeq);
		assert it2 > it;
		assert it < it2;
		assert compare(it2, it) > 0;
		assert compare(it, it2) < 0;

		for (local k, v: iterated1) {
			assert it;
			assertEquals((k, v), it.operator next());
		}
		assert !it;

		for (local k, none: iterated1)
			assert k in x;
		_assertIteratorConstructor(type it, x);
	} else {
		assert !x;

		local it = x.operator iter();
		assert !it;
		assert TRY(it.operator next()) == StopIteration();

		assert none !in x;
	}
}

