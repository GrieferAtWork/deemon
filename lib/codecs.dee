/* Copyright (c) 2019 Griefer@Work                                            *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement in the product documentation would be  *
 *    appreciated but is not required.                                        *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

import * from deemon;
import * from errors;
import * from util;

local function unknown_codec(name: string) {
	throw ValueError("Unknown codec {!r}".format({ name }));
}

local function sanitize_codec_name(name: string) {
	/* Make sure it's not detected as a module name. */
	if (("." in name) || !name || (!name.isalnum(0) && name[0] !in ["_"]))
		unknown_codec(name);
	return name;
}


local function encode_unsupported(...) {
	throw ValueError("Cannot use this codec for encoding");
}
local function decode_unsupported(...) {
	throw ValueError("Cannot use this codec for decoding");
}

local class CustomCodec {
	public final member encode: Callable;
	public final member decode: Callable;
	this(encode: Callable = none, decode: Callable = none) {
		this.encode = encode;
		this.decode = decode;
		if (this.encode is none)
			this.encode = encode_unsupported;
		if (this.decode is none)
			this.decode = decode_unsupported;
	}
}

local class CpCodec {
	public final member cp: string;
	public final member cp_len: int;
	public final member cp_rev: {int: string};
	this(cp: string) {
		this.cp = cp;
		this.cp_len = #cp;
	}
	public final function encode(data, errors: string) {
		if (cp_rev !is bound) {
			/* Create a mapping for translating unicode
			 * characters to their encoded ordinals. */
			cp_rev = Dict(
				for (local ord, ch: enumerate(cp.ordinals))
					(ch, string.chr(ord)));
		}
		File.Writer writer;
		for (local ch: data) {
			ch = ch.ord();
			local mapped_ch = cp_rev.get(ch);
			if (mapped_ch is none) {
				switch (errors) {
				default:
					throw UnicodeEncodeError("Cannot encode character {}".format({ ch }));
				case "replace":
					writer << "?";
					continue;
					break;
				case "ignore":
					writer << ch;
					continue;
				}
			}
			writer << mapped_ch;
		}
		local result = writer.string;
		if (cp_len <= 256)
			result = result.bytes();
		return result;
	}
	public final function decode(data, errors: string) {
		/* TODO: Add a builtin function to quickly translate
		 *       strings in a manner such as this one. */
		File.Writer writer;
		if (data is string)
			data = data.ordinals;
		for (local ch: data) {
			if (ch >= cp_len) {
				switch (errors) {
				default:
					throw UnicodeDecodeError("Cannot decode character {}".format({ ch }));
				case "replace":
					writer << "?";
					continue;
					break;
				case "ignore":
					writer << ch;
					continue;
				}
			}
			writer << cp[ch];
		}
		return writer.string;
	}
}


@@Cache of loaded codecs
local loaded_codecs = Dict();

@@Cache of loaded codecs
local user_codecs = Dict();

local function load_codec_module(name) {
	/* Load the codec from a module. */
	local codec_module = import("._codecs." + name);
	if (hasattr(codec_module, "cp"))
		return CpCodec(codec_module.operator . ("cp"));
	if (hasattr(codec_module, "encode")) {
		local encode_function = codec_module.operator . ("encode");
		local decode_function = none;
		if (hasattr(codec_module, "decode"))
			decode_function = codec_module.operator . ("decode");
		return CustomCodec(encode_function, decode_function);
	}
	if (hasattr(codec_module, "decode"))
		return CustomCodec(none, codec_module.operator . ("decode"));
	unknown_codec(name);
}

@@Check for a cached, or load a new codec matching @name
local function get_codec(name) {
	local result;
	result = user_codecs.get(name);
	if (result !is none) return result;
	result = loaded_codecs.get(name);
	if (result !is none) return result;
	try {
		result = load_codec_module(name);
	} catch (FileNotFound) {
		unknown_codec(name);
	}
	local was, old = loaded_codecs.setnew_ex(name, result)...;
	if (!was)
		result = old;
	return result;
}


@@General purpose encode() function that is invoked by the deemon
@@runtime for :string and :Bytes whenever a codec was specified
@@that wasn't recognized.
@@When this function is called, the given @name has already been normalized,
@@but has yet to be sanity-checked to become a valid name for a codec module.
function __encode(data, name: string, errors: string = "strict") {
	local codec = get_codec(sanitize_codec_name(name));
	try {
		return codec.encode(data, errors);
	} catch (AttributeError) {
		if (!hasattr(codec, "encode"))
			decode_unsupported();
		throw;
	}
}

@@Same as #__encode, but for the opposite direction, meaning that this
@@function is called as a general purpose decode() function.
function __decode(data, name: string, errors: string = "strict") {
	local codec = get_codec(sanitize_codec_name(name));
	try {
		return codec.decode(data, errors);
	} catch (AttributeError) {
		if (!hasattr(codec, "decode"))
			decode_unsupported();
		throw;
	}
}

@@Register a given @codec for @name
@@The given @codec can be an arbitrary object, which should implement member functions
@@`encode(data: Object, errors: string)' and `decode(data: Object, errors: string)'
@@If either function is missing, attempting to perform that operation using the codec
@@will cause a :ValueError to be thrown
@@@throw KeyError A codec that is matching the given @name has already been defined
function register(name: string, codec: Object) {
	if (!user_codecs.setnew(name, codec))
		throw KeyError("Codec {!r} has already been defined".format({ name }));
}


@@Normalize (_NOT_ sanitize) a given codec name, the same way the deemon
@@core does when the encode/decode functions of :string or :Bytes are invoked.
local function normalize_codec_name(name: string): string {
	name = name.casefold().replace("_", "-");
	if (name.startswith("iso-"))
		name = "iso"+name[4:];
	else if (name.startswith("cp-")) {
		name = "cp"+name[3:];
	}
	return name;
}


@@Transform @data according to @name
@@Normally, this function doesn't need to be used, as encoded data is usually
@@only encapsulated as :Bytes or :string objects, which provide encode/decode
@@functionality via member functions.
@@However, this function can be used to invoke codecs with arbitrary objects
@@given as input, while also allowing arbitrary objects as output.
@@@throw ValueError The given @name isn't a known codec
@@@param errors One of $"strict", $"ignore" or $"replace"
function decode(data, name: string, errors: string = "strict") {
	if (data is string || data is Bytes)
		return data.decode(name, errors);
	return __decode(data, normalize_codec_name(name), errors);
}

@@Transform @data according to @name
@@Normally, this function doesn't need to be used, as encoded data is usually
@@only encapsulated as :Bytes or :string objects, which provide encode/decode
@@functionality via member functions.
@@However, this function can be used to invoke codecs with arbitrary objects
@@given as input, while also allowing arbitrary objects as output.
@@@throw ValueError The given @name isn't a known codec
@@@param errors One of $"strict", $"ignore" or $"replace"
function encode(data, name: string, errors: string = "strict") {
	if (data is string || data is Bytes)
		return data.encode(name, errors);
	return __encode(data, normalize_codec_name(name), errors);
}
















