/* Copyright (c) 2019 Griefer@Work                                            *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement in the product documentation would be  *
 *    appreciated but is not required.                                        *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

import util;
import deemon;
import * from deemon;

global Declaration;
global Doc;
global DocSection;
global Expression;
global Parameter;
global TextSegment;
global TypeExpr;
global TypeRef;



local function decode_name_content(name: string): string {
	name = name.substr(1,#name - 1);
	name = name.replace("\\\n","\n");
	name = name.replace(r"-\>",r"->");
	for (local x: r"\?!{}|,()<>[]=")
		name = name.replace(r"\" + x,x);
	return name;
}

@@Decode a <NAME>-like documentation name
local function decode_name(name: string): string {
	if (name.startswith("{") && name.endswith("}"))
		return decode_name_content(name);
	return name;
}

@@Encode a <NAME>-like documentation name
local function encode_name(name: string): string {
	local result = name;
	if (!result.issymbol()) {
		for (local x: r"\?!{}|,()<>[]=")
			result = result.replace(x,r"\" + x);
		result = result.replace(r"->",r"-\>");
		result = result.replace("\n","\\\n");
		result = "{{{}}}".format({ result });
	}
	return result;
}

@@Decode the contents of a custom user-text section
local function decode_text(text: string): string {
	text = text.replace("\\\n","\n");
	text = text.replace("\n\\(","\n(");
	text = text.replace(r"-\>",r"->");
	text = text.replace(r"\\",r"\");
	return text;
}

@@Search for a given @ob within the export table of @mod, returning its name or :none if not found
local function lookup_object_in_module(mod: deemon.module,ob): string | none {
	/* Search the export table of this module! */
	for (local name,obj: deemon.module.__exports__(mod)) {
		if (obj === ob)
			return name;
	}
	return none;
}

@@Try to determine the declaring module of a given type and return
@@a string in the form of $"?E<MODULE>:<NAME>" if this applies.
@@Otherwise, when the module could not be determined, return a
@@string in the form of $"?U<NAME>"
local function encode_type(tp: deemon.type_): string {
	if (tp === deemon.object)
		return "?O";
	local mod = deemon.type_.__module__(tp);
	if (mod is none) /* Module could not be determined */
		return "?U" + encode_name(tp.__name__);
	local name = lookup_object_in_module(mod,tp);
	if (name is none)
		name = deemon.type_.__name__(tp);
	if (mod === deemon)
		return "?D" + encode_name(name);
	return "?E{}:{}".format({
		/* TODO: This only works for global modules! */
		encode_name(deemon.module.__name__(mod)),
		encode_name(name),
	});
}

@@Given a Doc-path in the form of $"<MODULE>/<ITEM>/<ATTR>/...", convert
@@that path into the form of $"?A<ATTR>?A<ATTR>?E<MODULE>:<ITEM>"
local function encode_type_from_path(path: string): string {
	local a,none,b = path.strip("/").rpartition("/")...;
	if (!b)
		return "?M" + encode_name(a);
	if ("/" !in a) {
		return "?E{}:{}".format({
			encode_name(a),
			encode_name(b),
		});
	}
	return "?A{}{}".format({
		encode_name(b),
		encode_type_from_path(a)
	});
}


@@Encode an arbitrary object expression @ob as a function default argument
@@If the given @ob cannot be encoded as such, return :none instead
local function encode_expr(ob: object): string | none {
	if (ob is int || ob is float)
		return "!" + ob;
	if (ob is string)
		return "!P" + encode_name(ob);
	if (ob is none)
		return "!N";
	if (ob is bool)
		return ob ? "!t" : "!f";
	if (ob is type object) {
		if (ob === deemon.object)
			return "!Dobject";
		return "!" + encode_type(ob)[1:];
	}
	if (ob is deemon.module)
		return "!M" + encode_name(deemon.module.__name__(ob));
	return none;
}

@@Generate the @n'th generic argument name, following the rules layed
@@out for generating names for unknown arguments:
@@Start by using each of abcdefghijklmnopqrstuvwxyz, the continue
@@by generating names aa ab ac, etc.
@@Additionally, when @d is given, try to extract argument name information
@@from keyword information meta-data taken from the Doc node's bound object.
local function get_generic_argument_name(n: int, d: Doc | none = none): string {
	if (d !is none && d.object is bound) {
		local ob = d.object;
		if (hasattr(ob,"__kwds__")) {
			local kwds = ob.__kwds__;
			if (n < #kwds)
				return kwds[n];
		}
	}
	local pat = "abcdefghijklmnopqrstuvwxyz";
	local result = "";
	do {
		result = pat[n % #pat] + result;
		n /= #pat;
	} while (n);
	return result;
}



@@Split a given @text documentation string into its individual sections
@@Note that the segments returned will have already had escaped line-feeds expanded
local function split_doc_sections(text: string): {string...} {
	return text.unifylines().split("\n\n");
}

@@Check if a backslash at @pos in @text is non-escaped, meaning
@@that in a text $r"a\\b", the backslash is ecaped, but isn't in $r"a\b"
local function is_backslash_at(text: string, pos: int): bool {
	local result = true;
	while (pos > 0) {
		--pos;
		if (text[pos] != "\\")
			break;
		result = !result;
	}
	return result;
}

@@Try to find @tofind in @text, but ensure that it isn't prefixed by an unmatched backslash
@@If @tofind could not be found, return ${-1} instead.
local function find_nonescaped(text: string, tofind: string, start: int = 0, end: int = -1): int {
	for (;;) {
		local result = text.find(tofind,start,end);
		if (result < 0)
			break;
		if (result && text[result - 1] == "\\" &&
		    is_backslash_at(text,result - 1)) {
			start = result + 1;
			continue;
		}
		return result;
	}
	return -1;
}

@@Similar to :find_nonescaped, but search from the right
local function rfind_nonescaped(text: string, tofind: string, start: int = 0, end: int = -1): int {
	for (;;) {
		local result = text.rfind(tofind,start,end);
		if (result < 0)
			break;
		if (result && text[result - 1] == "\\") {
			local is_escaped = true;
			local pos = result - 1;
			while (pos > 0) {
				--pos;
				if (text[pos] != "\\")
					break;
				is_escaped = !is_escaped;
			}
			if (is_escaped) {
				end = pos;
				continue;
			}
		}
		return result + 1;
	}
	return -1;
}

@@Split a given @text at each non-escaped instance of @tofind
local function split_nonescaped(text: string, tofind: string): {string...} {
	if (!text)
		return;
	local i = 0;
	for (;;) {
		local pos = find_nonescaped(text,tofind,i);
		if (pos < 0) {
			yield text.substr(i);
			break;
		}
		yield text.substr(i,pos);
		i = pos + #tofind;
	}
}


@@Decode a <NAME>-like documentation name
local function decode_name_end(name: string, start: int = 0): int {
	local result;
	if (name.startswith("{",start)) {
		result = find_nonescaped(name,"}",start + 1);
		if (result < 0)
			result = #name;
		return result;
	}
	result = start;
	while (result < #name && name.issymcont(result))
		++result;
	return result;
}



@@Lookup table to convert pretty operator names to their real counterparts
local operator_defaults: {(string,string)...} = {
	"constructor" : "(args!)->?N", "copy" : "(other:?.)->?N", "deepcopy" : "(other:?.)->?N",
	"destructor" : "()->?N", "assign" : "(other:?.)->?N", "moveassign" : "(other:?.)->?N",
	"str" : "()->?Dstring", "repr" : "()->?Dstring", "bool" : "()->?Dbool",
	"next" : "()->", "call" : "(args!)->", "int" : "()->?Dint", "hash" : "()->?Dint",
	"size" : "()->?Dint", "float" : "()->?Dfloat", "inv" : "()->?.",
	"pos" : "()->?.", "neg" : "()->?.", "add" : "(other:?.)->?.",
	"sub" : "(other:?.)->?.", "mul" : "(other:?.)->?.",
	"div" : "(other:?.)->?.", "mod" : "(other:?.)->?.",
	"shl" : "(shift:?Dint)->?.", "shr" : "(shift:?Dint)->?.",
	"pow" : "(other:?.)->?.", "and" : "(other:?.)->?.",
	"or" : "(other:?.)->?.", "xor" : "(other:?.)->?.",
	"inc" : "()->?.", "dec" : "()->?.", "iadd" : "(other:?.)->?.",
	"isub" : "(other:?.)->?.", "imul" : "(other:?.)->?.",
	"idiv" : "(other:?.)->?.", "imod" : "(other:?.)->?.",
	"ishl" : "(shift:?Dint)->?.", "ishr" : "(shift:?Dint)->?.",
	"ipow" : "(other:?.)->?.", "iand" : "(other:?.)->?.",
	"ior" : "(other:?.)->?.", "ixor" : "(other:?.)->?.",
	"eq" : "(other:?.)->?Dbool", "ne" : "(other:?.)->?Dbool",
	"lo" : "(other:?.)->?Dbool", "le" : "(other:?.)->?Dbool",
	"gr" : "(other:?.)->?Dbool", "ge" : "(other:?.)->?Dbool",
	"iter" : "()->?Aiterator?.", "contains" : "(item)->?Dbool",
	"getitem" : "(index:?Dint)->", "delitem" : "(index:?Dint)->?N",
	"setitem" : "(index:?Dint,value)->?N", "getrange" : "(start:?Dint,end:?Dint)->?S?O",
	"delrange" : "(start:?Dint,end:?Dint)->?N", "setrange" : "(start:?Dint,end:?Dint,values:?S?O)->?N",
	"getattr" : "(attr:?Dstring)->", "delattr" : "(attr:?Dstring)->?N",
	"setattr" : "(attr:?Dstring,value)->?N", "enumattr" : "()->?S?Dattribute",
	"enter" : "()->?N", "leave" : "()->?N",
};

@@Lookup table to convert pretty operator names to their real counterparts
local operator_names: {(string,string)...} = {
	"this" : "constructor", "~this" : "destructor", ":=" : "assign",
	"move:=" : "moveassign", ":=move" : "moveassign", "++" : "inc",
	"--" : "dec", "#" : "size", "~" : "inv", "+" : none, "-" : none,
	"*" : "mul", "/" : "div", "%" : "mod", "<<" : "shl",
	">>" : "shr", "&" : "and", "|" : "or", "^" : "xor",
	"**" : "pow", "+=" : "iadd", "-=" : "isub", "*=" : "imul",
	"/=" : "idiv", "%=" : "imod", "<<=" : "ishl", ">>=" : "ishr",
	"&=" : "iand", "|=" : "ior", "^=" : "ixor", "**=" : "ipow",
	"<" : "lo", "<=" : "le", ">" : "gr", ">=" : "ge", "==" : "eq",
	"!=" : "ne", "[]" : "getitem", "del[]" : "delitem",
	"[]=" : "setitem", "[:]" : "getrange", "del[:]" : "delrange",
	"[:]=" : "setrange", "." : "getattr", ".=" : "setattr",
	"del." : "delattr", "lt" : "lo", "gt" : "gr",
};
local pretty_operator_names: {(string,string)...} = {
	"assign" : " :=", "moveassign" : "move :=", "size" : "#",
	"inv" : "~", "add" : "+", "sub" : "-", "pos" : "+", "neg" : "-",
	"mul" : "*", "div" : "/", "mod" : "%", "shl" : "<<",
	"shr" : ">>", "and" : "&", "or" : "|", "xor" : "^",
	"delitem" : "del[]", "ne" : "!=", "getitem" : "[]", "iand" : "&=",
	"ishr" : ">>=", "isub" : "-=", "eq" : "==", "ishl" : "<<=",
	"setitem" : "[]=", "delrange" : "del[:]", "iadd" : "+=",
	"setrange" : "[:]=", "ior" : "|=", "ixor" : "^=", "imul" : "*=",
	"idiv" : "/=", "getrange" : "[:]", "ipow" : "**=", "imod" : "%=",
	"le" : "<=", "pow" : "**", "ge" : ">="
};

@@Weight of different node types when being sorted
local kind_sorting_weights: {(string,int)...} = {
	"module" : 0x0000, "operator" : 0x0100,
	"type" : 0x0101, "singleton" : 0x0102,
	"function" : 0x0200, "property" : 0x0201, "member" : 0x0202,
	"class_function" : 0x0300, "class_property" : 0x0301,
	"class_member" : 0x0302,
};

@@Weight of different operators when being sorted
local operator_sorting_weights: {(string,int)...} = {
	"constructor" : 0x0000, "copy" : 0x0001, "deepcopy" : 0x0002,
	"destructor" : 0x0003, "assign" : 0x0004, "moveassign" : 0x0005,
	"str" : 0x0100, "repr" : 0x0101, "bool" : 0x0102, "int" : 0x0103,
	"call" : 0x0200, "eq" : 0x0300, "ne" : 0x0301, "lo" : 0x0302,
	"le" : 0x0303, "gr" : 0x0304, "ge" : 0x0305, "inv" : 0x0400,
	"pos" : 0x0401, "neg" : 0x0402, "add" : 0x0403, "sub" : 0x0404,
	"mul" : 0x0405, "div" : 0x0406, "mod" : 0x0407, "shl" : 0x0408,
	"shr" : 0x0409, "and" : 0x040a, "or" : 0x040b, "xor" : 0x040c,
	"pow" : 0x040d, "iadd" : 0x040e, "isub" : 0x040f, "imul" : 0x0410,
	"idiv" : 0x0411, "imod" : 0x0412, "ishl" : 0x0413, "ishr" : 0x0414,
	"iand" : 0x0415, "ior" : 0x0416, "ixor" : 0x0417, "ipow" : 0x0418,
	"iter" : 0x0500, "size" : 0x0501, "contains" : 0x0502, "getitem" : 0x0503,
	"delitem" : 0x0504, "setitem" : 0x0505, "getrange" : 0x0506,
	"delrange" : 0x0507, "setrange" : 0x0508, "next" : 0x0600,
	"enter" : 0x0700, "leave" : 0x0701, "getattr" : 0x0800,
	"delattr" : 0x0801, "setattr" : 0x0802, "enumattr" : 0x0803,
};


@@Return the real name of a given operator name @name
@@This function translates names such as "#" to "size"
@@When the real operator cannot be unambiguosly deduced without
@@known the associated argument count, return :none, in which case
@@the caller must determine the argument count and re-attempt the
@@call while passing @argc as a value other than :none.
local function operator_realname(name: string, argc: int | none = none): string | none {
	local result = operator_names.get(name,name);
	if (result is none) {
		if (argc is none)
			return none;
		switch (name) {
		case "+":
			return argc == 0 ? "pos" : "add";
		case "-":
			return argc == 0 ? "neg" : "sub";
		default: break;
		}
		result = name.strip("_");
	}
	return result;
}

@@Returns the Doc-like path for a given fully qualified type
@@If no such path exists, return :none instead
@@NOTE: The returned path includes a leading $"/"
local function get_qualified_typepath(docnode: weakref with Doc, qual: string): string | none {
	if (#qual >= 2) switch (qual[1]) {
	case "G": {
		local mod = docnode.value.module;
		if (mod is none)
			return none;
		return "/{}/{}".format({
			deemon.module.__name__(mod),
			decode_name(qual.substr(2)),
		});
	}	break;
	case "E": {
		local modend = find_nonescaped(qual,":",2);
		return "/{}/{}".format({
			decode_name(qual.substr(2,modend)),
			decode_name(qual.substr(modend + 1)),
		});
	}	break;
	case "A": {
		local nameend = decode_name_end(qual,2);
		local base = get_qualified_typepath(docnode,qual.substr(nameend));
		if (base is none)
			return none;
		return "{}/c:{}".format({
			base,
			decode_name(qual.substr(2,nameend)),
		});
	}	break;
	default:
		break;
	}
	return none;
}

local function find_error_by_name(t: type_, qual: string, s: string): string | none {
	if (t.__name__ == s)
		return qual;
	for (local attr: deemon.enumattr(t)) {
		if (attr.decl != t) break;
		if (attr.attrtype != type deemon.object) break;
		if (!attr.isclass) continue;
		local result = find_error_by_name(
			t.operator . (attr.name),
			"?A{}{}".format({ attr.name, qual }),
			s);
		if (result !is none)
			return result;
	}
}

local function qualify_legacy_typeref(docnode: weakref with Doc, s: string): string {
	/* Search for a legacy-like type reference */
	local node = docnode.value;
	if (!node.istype && node.parent !is none)
		node = node.parent;
	do {
		if (node.haschild(s))
			return "?A{}{}".format({ encode_name(s), node.qualpath });
		node = node.parent;
	} while (node !is none);
	/* Search for known sub-classes of `Error' */
	local result = find_error_by_name(Error,"?DError",s);
	if (result !is none)
		return result;
	/* Search the deemon module itself. */
	if (hasattr(deemon,s))
		return "?D" + encode_name(s);
	/* Fallback: Invalid encoding -> Encode an unknown */
	return "?U" + encode_name(s);
}

@@Turn @s into a fully qualified type reference string
local function qualify_typeref_string(docnode: weakref with Doc, s: string): string {
	if (s.startswith("?") && #s >= 2) {
		switch (s[1]) {
		case ".": {
			local node = docnode.value;
			if (!node.istype && node.parent !is none)
				node = node.parent;
			return node.qualpath;
		}	break;
		case "#": {
			local node = docnode.value;
			local len = decode_name_end(s,2);
			if (node.ismodule) {
				local mod = node.module;
				return "?E{}:{}".format({
					/* TODO: This only works for global modules! */
					encode_name(deemon.module.__name__(mod)),
					s.substr(2,len)
				});
			}
			if (!node.istype && node.parent !is none)
				node = node.parent;
			return "?A{}{}".format({
				s.substr(2,len),
				node.qualpath,
			});
		}	break;
		case "N": return "?Edeemon:none";
		case "O": return "?Edeemon:object";
		case "D":
			return "?Edeemon:" + decode_name(s.substr(2));
		case "U":
		case "E":
		case "G":
			return s;
		case "A": {
			local attr_end;
			attr_end = find_nonescaped(s,"?",2);
			if (attr_end < 0)
				break;
			local tail = s.substr(attr_end);
			local newtail = qualify_typeref_string(docnode,tail);
			if (tail === newtail)
				return s;
			return s.substr(0,attr_end) + newtail;
		}	break;
		default: break;
		}
	}
	return qualify_legacy_typeref(docnode,s);
}

@@Return the type associated with a given fully qualified path
@@If the type could not be accessed, return :none or throw an
@@exception.
local function get_type_from_qualpath(docnode: weakref with Doc, qual: string): deemon.type_ | none {
	if (#qual < 2)
		return none;
	switch (qual[1]) {
	case "A": {
		local attrend = decode_name_end(qual,2);
		local base = get_type_from_qualpath(docnode,qual.substr(attrend));
		local result = base.operator . (qual.substr(2,attrend));
		if (result is none) result = type none;
		return result;
	}	break;
	case "E": {
		local modend = find_nonescaped(qual,":");
		if (modend < 0)
			break;
		local modnam = decode_name(qual.substr(2,modend));
		local symnam = decode_name(qual.substr(modend + 1));
		local mod;
		if (modnam.startswith(".")) {
			/* Import the module relatively to the one calling */
			mod = import(modnam, base: docnode.value.module);
		} else {
			mod = import(modnam);
		}
		return mod.operator . (symnam);
	}	break;
	case "G": {
		local basemod = docnode.value.module;
		local result = basemod.operator . (qual.substr(2));
		if (result is none) result = type none;
		return result;
	}	break;
	default: break;
	}
	return none;
}


@@Abstract representation of a type reference, using either
@@the new-style ?... encoding, or the direct naming of types
@@seen in old-style documentation strings
class TypeRef: weakrefable {

	@@The fully qualified documentation string for this type
	@@Example: $"?Edeemon:int"
	@@This type reference always has one of the following forms
	@@ - $"?A<NAME><TYPE>" (Allowing for attribute-lookup recursion)
	@@ - $"?E<NAME>:<NAME>" (For types with a known resident location)
	@@ - $"?G<NAME>" (For types with a known resident location in the associated module)
	@@ - $"?U<NAME>" (For types with an unknown resident location)
	public final property docstring: string = {
		get(): string {
			if (m_docstring !is string)
				m_docstring = qualify_typeref_string(docnode,encode_type(m_docstring));
			return m_docstring;
		}
	}
	public final member m_docstring: string | deemon.type_;

	@@The doc node that contains a reference to @this TypeRef
	public final member docnode: weakref with Doc;

	this(d: Doc | weakref with Doc, ds: string | deemon.type_)
		: docnode(d is weakref ? d : weakref(d))
	{
		if (ds is string) {
			m_docstring = qualify_typeref_string(docnode,ds);
		} else {
			m_docstring = ds;
			m_typ = ds;
		}
	}

	@@Returns a string representation of how @this TypeRef can be created
	operator repr(): string {
		return "TypeRef({!r},{!r})".format({ docnode.lock(none), docstring });
	}

	@@The actual type object represented by @this TypeRef,
	@@or :none if that type is unreachable or unknown
	public final property typ: deemon.type_ | none = {
		get(): deemon.type_ | none {
			if (m_typ !is bound) {
				m_typ =
					try get_type_from_qualpath(docnode,m_docstring)
					catch (...) none;
				if (m_typ !is deemon.type_)
					m_typ = none;
			}
			return m_typ;
		}
	}
	private member m_typ: deemon.type_ | none;


	@@Returns the Doc path associated with the type referenced by @this
	@@If no such path exists, return :none instead
	@@NOTE: The returned path includes a leading $"/"
	public final property path: string | none = {
		get(): string | none {
			if (m_path !is bound)
				m_path = get_qualified_typepath(docnode,docstring);
			return m_path;
		}
	}
	private member m_path: string | none;

	@@Similar to #path, but return the associated Doc node instead
	public final property node: Doc | none = {
		get(): Doc | none {
			if (m_node !is bound) {
				local p = path;
				if (p is none) {
					m_node = none;
					return none;
				}
				local result = Doc(p);
				m_node = weakref();
				return result;
			} else {
				local result = m_node.lock(none);
				if (result is none) {
					local p = path;
					if (p is none) {
						m_node = none;
						return none;
					}
					m_node.value = result = Doc(p);
				}
				return result;
			}
		}
	}
	private member m_node: weakref with Doc | none;

	@@Get the human-readable name of the type Referneced by @this
	@@The returned string does not retain all available information,
	@@and ishas 2 different forms:
	@@ - When the type is found to be apart of the same module as the referencing
	@@   doc node, then the module prefix is omitted, and the returned string is
	@@   structured in the form of $"MyType.iterator" (for ${(MyType from mymodule).iterator})
	@@ - When the type is apart of a different module, then that module's name is
	@@   prefixed, resulting in the form of $"mymodule.MyType.iterator"
	@@   When that other module is the builtin :deemon module, the module prefix
	@@   will be attempted to be omitted, however if the current module also contains
	@@   an export with the same name, the prefix is retained.
	public final property prettyname: string = {
		get() {
			if (m_prettyname !is bound) {
				if (docstring.startswith("?G"))
					m_prettyname = decode_name(docstring.substr(2));
				else {
					m_prettyname = getprettyname(docstring);
				}
			}
			return m_prettyname;
		}
	}
	private member m_prettyname: string;
	private getprettyname(qual): string {
		if (#qual >= 2) switch (qual[1]) {
		case "E": {
			local modend = find_nonescaped(qual,":",2);
			local modname = decode_name(qual.substr(2,modend));
			local modexp = decode_name(qual.substr(modend + 1));
			local mymod = docnode.lock(none).module;
			if (mymod !is none && modname == deemon.module.__name__(mymod))
				return modexp;
			if (modname == "deemon" && modexp !in deemon.module.__exports__(mymod))
				return modexp;
			return "{}.{}".format({ modname, modexp });
		}	break;
		case "U":
			return decode_name(qual.substr(2));
		case "A": {
			local namelen = decode_name_end(qual,2);
			return "{}.{}".format({
				getprettyname(qual.substr(namelen)),
				decode_name(qual.substr(2,namelen)),
			});
		}
		default:
			break;
		}
		return decode_name(qual.substr(2));
	}

	operator str(): string {
		return prettyname;
	}
}

@@Returns the character index where a type expression starting at @start ends
local function typeexpr_end(s: string, start: int): int {
	local len = #s;
	local result = start;
again:
	if (result >= len)
		return result;
	if (s[result] != "?") {
		result = s.find("?");
		if (result < 0)
			result = len;
		return result;
	}
	++result;
	if (result >= len)
		return result;
	switch (s[result]) {
	case "#":
	case "D":
	case "U":
	case "G":
		++result;
		result = decode_name_end(s,result);
		break;
	case "E":
		++result;
		result = decode_name_end(s,result);
		if (s[result] == ":") {
			++result;
			result = decode_name_end(s,result);
		}
		break;
	case "A":
		++result;
		result = decode_name_end(s,result);
		goto again;
	case "C":
		++result;
		result = typeexpr_end(s,result);
		goto again;
	case "T":
	case "X": {
		++result;
		local n_start = result;
		while (result < len && s.isdigit(result))
			++result;
		local n = try int(s[n_start:result]) catch (...) 0;
		for (none: [:n])
			result = typeexpr_end(s,result);
	}	break;
	case "S":
		++result;
		goto again;
	case "Q": {
		local end = find_nonescaped(s,"]",result + 1);
		if (end < 0)
			end = len - 1;
		result = end + 1;
	}	break;
	default:
		++result;
		break;
	}
	return result;
}


@@Returns the character index where a default expression starting at @start ends
local function deflexpr_end(s: string, start: int): int {
	local len = #s;
	local result = start;
again:
	if (result >= len)
		return result;
	if (s[result] != "!") {
		result = s.find("!");
		if (result < 0)
			result = len;
		return result;
	}
	++result;
	if (result >= len)
		return result;
	switch (s[result]) {
	case "V":
		++result; /* VA */
	case "P":
	case "#":
	case "D":
	case "U":
	case "G":
	case "M":
		++result;
		result = decode_name_end(s,result);
		break;
	case "E":
		++result;
		result = decode_name_end(s,result);
		if (s[result] == ":") {
			++result;
			result = decode_name_end(s,result);
		}
		break;
	case "T":
	case "L":
	case "S":
	case "H": {
		++result;
		local n_start = result;
		while (result < len && s.isdigit(result))
			++result;
		local n = try int(s[n_start:result]) catch (...) 0;
		for (none: [:n])
			result = deflexpr_end(s,result);
	}	break;
	case "!":
		++result;
		if (result >= len)
			break;
		switch (s[result]) {
		case "!":
			++result;
			if (result >= len)
				break;
			switch (s[result]) {
			case "!": /* NOT */
				++result;
				goto again;
			case "<": /* shl */
			case ">": /* shr */
				++result;
				result = deflexpr_end(s,result);
				goto again;
			default: break;
			}
			break;
		case "+":
		case "-":
		case "*":
		case "=":
		case "<":
		case ">":
		case "C":
			++result;
			result = deflexpr_end(s,result);
			goto again;
		case "[":
			++result;
			result = deflexpr_end(s,result);
			result = deflexpr_end(s,result);
			goto again;
		default:
			break;
		}
		++result;
		goto again;
	case "C":
	case "X":
	case "W":
	case "O":
	case "K":
	case "R":
	case "Q":
	case "+":
	case "~":
		++result;
		goto again;
	case "*":
	case "/":
	case "%":
	case "&":
	case "|":
	case "^":
	case "=":
	case "<":
	case ">":
	case "[":
		++result;
		result = deflexpr_end(s,result);
		goto again;
	case "I": /* conditional expression */
		++result;
		result = deflexpr_end(s,result);
		result = deflexpr_end(s,result);
		goto again;
	case "-":
		++result;
	default:
		if (result < len && s.isdigit(result)) {
			for (;;) {
				++result;
				if (result >= len)
					break;
				if (!s.isdigit(result) && s[result] != ".")
					break;
			}
			break;
		} else {
			++result;
		}
		break;
	}
	return result;
}




@@Abstract representation of a type expression, including
@@support for generic sequence expressions, alternative
@@representations, as well as container expressions.
@@Example:
@@>import * from deemon;
@@>import * from doc;
@@>function foo(x: int | float): string {
@@> return str x;
@@>}
@@>
@@>local d = Doc(foo);
@@>print d.decls[0].parameters[0].typ.Xtypes[0].Etyperef.typ; /* int */
@@>print d.decls[0].parameters[0].typ.Xtypes[1].Etyperef.typ; /* float */
@@>print d.decls[0].ret.Etyperef.typ;                         /* string */
@@>print d.decls[0].parameters[0].isaccepted(1234);  /* true */
@@>print d.decls[0].parameters[0].isaccepted(1.0);   /* true */
@@>print d.decls[0].parameters[0].isaccepted("foo"); /* false */
class TypeExpr: weakrefable {

	@@The raw documentation string for this type
	@@Example: $"?T2?Dint?Dint"
	public final property docstring: string = {
		get(): string {
			if (m_docstring !is string)
				m_docstring = encode_type(m_docstring);
			return m_docstring;
		}
	}
	private member m_docstring: string | deemon.type_;

	@@The doc node that contains a reference to @this TypeExpr
	public final property docnode: weakref with Doc = {
		get(): weakref with Doc {
			return docdecl.value.docsect.value.docnode;
		}
	}

	@@The doc Declaration that uses @this TypeExpr
	public final member docdecl: weakref with Declaration;

	this(d: Declaration | weakref with Declaration, ds: string | deemon.type_)
		: docdecl(d is weakref ? d : weakref(d))
		, m_docstring(ds)
	{
		if (m_docstring !is string) {
			m_kind = "E";
			m_cache = TypeRef(docnode,m_docstring);
			m_types = (m_docstring,);
		}
	}

	@@Returns a string representation of how @this TypeExpr can be created
	operator repr(): string {
		return "TypeExpr({!r},{!r})".format({ docdecl.lock(none), docstring });
	}

	@@Returns true if @this Type expression referrs to :none
	public final property isnone: bool = {
		get(): bool {
			if (m_docstring is string)
				return m_docstring in ["?N","?Dnone","?Edeemon:none"];
			return m_docstring === type none;
		}
	}

	@@Returns :true if the type referred to by @this TypeExpr
	@@accepts any kind of input (aka. referrs to deemon.object)
	@@Seperately, a X-expression with at least one element
	@@accepting anything, also accepts anything itself.
	public final property acceptsany: bool = {
		get(): bool {
			if (m_acceptsany !is bound) {
				if (m_docstring !is string)
					m_acceptsany = m_docstring === deemon.object;
				else if (m_docstring in ["?O","?Dobject","?Edeemon:object"])
					m_acceptsany = true;
				else {
					m_acceptsany = false;
					if (kind == "X") {
						for (local x: Xtypes) {
							if (x.acceptsany) {
								m_acceptsany = true;
								break;
							}
						}
					}
				}
			}
			return m_acceptsany;
		}
	}
	private member m_acceptsany: bool;


	@@Check if a given object @ob can be accepted as argument for @this TypeExpr
	public final isaccepted(ob: object): bool {
		switch (kind) {
		case "E":
			return ob is Etyperef.typ;
		case "C": {
			if (ob !is Ccelltype.typ)
				return false;
			local cellitem = Citemtype.typ;
			if (cellitem === deemon.object)
				return true;
			try {
				if (ob.value is cellitem)
					return true;
			} catch (...) {
			}
		}	break;
		case "T": {
			local items;
			try {
				items = tuple(ob);
			} catch (...) {
				return false;
			}
			local ttypes = Ttypes;
			if (#items != #ttypes)
				return false;
			for (local i: [:#items]) {
				if (!ttypes[i].isaccepted(items[i]))
					return false;
			}
			return true;
		} break;
		case "X":
			for (local alt: Xtypes) {
				if (alt.isaccepted(ob))
					return true;
			}
			break;
		case "S": {
			local it;
			try {
				it = ob.operator iter();
			} catch (...) {
				return false;
			}
			local st = Stype;
			if (st.acceptsany)
				return true;
			for (;;) {
				local elem;
				try {
					foreach(elem: it)
						goto check_elem;
					return true;
				} catch (...) {
					return false;
				}
check_elem:
				if (!st.isaccepted(ob))
					return false;
			}
			return true;
		}	break;
		default:
			break;
		}
		return false;
	}

	@@Enumerate the (simplified) set of types which @this TypeExpr accepts
	@@For this purpose, contained-information for cell-like objects is removed, and
	@@any kind of sequence-like type is interpreted as one of :sequence or :mapping
	public final property types: {deemon.type_...} = {
		get(): {deemon.type_...} {
			if (m_types !is bound)
				m_types = hashset(enumtypes());
			return m_types;
		}
	}
	private member m_types: {deemon.type_...};

	private enumtypes(): {deemon.type_...} {
		switch (kind) {
		case "E":
			yield Etyperef.typ;
			break;
		case "C":
			yield Ccelltype.enumtypes()...;
			break;
		case "T":
			yield deemon.sequence;
			break;
		case "X":
			for (local x: Xtypes)
				yield x.enumtypes()...;
			break;
		case "S": {
			local st = Stype;
			if (st.docstring.startswith("?T2"))
				yield deemon.mapping; /* Sequence of 2-element tuples. */
			else {
				yield deemon.sequence; /* Sequence of something else. */
			}
		}	break;
		case "Q":
			yield Qexpr.exprtypes...;
			break;
		default:
			yield deemon.object;
			break;
		}
	}

	@@Returns the kind of type expression represented by @this node
	@@This is a single character, which is one of:
	@@ - $"E": Fully qualifyable type; s.a. #Etyperef
	@@ - $"C": Container-like type (s.a. #Ccelltype and #Citemtype)
	@@ - $"T": Tuple consisting of multiple child-elements (s.a. #Ttypes)
	@@ - $"X": A set of multiple, alternatively accepted types (s.a. #Xtypes)
	@@ - $"S": A sequence containing elements of a specific type (s.a. #Stype)
	@@ - $"Q": The type of an expression (s.a. #Qexpr)
	public final property kind: string = {
		get(): string {
			if (m_kind !is bound) {
				if (#m_docstring < 2 || !m_docstring.startswith("?"))
					m_kind = "E"; /* Legacy-like type name */
				else {
					m_kind = m_docstring[1];
					if (m_kind in [".","N","O","#","D","U","G"/*,"E"*/,"A"])
						m_kind = "E"; /* Fully qualifyable */
				}
			}
			return m_kind;
		}
	}
	private member m_kind: string;


	@@Cache of child-expressions / references
	private member m_cache: TypeRef | TypeExpr | {TypeExpr...} | (TypeExpr,TypeExpr) | Expression;
	private loadC() {
		local end = typeexpr_end(m_docstring,2);
		m_cache = (
			TypeExpr(docdecl,m_docstring.substr(2,end)),
			TypeExpr(docdecl,m_docstring.substr(end)),
		);
	}
	private loadTX() {
		local pos = 2;
		while (pos < #m_docstring && m_docstring.isdigit(pos))
			++pos;
		local n = try int(m_docstring[2:pos]) catch (...) 0;
		local result = list(n,none);
		for (local i: [:n]) {
			local end = typeexpr_end(m_docstring,pos);
			result[i] = TypeExpr(docdecl,m_docstring.substr(pos,end));
			pos = end;
		}
		m_cache = tuple(result);
	}
	private loadS() {
		m_cache = TypeExpr(docdecl,m_docstring.substr(2));
	}
	private loadQ() {
		m_cache = Expression(docdecl,m_docstring[2:-1]);
	}


	@@Returns a fully qualified type reference for @this
	@@WARNING: This property must only be used when #kind is equal to $"E"
	public final property Etyperef: TypeRef = {
		get(): TypeRef {
			if (m_cache !is bound)
				m_cache = TypeRef(docnode,m_docstring);
			return m_cache;
		}
	}

	@@Returns the cell container type for @this
	@@WARNING: This property must only be used when #kind is equal to $"C"
	public final property Ccelltype: TypeExpr = {
		get(): TypeExpr {
			if (m_cache !is bound)
				loadC();
			return m_cache[0];
		}
	}

	@@Returns the cell item type for @this
	@@WARNING: This property must only be used when #kind is equal to $"C"
	public final property Citemtype: TypeExpr = {
		get(): TypeExpr {
			if (m_cache !is bound)
				loadC();
			return m_cache[1];
		}
	}

	@@Returns the sequence of tuple element types
	@@WARNING: This property must only be used when #kind is equal to $"T"
	public final property Ttypes: {TypeExpr...} = {
		get(): {TypeExpr...} {
			if (m_cache !is bound)
				loadTX();
			return m_cache;
		}
	}

	@@Returns the sequence of alternative type expressions
	@@WARNING: This property must only be used when #kind is equal to $"X"
	public final property Xtypes: {TypeExpr...} = {
		get(): {TypeExpr...} {
			if (m_cache !is bound)
				loadTX();
			return m_cache;
		}
	}

	@@Returns the element type of @this sequence expression
	@@WARNING: This property must only be used when #kind is equal to $"S"
	public final property Stype: TypeExpr = {
		get(): TypeExpr {
			if (m_cache !is bound)
				loadS();
			return m_cache;
		}
	}

	@@Returns the expression who's type is referenced by @this TypeExpr
	@@WARNING: This property must only be used when #kind is equal to $"Q"
	public final property Qexpr: Expression = {
		get(): Expression {
			if (m_cache !is bound)
				loadQ();
			return m_cache;
		}
	}

	@@Return @this type in a way in which the user may have originally written it
	operator str(): string {
		switch (kind) {
		case "E":
			return str Etyperef;
		case "C":
			return "{} with {}".format({ Ccelltype, Citemtype });
		case "T":
			return #Ttypes == 1
				? "({},)".format({ Ttypes[0] })
				: "({})".format({ ", ".join(Ttypes) });
		case "X":
			return " | ".join(Xtypes);
		case "S":
			return "{{{}...}}".format({ Stype });
		case "Q":
			return "type({})".format({ Qexpr });
		default: break;
		}
		return docstring;
	}
}


@@Abstract representation of documentation expressions,
@@as used to encode parameter default values
class Expression: weakrefable {

	@@The raw documentation string for this expression
	@@Example: $"!Edeemon:none"
	public final property docstring: string = {
		get(): string {
			if (m_docstring === false)
				m_docstring = encode_expr(m_cache);
			return m_docstring;
		}
	}
	private member m_docstring: string | bool;

	@@The doc Declaration that contains a reference to @this Expression
	public final member docdecl: weakref with Declaration;

	@@The doc node associated with @this Expression
	public final property docnode: weakref with Doc = {
		get(): weakref with Doc {
			return docdecl.value.docsect.value.docnode;
		}
	}

	this(d: Declaration | weakref with Declaration, ds: string | bool, cval?: object)
		: docdecl(d is weakref ? d : weakref(d))
		, m_docstring(ds)
	{
		if (cval is bound) {
			m_kind = "C";
			m_cache = cval;
		}
	}

	@@Returns a string representation of how @this Expression can be created
	operator repr(): string {
		return "Expression({!r},{!r})".format({ docdecl.lock(none), docstring });
	}

	@@Enumerate a sequence of all the possible types that @this expression can take
	public final property exprtypes: {TypeExpr...} = {
		get(): {TypeExpr...} {
			switch (kind) {
			case "C":
				yield TypeExpr(docdecl,type Cvalue);
				break;
			case "A":
				/* Alias the same types as seen in another argument. */
				yield Aparam.typ.types...;
				break;
			case "S":
				yield StypeExpr;
				break;
			default:
				yield TypeExpr(docdecl,"?O");
				break;
			}
		}
	}

	@@Helper function to try and optimize an expression into a constant
	private try_optimize_expression() {
		/* TODO */
	}


	@@The kind of expression, which is one of
	@@  - C  A constant expression (s.a. #Cvalue)
	@@  - E  An fully qualified location within a reachable module (s.a. #Epath, #Emodule, #Evalue)
	@@  - A  Another argument (s.a. #Aparam)
	@@  - U  An undefined/private symbol (s.a. #Uname)
	@@  - S  A sequence expression (s.a. #Sitems, #Stype)
	@@  - O  An operator being invoked on another expression (s.a. #Ooperator and #Ooperands)
	public final property kind: string = {
		get(): string {
			if (m_kind !is bound) {
				if (!m_docstring.startswith("!")) {
					/* Raw, constant expression */
					m_kind = "C";
					if (!m_docstring)
						m_cache = none;
					else if (m_docstring.startswith("\""))
						m_cache = try m_docstring.decode("c-escape") catch (...) m_docstring;
					else if (m_docstring.startswith("r\""))
						m_cache = m_docstring[2:-1];
					else if (m_docstring.isdigit(0))
						m_cache = try
							"." in m_docstring
								? float(m_docstring)
								: int(m_docstring)
							catch (...)
								m_docstring;
					else if (":" in m_docstring) {
						/* Assume external symbol. */
						local mod,none,path = m_docstring.partition(":")...;
						m_docstring = "!E{}:{}".format({
							encode_name(mod),
							encode_name(path),
						});
						m_kind = "E";
					} else {
						local defl = {
							"none" : none,
							"true" : true,
							"false" : false,
						};
						m_cache = defl.get(m_docstring,m_docstring);
					}
				} else if (#m_docstring < 2) {
					m_kind = "C";
					m_cache = none;
				} else {
					/* New-style default expression. */
					local id = m_docstring[1];
					if (id == "P" || id.isdigit()) {
						m_kind = "C";
					} else if (id == "-" && #m_docstring >= 2 &&
					          (m_docstring.isdigit(2) || m_docstring[2] == ".")) {
						m_kind = "C";
					} else if (id in ["N","t","f"]) {
						local map = { "N" : none, "t" : true, "f" : false };
						m_kind = "C";
						m_cache = map[id];
					} else if (id in ["D","U","G","E","M"]) {
						m_kind = "E";
					} else if (id in ["T","L","S","H"]) {
						m_kind = "S";
					} else if (id == "V" && #m_docstring >= 3 && m_docstring[2] == "A") {
						m_kind = "A";
					} else {
						if (id == "!" && #m_docstring >= 4) {
							id = m_docstring[2];
							if (id == "+" && m_docstring.isdigit(3)) {
								local ds = m_docstring.substr(3);
								m_kind = "C";
								m_cache = try
									"." in ds
										? int(ds)
										: float(ds)
									catch (...)
										ds;
								goto done;
							} else if (id == "-" && m_docstring.isdigit(3)) {
								local ds = m_docstring.substr(3);
								m_kind = "C";
								m_cache = try
									"." in ds
										? -int(ds)
										: -float(ds)
									catch (...)
										ds;
								goto done;
							}
						}
						m_kind = "O";
						try_optimize_expression();
					}
				}
			}
done:
			return m_kind;
		}
	}
	private member m_kind: string;
	private member m_cache;


	@@Returns the constant default value when #kind is $"C"
	public final property Cvalue: object = {
		get(): object {
			if (m_cache !is bound) {
				if (m_docstring[1] == "P") {
					m_cache = decode_name(m_docstring.substr(2));
				} else {
					local ds = m_docstring.substr(1);
					m_cache = try
						"." in ds
							? float(ds)
							: int(ds)
						catch (...)
							ds;
				}
			}
			return m_cache;
		}
	}

	@@Initialize #m_cache as (module_name: string | module | none, module_attr: string | none)
	@@When `module_name' is set to ".", referr to the current module.
	private Edecode() {
		switch (m_docstring[1]) {
		case "D":
			m_cache = (deemon,m_docstring.substr(2));
			break;
		case "U":
			m_cache = (none,m_docstring.substr(2));
			break;
		case "G":
			m_cache = (".",m_docstring.substr(2));
			break;
		case "E": {
			local sep = find_nonescaped(m_docstring,":",2);
			if (sep < 0) {
				m_cache = (m_docstring.substr(2),none);
			} else {
				m_cache = (m_docstring.substr(sep),m_docstring.substr(sep + 1));
			}
		}	break;
		case "M":
			m_cache = (m_docstring.substr(2),none);
			break;
		default:
			m_cache = (none,m_docstring);
			break;
		}
	}

	@@Returns the doc-path for the externally referenced
	@@object, or :none if that path is unavailable.
	public final property Epath: string | none = {
		get(): string | none {
			local modnam = Emodulename;
			if (modnam is none)
				return none;
			local att = Emoduleattr;
			if (att is none)
				return "/" + modnam;
			return "/{}/{}".format({ modnam, att });
		}
	}

	@@Return the doc node for the externally referenced
	@@object, or :none if that object cannot be traced.
	public final property Enode: Doc | none = {
		get(): Doc | none {
			local mod = Emodule;
			if (mod is none)
				return none;
			return Doc(mod,Emoduleattr);
		}
	}

	@@The module that is being imported
	public final property Emodule: module | none = {
		get(): module | none {
			if (m_cache !is bound)
				Edecode();
			local result = m_cache[0];
			if (result !is module && result !is none) {
				if (result.startswith(".")) {
					local base = docnode.value.module;
					result = result == "."
						? base
						: import(result,base: base)
						;
				} else {
					result = import(result);
				}
			}
			return result;
		}
	}

	@@The name of the module that is being imported
	public final property Emodulename: string | none = {
		get(): string | none {
			if (m_cache !is bound)
				Edecode();
			local result = m_cache[0];
			if (result is module)
				result = module.__name__(result);
			return result;
		}
	}

	@@The name of the attribute that is being imported from the #Emodule
	@@If the external reference applies directly to a module, evaluate to :none
	public final property Emoduleattr: string | none = {
		get(): string {
			if (m_cache !is bound)
				Edecode();
			return m_cache[1];
		}
	}

	@@The external object that is being referenced
	public final property Evalue: object | none = {
		get(): object | none {
			local mod = Emodule;
			local att = m_cache[1];
			if (mod !is none && att !is none)
				mod = mod.operator . (att);
			return mod;
		}
	}

	@@Returns the referenced parameter when #kind is $"C"
	public final property Aparam: Parameter | none = {
		get(): Parameter {
			if (m_cache !is bound) {
				/* HINT: If this line causes a ReferenceError to be thrown, then
				 *       you must store the Doc node used to access parameters in
				 *       a temporary variable.
				 * >> import * from deemon;
				 * >> import * from doc;
				 * >> function foo(x: string = "foo"): type(x) {
				 * >> 	return x;
				 * >> }
				 * >>
				 * >> print Doc(foo).decls[0].ret.types...; // Wrong!
				 * >>
				 * >> local d = Doc(foo);
				 * >> print d.decls[0].ret.types...; // OK
				 * >>
				 * This is required, because in the later case, the compiler is
				 * required to keep `d' alive for the duration of enumeration of
				 * the function's return types.
				 * In the first variant, the compiler isn't required to do this,
				 * leading to the weak references we use to point back to the
				 * original doc node to have become stale, causing the `value'
				 * dereference in the following line to read a dead weakref.
				 */
				m_cache = docdecl.value.getparambyname(
					decode_name(m_docstring.substr(3)));
			}
			return m_cache;
		}
	}

	@@Returns the name of the undefined object referenced
	public final property Uname: string = {
		get(): string {
			if (m_cache !is bound)
				m_cache = decode_name(m_docstring.substr(2));
			return m_cache;
		}
	}

	@@Returns the sequence element expression of @this
	public final property Sitems: {Expression...} = {
		get(): {Expression...} {
			if (m_cache !is bound) {
				local pos = 3;
				while (pos < #m_docstring && m_docstring.isdigit(pos))
					++pos;
				local count = try int(m_docstring.substr(2,pos)) catch (...) 0;
				local items = list(count);
				for (local i: [:count]) {
					local start = pos;
					pos = deflexpr_end(m_docstring,pos);
					items[i] = Expression(docdecl,m_docstring.substr(start,pos));
				}
				m_cache = tuple(items);
			}
			return m_cache;
		}
	}

	@@Returns the sequence type of @this, which is one of:
	@@ - :deemon.list
	@@ - :deemon.tuple
	@@ - :deemon.dict
	@@ - :deemon.hashset
	public final property Stype: deemon.type_ = {
		get(): deemon.type_ {
			local map = {
				"L" : deemon.list,
				"T" : deemon.tuple,
				"D" : deemon.dict,
				"S" : deemon.hashset,
			};
			return map[m_docstring[1]];
		}
	}
	@@Similar to #Stype, but return the associated type expression
	public final property StypeExpr: TypeExpr = {
		get(): TypeExpr {
			local map = {
				"L" : "?Dlist",
				"T" : "?Dtuple",
				"D" : "?Ddict",
				"S" : "?Dhashset",
			};
			return TypeExpr(docdecl,map[m_docstring[1]]);
		}
	}

	@@Returns the real-name (e.g. $"add") of the operator being invoked
	public final property Ooperator: string = {
		get(): string {
			/* TODO */
			return "add";
		}
	}

	@@Return the operands of @this Expression
	public final property Ooperands: {Expression...} = {
		get(): {Expression...} {
			/* TODO */
			return {};
		}
	}

	operator str(): string {
		/* TODO: Should instead return a human-readable representation of the expression.
		 *  !t -> true
		 *  !C!Umy_instance -> copy(my_instance)
		 */
		switch (kind) {
		case "C":
			return repr Cvalue;
		case "A":
			return Aparam.name;
		case "E": {
			local mod = Emodulename;
			local att = Emoduleattr;
			if (mod is none)
				return str att;
			if (att is none)
				return mod;
			return "{}.{}".format({ mod, att });
		}
		case "U":
			return Uname;
		case "S":
			switch (m_docstring[1]) {
			case "L":
				return "[{}]".format({ ",".join(Sitems) });
			case "T": {
				local t = tuple(Sitems);
				if (!t) return "()";
				if (#t == 1)
					return "({},)".format({ t[0] });
				return "({})".format({ ",".join(t) });
			}
			case "D": {
				file.writer result;
				result << "{ ";
				local is_first = true;
				for (local a,b: Sitems.segments(2)) {
					if (!is_first)
						result << ", ";
					is_first = false;
					result << a << " : " << b;
				}
				result << (is_first ? "}" : " }");
				return result.string;
			}
			case "S":
				return "{{ {} }}".format({ ", ".join(Sitems) });
			default:
				break;
			}
			break;
		case "O":
			/* TODO: Operator */
			break;
		default:
			break;
		}
		return docstring;
	}
}


class Parameter: weakrefable {

	@@The raw documentation string for this parameter
	@@Example: $"x:?Dint"
	public final member docstring: string;

	@@The declaration that @this parameter is apart of
	public final member docdecl: weakref with Declaration;

	@@The argument index of this parameter
	public final member docargi: int;

	this(d: Declaration | weakref with Declaration, argi: int, ds: string)
		: docdecl(d is weakref ? d : weakref(d))
		, docargi(argi)
		, docstring(ds)
	{}

	private member m_namstring: string; /* Already decoded (using decode_name) */
	private member m_typstring: string | none; /* in <TYPE> encoding */
	private member m_defstring: string | none; /* in <EXPR> encoding */
	private member m_isoptional: bool;
	private member m_isvarargs: bool;
	private member m_iskwargs: bool;

	@@Decode #docstring to extract information
	private decode_docstring() {
		m_isoptional = m_isvarargs = m_iskwargs = false;
		m_typstring = m_defstring = none;
		/* For backwards-compatibility, check for old-type parameter
		 * declarations in the form of `int x', something that we
		 * identify by searching for a non-escaped space-character,
		 * which we then interpret as the delimiter between name & type */
		local type_end = find_nonescaped(docstring," ");
		local doclen = #docstring;
		if (type_end >= 0) {
			/* Since old-style declarations were sometimes also written
			 * as `int x, int y', meaning we'd end up with " int y", we
			 * must repeat the check after stripping whitespace.
			 * However, since non-escaped whitespace isn't actually
			 * allowed as part of the new system, it should already
			 * be clear that we're dealing with a new-style parameter. */
			docstring = docstring.strip();
			doclen = #docstring;
			type_end = find_nonescaped(docstring," ");
			if (type_end >= 0) {
				m_typstring = docstring.substr(0,type_end);
				m_namstring = docstring.substr(type_end + 1).lstrip();
				/* Also check for a default argument. */
				if ("=" in m_namstring) {
					m_namstring,none,m_defstring = m_namstring.partition("=")...;
					m_namstring = m_namstring.strip();
					m_defstring = m_defstring.strip();
				}
				for (;;) {
					if (m_namstring.endswith("...")) {
						/* Old-style, typed varargs argument */
						m_namstring = m_namstring.substr(0,#m_namstring - 3).rstrip();
						m_isvarargs = true;
						m_iskwargs = m_isoptional = false;
						continue;
					}
					if (m_namstring.startswith("...")) {
						/* Old-style, typed varargs argument */
						m_namstring = m_namstring.substr(3).lstrip();
						m_isvarargs = true;
						m_iskwargs = m_isoptional = false;
						continue;
					}
					if (m_namstring.endswith("?")) {
						/* Old-style, typed optional argument */
						m_namstring = m_namstring.substr(0,#m_namstring - 1).rstrip();
						m_isoptional = true;
						m_iskwargs = m_isvarargs = false;
						continue;
					}
					if (m_namstring.startswith("?")) {
						/* Old-style, typed optional argument */
						m_namstring = m_namstring.substr(1).lstrip();
						m_isoptional = true;
						m_iskwargs = m_isvarargs = false;
						continue;
					}
					if (m_namstring.startswith("**")) {
						/* Old-style, typed optional argument */
						m_namstring = m_namstring.substr(2).lstrip();
						m_iskwargs = true;
						m_isvarargs = m_isoptional = false;
						continue;
					}
					break;
				}
				for (;;) {
					/* Old-style conventions also allowed
					 * the ... to appear as part of the type. */
					if (m_typstring.endswith("...")) {
						m_typstring = m_typstring.substr(0,#m_typstring - 3).rstrip();
						m_isvarargs = true;
						m_iskwargs = m_isoptional = false;
						continue;
					}
					if (m_typstring.endswith("**")) {
						m_typstring = m_typstring.substr(0,#m_typstring - 2).rstrip();
						m_iskwargs = true;
						m_isvarargs = m_isoptional = false;
						continue;
					}
					break;
				}
				return;
			}
		}
		if (!doclen) {
			/* Try to extract the argument name from varkwds information */
			m_namstring = get_generic_argument_name(docargi,
				docdecl.value.docsect.value.docnode.value);
			return;
		}
		/* Decode the parameter string new-style. */
		local name_end;
		if (docstring.issymstrt(0)) {
			/* Non-escaped argument name. */
			for (name_end = 1; name_end < doclen; ++name_end) {
				if (!docstring.issymcont(name_end))
					break;
			}
			m_namstring = docstring.substr(0,name_end);
		} else if (docstring[0] == "{") {
			/* Escaped argument name. */
			name_end = find_nonescaped(docstring,"}",1);
			if (name_end < 0)
				name_end = doclen;
			m_namstring = decode_name_content(docstring.substr(1,name_end));
			if (name_end < doclen)
				++name_end;
		} else {
			/* Parameter is unnamed. */
			m_namstring = get_generic_argument_name(docargi,
				docdecl.value.docsect.value.docnode.value);
			name_end = 0;
		}
		if (name_end >= doclen)
			return;
		switch (docstring[name_end]) {
		case "?":
			m_isoptional = true;
			++name_end;
			break;
		case "!":
			++name_end;
			if (name_end < doclen && docstring[name_end] == "!") {
				++name_end;
				m_iskwargs = true;
			} else {
				m_isvarargs = true;
			}
			break;
		default: break;
		}
		if (name_end >= doclen)
			return;
		if (docstring[name_end] == ":") {
			/* Argument type */
			++name_end;
			local typend = find_nonescaped(docstring,"=",name_end);
			if (typend >= 0) {
				/* Default expression */
				m_typstring = docstring.substr(name_end,typend);
				m_defstring = docstring.substr(typend + 1);
			} else {
				m_typstring = docstring.substr(name_end);
			}
			return;
		}
		if (docstring[name_end] == "=") {
			m_defstring = docstring.substr(name_end + 1);
			/* Try to determine the default value of the Parameter */
			if (m_typstring is none) {
				local types = tuple(defexpr.exprtypes);
				if (types) {
					if (#types == 1) {
						m_typ = types[0];
						/* An implicit non-argument should not be interpreted
						 * as the argument requiring to be typed as `none' */
						if (m_typ.isnone) {
							m_typstring = "?O";
							del m_typ;
						} else {
							m_typstring = m_typ.docstring;
						}
					} else {
						m_typstring = "?X{}{}".format({
							(#types),
							(for (local x: types) x.docstring) + ...
						});
					}
				}
			}
			return;
		}
		if (docstring.startswith("...",name_end)) {
			/* Old-style varargs suffing without explicit typing */
			m_isvarargs = true;
			m_iskwargs = m_isoptional = false;
			name_end += 3;
		}
		/* Undefined suffix... */
	}

	@@The decoded name of @this Parameter
	public final property name: string = {
		get(): string {
			if (m_namstring !is bound)
				decode_docstring();
			return m_namstring;
		}
	}

	@@The <TYPE>-encoded typing of @this Parameter
	@@When unspecified, evaluates to :none instead
	public final property typstring: string | none = {
		get(): string | none {
			if (m_typstring !is bound)
				decode_docstring();
			return m_typstring;
		}
	}

	@@A descriptor for the typing of @this parameter
	public final property typ: TypeExpr = {
		get(): TypeExpr {
			if (m_typ !is bound) {
				local typstr = typstring;
				if (typstr is none)
					typstr = "?O";
				m_typ = TypeExpr(docdecl,typstr);
			}
			return m_typ;
		}
	}
	private member m_typ: TypeExpr;

	@@Alias for ${this.typ.isaccepted(ob)}
	public final isaccepted(ob: object): bool {
		return typ.isaccepted(ob);
	}

	@@The <EXPR>-encoded default value of @this Parameter
	@@When unspecified, evaluates to :none instead
	public final property defstring: string | none = {
		get(): string | none {
			if (m_defstring !is bound)
				decode_docstring();
			return m_defstring;
		}
	}

	@@A descriptor for the default value of @this parameter
	@@When not given, default to :none
	public final property defexpr: Expression | none = {
		get(): Expression | none {
			if (m_defexpr !is bound) {
				local defstr = defstring;
				if (defstr is none)
					m_defexpr = none;
				else {
					if (!defstr) {
						/* Try to load the default value from the documented object. */
						local node = docdecl.lock(none)
							.docsect.lock(none)
							.docnode.lock(none);
						if (node !is none && node.object is bound) {
							local ob = node.object;
							if (ob is deemon.function_) {
								/* Extract from default argument list of user-level function */
								local code = ob.__code__;
								local argc_min = code.__argc_min__;
								if (docargi >= argc_min &&
								    docargi <  code.__argc_max__) {
									/* Default argument is available. */
									local val = code.__default__[docargi - argc_min];
									m_defexpr = Expression(docdecl,false,val);
									goto done;
								}
							}
						}
					}
					m_defexpr = Expression(docdecl,defstr);
				}
			}
done:
			return m_defexpr;
		}
	}
	private member m_defexpr: Expression | none;


	@@Evaluates to :true if @this Parameter is an optional argument
	public final property isoptional: bool = {
		get(): string | none {
			if (m_isoptional !is bound)
				decode_docstring();
			return m_isoptional;
		}
	}

	@@Evaluates to :true if @this Parameter is a varargs argument
	public final property isvarargs: bool = {
		get(): bool {
			if (m_isvarargs !is bound)
				decode_docstring();
			return m_isvarargs;
		}
	}

	@@Evaluates to :true if @this Parameter is a varkwds argument
	public final property isvarkwds: bool = {
		get(): bool {
			if (m_iskwargs !is bound)
				decode_docstring();
			return m_iskwargs;
		}
	}

	@@Returns A pretty, human-readable representation of this parameter
	operator str(): string {
		file.writer fp;
		if (isvarkwds)
			fp << "**";
		fp << name;
		if (isoptional)
			fp << "?";
		else if (isvarargs)
			fp << "...";
		fp << ": ";
		fp << typ;
		local def = defexpr;
		if (def !is none) {
			fp << " = " << def;
		}
		return fp.string;
	}

	@@Returns a string representation of how @this Parameter can be created
	operator repr(): string {
		return "Parameter({!r},{!r},{!r})".format({ docdecl.lock(none), docargi, docstring });
	}
}



@@Declaration descriptor for a function or field
class Declaration: weakrefable {

	@@The raw documentation string for this declaration
	@@Example: $"(x:?Dint)->?Dint"
	public final member docstring: string;

	@@The Doc section containing @this declaration
	public final member docsect: weakref with DocSection;

	@@True if @this Declaration is for an operator
	@@This is the case when the associated doc-node is a type,
	@@as operator declarations are made as part of the doc string
	@@of a type, rather than have their own storage locations.
	public final property isoperator: bool = {
		get(): bool {
			return docsect.value.docnode.value.istype;
		}
	}

	this(s: DocSection | weakref with DocSection, ds: string)
		: docsect(s is weakref ? s : weakref(s))
		, docstring(ds)
	{}

	private member m_parstring: string | none; /* Argument list */
	private member m_namstring: string | none;
	private member m_retstring: string | none;
	private member m_opname: string | none;
	private member m_isdeleted: bool;
	private member m_isinherited: bool;
	private member m_explittype: bool;

	@@Split #docstring into its individual segments
	private split_decl_string() {
		local ds = docstring;
		local par_start = find_nonescaped(ds,"(");
		local ret_start = ds.rfind("->");
		m_parstring = m_namstring = m_retstring = none;
		m_isdeleted = m_isinherited = m_explittype = false;
		if (par_start >= 0) {
			if (ret_start > 0 && ds[ret_start - 1] == ")")
				m_parstring = ds.substr(par_start + 1,ret_start - 1);
			else if (ds[#ds - 1] == ")")
				m_parstring = ds.substr(par_start + 1,#ds - 1);
		}
		if (par_start >= 0) {
			if (par_start > 0)
				m_namstring = ds.substr(0,par_start);
		} else if (ret_start > 0) {
			m_namstring = ds.substr(0,ret_start);
		}
		if (ret_start >= 0) {
			m_retstring = ds.substr(ret_start + 2);
			if (m_parstring is none) {
				if (m_retstring == "!D") { /* Deleted operator. */
					m_retstring = none;
					m_isdeleted = true;
					return;
				}
				if (m_retstring == "!S") { /* Inherited operator. */
					m_retstring = none;
					m_isinherited = true;
					return;
				}
				if (isoperator) {
					/* Generate default parameter information for operators */
					m_parstring = "";
					local defl = operator_defaults.get(opname);
					if (defl !is none) {
						local rt = defl.rfind("->");
						if (rt >= 0) {
							m_parstring = defl.substr(1,rt - 1);
							if (!m_retstring)
								m_retstring = defl.substr(rt + 2);;
						}
					}
				} else if (docsect.value.docnode.value.isfunction) {
					m_parstring = ""; /* Default to an empty argument list for functions */
				}
			}
			m_explittype = true;
			if (!m_retstring) {
				m_explittype = false;
				if (isoperator) {
					local defl = operator_defaults.get(opname);
					if (defl !is none) {
						local rt = defl.rfind("->");
						if (rt >= 0) {
							/* Generate default declaration information for operators */
							m_retstring = defl.substr(rt + 2);
						}
					}
				}
			}
		} else if (m_parstring is none) {
			/* Default to returning `object' when the parameter list was omitted. */
			m_retstring = "";
			if (isoperator) {
				local defl = operator_defaults.get(opname);
				if (defl !is none) {
					local rt = defl.rfind("->");
					if (rt >= 0) {
						/* Generate default declaration information for operators */
						m_retstring = defl.substr(rt + 2);
						m_parstring = defl.substr(1,rt - 1);
					}
				}
			}
		}
	}

	@@Returns the (paren-stripped) string associated with the argument list
	@@portion of @this Declaration. - If the declaration doesn't include an
	@@explicit argument list, :none is returned instead.
	public final property parstring: string | none = {
		get(): string | none {
			if (m_parstring !is bound)
				split_decl_string();
			return m_parstring;
		}
	}

	@@Returns the name of the declaration (as used to describe the name
	@@of an operator when encountered inside of a type-expression)
	@@If no such name has been defined, return :none instead.
	public final property namstring: string | none = {
		get(): string | none {
			if (m_namstring !is bound)
				split_decl_string();
			return m_namstring;
		}
	}

	@@Evaluates to :true if @this declaration refers to a member/operator
	@@that has been explicitly deleted and will throw a :NotImplemented
	@@error, should the user attempt to invoke it.
	public final property isdeleted: bool = {
		get(): bool {
			if (m_isdeleted !is bound)
				split_decl_string();
			return m_isdeleted;
		}
	}

	@@Evaluates to :true if @this declaration refers to an member/operator
	@@that has explicitly been inherited from a base-class.
	@@The most notable example of this is an inherited constructor, as
	@@can easily be achieved by user-code writing ${this = super;}
	public final property isinherited: bool = {
		get(): bool {
			if (m_isinherited !is bound)
				split_decl_string();
			return m_isinherited;
		}
	}

	@@Evaluates to :true if the return type of @this declaration has been
	@@explicitly defined. When :false, the return type was either implied
	@@as :object (when a return arrow was present, but no return type), or
	@@as automatically deduced (as done for operators, as well as for function
	@@prototypes implying a none-return type when a parameter list is given,
	@@but no return arrow was found)
	public final property istypeexplicit: bool = {
		get(): bool {
			if (m_explittype !is bound)
				split_decl_string();
			return m_explittype;
		}
	}

	@@Similar to @namstring, however automatically translate operator names
	public final property opname: string | none = {
		get(): string | none {
			if (m_opname !is bound) {
				local name = namstring;
				if (name is none)
					m_opname = "constructor";
				else {
					m_opname = operator_realname(name);
					/* Check if also need argument count to deduce the real operator name */
					if (m_opname is none)
						m_opname = operator_realname(name,#parameters);
				}
			}
			return m_opname;
		}
	}

	@@Returns the name of @this Declaration
	public final property name: string = {
		get(): string {
			local node = docsect.value.docnode.value;
			if (node.istype)
				return opname;
			return node.name;
		}
	}

	@@Returns the return expression string (as used to describe the typing
	@@of a member-like declaration, or the return type of a function-like one)
	@@If no type expression has been defined, return :none instead.
	@@Note when this evaluates to an empty string, `deemon.object' is returned.
	public final property retstring: string | none = {
		get(): string | none {
			if (m_retstring !is bound)
				split_decl_string();
			return m_retstring;
		}
	}

	@@Returns :true if the return type of @this declaration is always :none
	public final property returnsnone: bool = {
		get(): bool {
			local retstr = m_retstring;
			return retstr is none || retstr in ["?N","?Dnone","?Edeemon:none"];
		}
	}

	@@The return type of @this Declaration (i.e. the
	@@type expression found after the $"->" arrow)
	@@When #isdeleted is :true, this property evaluates
	@@to ${TypeExpr(...,"?N")} (aka. `none')
	public final property ret: TypeExpr = {
		get(): TypeExpr {
			if (m_typ !is bound) {
				local retstr = retstring;
				if (retstr is none)
					m_typ = TypeExpr(this,"?N");
				else if (!retstr)
					m_typ = TypeExpr(this,"?O");
				else {
					m_typ = TypeExpr(this,retstr);
				}
			}
			return m_typ;
		}
	}
	private member m_typ: TypeExpr;

	@@Split @parstring into the individual parameters described by it
	public final property parameters: {Parameter...} | none = {
		get(): {Parameter...} | none {
			if (m_parameters !is bound) {
				local parstr = parstring;
				if (parstr is none) {
					local doc = docsect.value.docnode.value;
					if (doc.isfunction)
						m_parameters = [Parameter(this,0,"args!")];
					else {
						m_parameters = none; /* No parameters */
					}
				} else {
					m_parameters = tuple(
						for (local i,part: util.enumerate(split_nonescaped(parstr,",")))
							Parameter(this,i,part));
				}
			}
			return m_parameters;
		}
	}
	private member m_parameters: {Parameter...} | none;

	@@Return a function parameter, given its name
	public final getparambyname(name: string): Parameter | none {
		for (local p: parameters) {
			if (p.name == name)
				return p;
		}
		return none;
	}

	@@If @this declaration is that of a function or operator, check if the
	@@type specifications of that function allow the given @args to be used
	@@in a call to the function or operator
	public final isaccepted(args...: object): bool {
		local par = parameters;
		if (par is none)
			return false;
		if (#args != #par) /* TODO: Varargs, optional, default, ... */
			return false;
		for (local i: [:#args]) {
			if (!par[i].isaccepted(args[i]))
				return false;
		}
		return true;
	}

	@@Returns @this declaration as a pretty, human-readable string
	operator str(): string {
		local name = this.name;
		if (isdeleted)
			return "{} = del".format({ name });
		if (isinherited)
			return "{} = super".format({ name });
		local par = this.parameters;
		if (par !is none) {
			if (returnsnone) {
				return "{}({})".format({
					name,
					", ".join(par),
				});
			} else {
				return "{}({}): {}".format({
					name,
					", ".join(par),
					ret
				});
			}
		}
		return "{}: {}".format({
			name,
			ret
		});
	}

	@@Returns a string representation of how @this Declaration can be created
	operator repr(): string {
		return "Declaration({!r},{!r})".format({ docsect.lock(none), docstring });
	}
}

class TextSegment: weakrefable {

	@@The raw documentation string for this text segment
	@@Example: $"(x:?Dint,y:?Dint)->?Dint\nAdd together 2 numbers"
	public final member docstring: string;

	@@The Doc section containing @this text segment
	public final member docsect: weakref with DocSection;

	this(s: DocSection | weakref with DocSection, ds: string)
		: docsect(s is weakref ? s : weakref(s))
		, docstring(ds)
	{}

	/* TODO: Standartize documentation text section formatting
	 *       Now that the job of creating doc strings has been off-loaded onto
	 *       the compiler, we could (in theory) get rid of all those different
	 *       special tags which may appear in doc texts, and instead unify
	 *       everything to use some kind of compiler-generated symbol addressing
	 *       syntax, which could then make use of compile-time symbol resolution
	 *       to remove all of the complexity that is currently required to referr
	 *       to different types of symbols.
	 *       Resolution itself should then happen in the context of the function
	 *       being documented, thus allowing
	 * Proposal:
	 *   Use `@' for this purpose. - `@' is already used in GATW's assembly
	 *   implementation in order to inline user-level expressions within operands.
	 *   An example use of this could then look like this:
	 *
	 * >> import * from deemon;
	 * >> import util;
	 * >>
	 * >> @@Take 2 argument @x and @y and return the lower of the 2
	 * >> @@This is done through use of @(min from util), re-using
	 * >> @@its @int-typed return value to return from this function.
	 * >> function myfunc(x: int, y: int): int {
	 * >>     return util.min(x,y);
	 * >> }
	 *
	 * The idea here is that when the compiler generates the TextSegment-part
	 * of the associated documenation string, it can resolve those identifiers
	 * in relation to where they appear in the actual source-file.
	 * CON:
	 *   - This would interfere with user-doc function tags,
	 *     such as `@throws Foo' or @param / @arg
	 *     This could be prevented by having special behavior when @
	 *     appears at the start of a line, but now it's starting to
	 *     look really ugly:
	 *     >> @@Description goes here
	 *     >> @@@param x An integer value
	 *     >> @@@param y An integer value
	 *     >> @@@return The lower of @x and @y
	 *     >> function myfunc(x: int, y: int): int {
	 *     >>     return util.min(x,y);
	 *     >> }
	 *   - This uglyness however has already become inadvertible ever-since
	 *     the (still good & correct) decision was made to move from @"..."
	 *     like doc strings to instead use @@...<LF>, which is something that
	 *     looks way better.
	 */

	@@Returns #docstring
	operator str(): string {
		return docstring;
	}

	@@Returns a string representation of how @this TextSegment can be created
	operator repr(): string {
		return "TextSegment({!r},{!r})".format({ docsect.lock(none), docstring });
	}

}


@@Split the text of a :DocSection into a sequence of :{Declaration}s and :{TextSegment}s
local function split_section(sect: DocSection, docstring: string): {Declaration | TextSegment...} {
	local start = 0;
	while (docstring.startswith("(",start)) {
		/* The first line is already is one that is special */
		local newstart = find_nonescaped(docstring,"\n",start);
		if (newstart < 0) newstart = #docstring;
		yield Declaration(sect,docstring.substr(start,newstart));
		start = newstart + 1;
	}
	for (;;) {
		local i = docstring.find("\n(",start);
		local j = docstring.find("->",start);
		if (i < 0) {
			if (j < 0)
				break;
			i = rfind_nonescaped(docstring,"\n",start,j);
			if (i < 0) i = start;
		} else {
			++i;
			if (j >= 0 && j < i) {
				i = rfind_nonescaped(docstring,"\n",start,j);
				if (i < 0) i = start;
			}
		}
		if (i - 1 > start)
			yield TextSegment(sect,decode_text(docstring.substr(start,i - 1)));
		local line_end = find_nonescaped(docstring,"\n",i);
		if (line_end < 0) line_end = #docstring;
		yield Declaration(sect,docstring.substr(i,line_end));
		start = line_end + 1;
	}
	if (start < #docstring)
		yield TextSegment(sect,decode_text(docstring.substr(start)));
}


class DocSection: weakrefable {

	@@The raw documentation string for this doc section
	public final member docstring: string;

	@@The Doc node of which this is a section.
	@@NOTE: For operator DocSections, this refers to the type node, not the operator node!
	public final member docnode: weakref with Doc;

	this(d: Doc | weakref with Doc, ds: string)
		: docnode(d is weakref ? d : weakref(d))
		, docstring(ds)
	{}

	@@Enumerate all operator sections contained within this DocSection
	@@as tuples of (operator_name: string, section: DocSection)
	public final enumerate_opsections(): {(string,DocSection)...} {
		local seg = segments;
		for (local i = 0; i < #seg; ++i) {
			local s = seg[i];
			if (s !is Declaration)
				continue;
			local opname = s.opname;
			if (opname is none)
				continue;
			local result_segments = [s];
			for (local j = i + 1; j < #seg; ++j) {
				s = seg[j];
				if (s is Declaration/* && s.opname != opname*/)
					continue;
				result_segments.append(s);
			}
			if (#result_segments == #m_segments) {
				yield (opname,this);
				return;
			}
			local result = DocSection(docnode,
				"\n".join(
					for (local x: result_segments)
						x.docstring));
			result.m_hasdecls = true;
			result.m_segments = result_segments;
			yield (opname,result);
		}
	}


	@@Check if @this DocSection contains a declaration for a given operator @name
	@@If it does, return a new DocSection containing all of the associated
	@@sub-segments containing information about that operator.
	public final getopsection(name: string): {DocSection...} | none {
		local seg = segments;
		for (local i = 0; i < #seg; ++i) {
			local s = seg[i];
			if (s !is Declaration)
				continue;
			if (s.opname != name)
				continue;
			local result_segments = [s];
			for (local j = i + 1; j < #seg; ++j) {
				s = seg[j];
				if (s is Declaration/* && s.opname != opname*/)
					continue;
				result_segments.append(s);
			}
			if (#result_segments == #m_segments) {
				yield this;
				return;
			}
			local result = DocSection(docnode,
				"\n".join(
					for (local x: result_segments)
						x.docstring));
			result.m_hasdecls = true;
			result.m_segments = result_segments;
			yield result;
		}
	}

	@@Returns @docstring
	operator str(): string {
		return docstring;
	}

	@@Returns a string representation of how @this DocSection can be created
	operator repr(): string {
		return "DocSection({!r},{!r})".format({ docnode.lock(none), docstring });
	}

	@@Evalues to :true if @this DocSection contains declaration segments
	public final property hasdeclarations: bool = {
		get() {
			if (m_hasdecls !is bound) {
				for (local seg: segments) {
					if (seg !is Declaration)
						continue;
					m_hasdecls = true;
					return true;
				}
				m_hasdecls = false;
			}
			return m_hasdecls;
		}
	}
	private member m_hasdecls: bool;

	@@Split @this DocSection into segments of special doc-strings & human-text
	@@The returned tuple is (is_declaration,content), where is_declaration is
	@@a line applicable to contain either the "->" or the "<START_OF_LINE>("
	@@pattern.
	public final property segments: {Declaration | TextSegment...} = {
		get() {
			if (m_segments !is bound)
				m_segments = tuple(split_section(this,docstring));
			return m_segments;
		}
	}
	private member m_segments: {Declaration | TextSegment...};
}



@@Automatically generate documentation for a given @fun
local function generate_function_params(fp: file, fun: deemon.function_) {
	/* We can actually figure out a lot about this function! */
	local code = fun.__code__;
	local argc_min = code.__argc_min__;
	local argc_max = code.__argc_max__;
	local kwds = code.__kwds__;
	local n_kwds = #kwds;
	fp << "(";
	for (local i: [:argc_min]) {
		if (i != 0)
			fp << ",";
		if (i < n_kwds) {
			fp << kwds[i];
		} else {
			fp << get_generic_argument_name(i);
		}
	}
	if (argc_max > argc_min) {
		local defl = code.__default__;
		if (argc_min)
			fp << ",";
		for (local i: [:argc_max - argc_min]) {
			if (i != 0)
				fp << ",";
			if (i < n_kwds) {
				fp << kwds[i];
			} else {
				fp << get_generic_argument_name(i);
			}
			if (defl[i] !is bound) {
				fp << "?";
			} else {
				local default_value = defl[i];
				/* Only emit type information when the default value isn't none
				 * Since `none' is usually used as a placeholder, the user probably
				 * doesn't expect the user of this function to pass `none' intentionally. */
				if (default_value !is none)
					fp << ":" << encode_type(type(default_value));
				local defl = encode_expr(default_value);
				if (defl !is none)
					fp << "=" << defl;
			}
		}
	}
	if (code.hasvarargs) {
		if (argc_max)
			fp << ",";
		fp << (argc_max < n_kwds
			? kwds[argc_max]
			: get_generic_argument_name(argc_max))
			<< "!";
	}
	fp << ")";
}



@@The main interface for accessing the documentation API provided by deemon
@@Documentation text is addressed using unambiguos paths structures as follows:
@@
@@The string is split into segments seperated by ${"/"}
@@
@@Dangling leading and trailing slashes are ignored.
@@
@@The first segment is a module name that describes which module to search
@@for the documenation strings. If no slash follows, the Doc node will refer
@@to that module as a whole
@@
@@Otherwise, the remaining segment are walked left-to-right and used to dereference
@@attribute names of their respective object.
@@
@@These attributes can optionally be prefixed with one of the following
@@modifiers in order to address different attributes namespaces:
@@
@@%{table Prefix|Description
@@$""|The attribute is either a class-attribute, or an instance-attribute (may lead to ambiguity when a name is re-used, such as by :dict.c:keys and :dict.i:keys)"
@@$"c:"|The attribute is a class-attribute (e.g. ${string.chr})
@@$"i:"|The attribute is a instance-attribute (e.g. ${string.find})
@@$"op:"|The attribute is a real operator name (e.g. ${"eq"} instead of ${"=="})}
@@
@@Furthermore, child-nodes (attributes) can be reached using #child, and all existing
@@child nodes can be enumerated by using the doc-node as a sequence-like object.
@@
@@Some restrictions apply to Doc-nodes, most notably the restriction that the object
@@being documented must somehow by addressible as a module export, meaning that private (local)
@@functions or classes usually cannot be addressed, and that builtin objects used by the
@@deemon core, which aren't actually exported from the builtin deemon module cannot be
@@addressed without the use of the :rt module.
class Doc: weakrefable {

	@@A universally, unique path that can be used to address this Doc item
	@@NOTE: If the path cannot be determined, return :none instead
	@@NOTE: The returned path includes a leading $"/"
	public final property path: string | none = {
		get(): string {
			if (m_path !is bound) {
				local par = parent;
				if (par is none) {
					m_path = ismodule ? "/" + name : none;
				} else {
					par = parent.path;
					m_path = par is none
						? none
						: "{}/{}".format({ par, name });
				}
			}
			return m_path;
		}
	}
	private member m_path: string | none;

	@@Similar to @path, but return the qualified path in <TYPE> encoding
	@@NOTE: Because <TYPE> encoding includes support for untracable components,
	@@      this property always evaluates to a string and simply uses
	@@      the ?U encoding when the qualified path cannot be determined.
	public final property qualpath: string = {
		get(): string {
			if (m_qualified_path !is bound) {
				local par = parent;
				if (par is none)
					m_qualified_path = "?U" + encode_name(name);
				else if (par.ismodule) {
					m_qualified_path = "?E{}:{}".format({
						/* TODO: This only works for global modules! */
						encode_name(par.name),
						encode_name(name),
					});
				} else {
					m_qualified_path = "?A{}{}".format({
						encode_name(name),
						par.qualpath,
					});
				}
			}
			return m_qualified_path;
		}
	}
	private member m_qualified_path: string;

	@@The name of this documentation object (last component of #path, stripped of its namespace prefix)
	@@Note the namespace prefix will have already been stripped from this string, though
	@@its typing can be recreated with the attributes #isclassattr and #isoperator
	public final member name: string;

	@@Returns the name of type, or #name if #istype is :false, or if the type is anonymous
	public final property typename: string = {
		get(): string {
			local result = none;
			if (istype && object is bound)
				result = deemon.type_.__name__(object);
			return result is none ? name : result;
		}
	}

	@@Similar to #name, but if @this Doc node is an operator, return
	@@that operator's name in the form of $"==", rather than $"eq"
	public final property prettyname: string = {
		get(): string {
			if (isoperator) {
				local res = pretty_operator_names.get(name);
				if (res !is none)
					return res;
			}
			return name;
		}
	}

	@@Similar to #prettyname, but include an $"operator"
	@@prefix when @this Doc node describes an operator.
	public final property prettypathname: string = {
		get(): string {
			if (isoperator) {
				local res = pretty_operator_names.get(name);
				if (res !is none)
					return "operator " + res;
			}
			return name;
		}
	}

	@@Similar to #prettyname, but also include the node kind,
	@@resulting in the form of $"operator ==" or "function foo"
	public final property prettydesc: string = {
		get(): string {
			return "{} {}".format({
				kind,
				prettyname
			});
		}
	}

	@@Similar to #path, but return in a form akin to $"deemon.string.operator =="
	@@Additionally, this name representation still provides good-looking results
	@@when #path would evaluate to :none
	public final property prettypath: string = {
		get(): string {
			local result = path;
			if (result is none) {
				local par = parent;
				if (par is none) {
					result = name;
					if (isoperator)
						result = "operator " + pretty_operator_names.get(name,name);
					return result;
				}
				result = par.prettypath;
				if (isoperator) {
					result = "{}.operator {}".format({
						result,
						pretty_operator_names.get(name,name)
					});
				} else {
					result = "{}.{}".format({ result, name });
				}
				return result;
			}
			result = result.lstrip("/").replace("i:","").replace("c:","");
			if (isoperator) {
				result = result.rpartition("/")[0];
				result = "{}.operator {}".format({
					result,
					pretty_operator_names.get(name,name)
				});
			}
			return result.replace("/",".");
		}
	}

	@@The object represented by @this Doc node (May be unbound)
	public final member object;
	public final property attr: attribute | none = {
		get(): attribute | none {
			if (m_attr !is bound) {
				if (isoperator || parent is none)
					m_attr = none;
				else {
					m_attr = deemon.attribute(parent.object,name);
				}
			}
			return m_attr;
		}
	}
	private member m_attr: attribute | none;

	@@The parent doc, or :none when unknown or @this
	@@Doc node is already a top-level module node
	public property parent: Doc | none = {
		get(): Doc | none {
			if (m_parent !is Doc && m_parent !is none)
				m_parent = Doc(m_parent);
			return m_parent;
		}
	}
	private member m_parent: Doc | none;

	@@The raw documentation text associated with this node
	@@If no documentation string could be located, this is an empty string
	public final member docstring: string;

	@[gatw.doc("(path:?Dstring)")]
	@[gatw.doc("Lookup a given @path in the form \"/<module>/<x>/<y>/<z>\"")]
	@[gatw.doc("")]
	@[gatw.doc("(mod:?Dmodule)")]
	@[gatw.doc("Lookup the Doc node for a given module")]
	@[gatw.doc("")]
	@[gatw.doc("(tp:?Dtype)")]
	@[gatw.doc("Lookup the Doc node for a given type")]
	@[gatw.doc("")]
	@[gatw.doc("(attr:?Dattribute)")]
	@[gatw.doc("Lookup the Doc node for a given attribute")]
	@[gatw.doc("")]
	@[gatw.doc("(wrapper)")]
	@[gatw.doc("Lookup the Doc node for a wrapper, as produced by expressions such as ${string.lower}")]
	@[gatw.doc("")]
	@[gatw.doc("(base:?Dmodule,attrname:?Dstring)")]
	@[gatw.doc("(base:?Dtype,attrname:?Dstring)")]
	@[gatw.doc("(base:?GDoc,attrname:?Dstring)")]
	@[gatw.doc("(base,attrname:?Dstring)")]
	@[gatw.doc("Lookup a given @attrname as a child of a given @base")]
	this(doc_parent_or_path, attribute_name?: deemon.attribute | string, operator_doc?: {DocSection...}) {
		if (attribute_name !is bound) {
			if (doc_parent_or_path is deemon.module) {
				/* Doc(module) */
				object    = doc_parent_or_path;
				m_attr    = none;
				docstring = "";
				m_parent  = none;
				name = deemon.module.__name__(doc_parent_or_path);
				return;
			}
			if (doc_parent_or_path is deemon.type_) {
				/* Doc(type) */
				local type_module;
load_type_input:
				object = doc_parent_or_path;
				m_parent = type_module = deemon.type_.__module__(doc_parent_or_path);
				docstring = deemon.type_.__doc__(doc_parent_or_path).rstrip();
				istype = true;
				name = deemon.type_.__name__(doc_parent_or_path);
				if (type_module is none) {
					m_attr = none;
					m_path = none;
				} else {
					m_attr = deemon.attribute.lookup(type_module,name);
					if (m_attr is none) {
						module;
						m_parent = none;
						m_path = none;
					} else {
						m_path = "/{}/{}".format({ deemon.module.__name__(type_module), name });
					}
				}
				return;
			}
			if (doc_parent_or_path is deemon.attribute) {
				/* Doc(attribute) */
				name = doc_parent_or_path.name;
				local ds = doc_parent_or_path.doc;
				if (ds is none)
					ds = "";
				docstring = ds.rstrip();
				local decl = m_parent = doc_parent_or_path.decl;
				if (doc_parent_or_path.isclass) {
					local parob = decl;
					if (doc_parent_or_path.isinstance) {
						/* Use `type.getinstanceattr' to prevent ambiguity
						 * between stuff like `dict.c:keys' and `dict.i:keys' */
						object = deemon.type_.getinstanceattr(parob,name);
					} else {
						object = parob.operator . (name);
					}
				}
				m_attr = doc_parent_or_path;
				return;
			}
			/* Support for attribute wrappers */
			if (doc_parent_or_path !is string) {
				/* Check for singleton-like object instances. */
				local tp = type doc_parent_or_path;
				if (deemon.type_.__issingleton__(tp)) {
					doc_parent_or_path = tp;
					goto load_type_input;
				}
				name = doc_parent_or_path.__name__;
				local ds = doc_parent_or_path.__doc__;
				if (ds is none)
					ds = "";
				docstring = ds.rstrip();
				object = doc_parent_or_path;
				if (deemon.hasattr(doc_parent_or_path,"__type__")) {
					local doc_type;
					try {
						doc_type = doc_parent_or_path.__type__;
					} catch (Error.AttributeError) {
						goto do_load_wrapper_module;
					}
					if (doc_type is none)
						goto do_load_wrapper_module;
					m_parent = doc_type;
				} else {
do_load_wrapper_module:
					local mod;
					try {
						mod = doc_parent_or_path.__module__;
					} catch (Error.AttributeError) {
						goto do_throw_unknown_object_origin;
					}
					if (mod is none) {
do_throw_unknown_object_origin:
						throw Error.AttributeError(
							"Failed to determine the declaring type or module of {!r}".
							format({ doc_parent_or_path }));
					}
					m_parent = mod;
				}
				return;
			}
			local head,none,tail = doc_parent_or_path.strip("/ ").rpartition("/")...;
			if (!tail) {
				/* Module documentation */
				if (head.startswith(".")) {
					throw Error.ValueError(
						"Module name {!r} is not absolute"
						.format({ head }));
				}
				object    = import(head);
				m_parent  = none;
				m_attr    = none;
				docstring = ""; /* XXX: Module documentation texts? */
				m_path    = "/" + head;
				name      = head;
				return;
			}
			doc_parent_or_path = Doc(head);
			attribute_name     = tail;
		}
		if (doc_parent_or_path !is Doc)
			doc_parent_or_path = Doc(doc_parent_or_path);
		local fixed_attribute_name;
		if (!doc_parent_or_path.haschildren) {
			if (attribute_name.startswith("op:")) {
				attribute_name = attribute_name[3:];
err_unknown_operator:
				throw Error.AttributeError(
					"Unknown operator {!r} in {!r}".format({
						attribute_name,
						doc_parent_or_path.path
					})
				);
			}
			fixed_attribute_name = attribute_name.lsstrip("i:").lsstrip("c:");
err_unknown_attribute:
			throw Error.AttributeError(
				"Unknown attribute {!r} in {!r}".format({
					fixed_attribute_name,
					doc_parent_or_path.path
				})
			);
		}
		m_parent = doc_parent_or_path;
		local my_attr;
		if (attribute_name is deemon.attribute) {
			my_attr = attribute_name;
			fixed_attribute_name = attribute_name.name;
			attribute_name = "{}{}".format({
				attribute_name.isinstance ? "i:" :
				attribute_name.isclass ? "c:" : "",
				fixed_attribute_name
			});
		} else if (attribute_name.startswith("op:")) {
			/* Operator node. */
			local parpath = doc_parent_or_path.path;
			if (parpath is none) {
				m_path = none;
			} else {
				m_path = "{}/{}".format({
					parpath,
					attribute_name
				});
			}
			attribute_name = name = attribute_name[3:];
			isoperator = true;
			local sect;
			if (operator_doc is bound) {
				/* Caller-provided documentation string */
				sect = tuple(operator_doc);
			} else {
				/* Manually lookup the doc section associated with this operaotr. */
				sect = tuple(doc_parent_or_path.getopdoc(attribute_name));
				if (!sect)
					goto err_unknown_operator;
			}
			m_docsections = m_allsections = sect;
			docstring = "\n\n".join(
				for (local s: sect)
					s.docstring
			).rstrip();
			return;
		} else {
			try {
				if (attribute_name.startswith("i:")) {
					fixed_attribute_name = attribute_name[2:];
					my_attr = deemon.attribute(doc_parent_or_path.object,fixed_attribute_name,"i");
				} else if (attribute_name.startswith("c:")) {
					fixed_attribute_name = attribute_name[2:];
					my_attr = deemon.attribute(doc_parent_or_path.object,fixed_attribute_name,"i","");
				} else {
					fixed_attribute_name = attribute_name;
					my_attr = deemon.attribute(doc_parent_or_path.object,fixed_attribute_name);
				}
			} catch (Error.AttributeError) {
				goto err_unknown_attribute;
			}
		}
		assert operator_doc !is bound;
		assert my_attr is bound;
		assert my_attr is deemon.attribute;
		if (!my_attr.isprivate && !my_attr.isproperty) {
			local parob = doc_parent_or_path.object;
			if (parob is deemon.type_) {
				if (my_attr.isclass) {
					if (my_attr.isinstance) {
						/* Use `type.getinstanceattr' to prevent ambiguity
						 * between stuff like `dict.c:keys' and `dict.i:keys' */
						object = deemon.type_.getinstanceattr(parob,fixed_attribute_name);
					} else {
						try {
							object = parob.operator . (fixed_attribute_name);
						} catch (Error.AttributeError) {
						}
					}
				}
			} else if (my_attr.isinstance) {
				try {
					object = parob.operator . (fixed_attribute_name);
				} catch (Error.RuntimeError.UnboundLocal) {
				}
			}
		}
		/* Types implement their own documentation strings. */
		if (object is bound) {
			if (object is deemon.type_) {
set_is_type:
				docstring = deemon.type_.__doc__(object).rstrip();
				istype = true;
			} else if (deemon.type_.__issingleton__(type object)) {
				/* When accessing the documentation of a singleton object instance
				 * (as indicated by us having an instance of that singleton, when its
				 * type offers no way of being constructed; `this = del'), display
				 * documentation for the type instead of the singleton */
				object = type object;
				issingleton = true;
				goto set_is_type;
			}
		}
		local tp = my_attr.attrtype;
		if (tp !is none && deemon.type_.derivedfrom(tp,deemon.type_))
			istype = true;
		/* If we couldn't load a non-empty doc string from other places,
		 * try to load the doc string from the attribute descriptor. */
		if (docstring !is bound || !docstring)
			docstring = my_attr.doc.rstrip();
		m_attr = my_attr;
		name = fixed_attribute_name;
		local parpath = doc_parent_or_path.path;
		if (parpath is none) {
			m_path = none;
		} else {
			m_path = "{}/{}".format({
				parpath,
				attribute_name
			});
		}
	}

	@@Returns a string representation of how @this Doc node can be constructed
	operator repr(): string {
		return "Doc({!r})".format({ path });
	}

	@@Returns :true if @this doc node has allowed to referr to child nodes
	public final property haschildren: bool = {
		get() {
			if (object is bound) {
				if (object is deemon.module)
					return true;
				if (object is deemon.type_)
					return true;
			}
			return false;
		}
	}

	@@Evaluates to :true if the object is function-like
	public final property isfunction: bool = {
		get() {
			if (isoperator)
				return true;
			local at = attr;
			if (at !is none && (at.cancall || callable.baseof(at.attrtype)))
				return true;
			return object is bound && object is callable;
		}
	}

	@@Evaluates to :true if the object is private to its class
	public final property isprivate: bool = {
		get() {
			local at = attr;
			return at !is none && at.isprivate;
		}
	}

	@@Evaluates to :true if the object is a class-attribute
	public final property isclassattr: bool = {
		get() {
			local at = attr;
			return at !is none && !attr.isinstance;
		}
	}

	@@Evaluates to :true if the object is a module
	public final property ismodule: bool = {
		get() {
			return object is bound && object is deemon.module;
		}
	}

	@@Evaluates to :true if the object is a type
	public final member istype: bool = false;

	@@Evaluates to :true if the object is a type, but was accessed via a singleton
	@@An example of this is :deemon.gc or :none, which are both singleton objects
	@@that, when accessed via Doc, should display the documentation of their
	@@respective type, rather than what little text may be available for the
	@@single instance itself.
	@@Since such Doc nodes would otherwise be indistinguishable from nodes created
	@@for the actual types, nodes create via a singleton instance have this field
	@@set to :true
	public final member issingleton: bool = false;

	@@Evaluates to :true if the object is an operator
	public final member isoperator: bool = false;



	@@Returns the kind of node, which is one of the following
	@@%{table Name|Description
	@@$"module"|The node refers to a module
	@@$"type"|The node refers to a type
	@@$"singleton"|The node refers to a type accessed via a singleton
	@@$"functionThe node refers to a function
	@@$"class_function"|The node refers to a class-function
	@@$"member"|The node refers to a member or global module-variable
	@@$"class_member"|The node refers to a class-member
	@@$"property"|The node refers to a property
	@@$"class_property"|The node refers to a class-property
	@@$"operator"|The node refers to an operator
	@@$none|The node kind could not be determined}
	public final property kind: string | none = {
		get(): string | none {
			local at;
			if (istype)
				return issingleton ? "singleton" : "type";
			if (object !is bound) {
				at = attr;
				if (at is none)
					return "operator";
			} else {
				if (object is deemon.module)
					return "module";
			}
			if (at !is bound)
				at = attr;
			if (at !is none) {
				if (at.isproperty)
					return at.isinstance ? "property" : "class_property";
				if (at.cancall || callable.baseof(at.attrtype))
					return at.isinstance ? "function" : "class_function";
				return at.isinstance ? "member" : "class_member";
			}
			return none;
		}
	}

	@@Returns the module-node (i.e the path-base-node) of this node
	@@If the module could not be determined, return :none instead
	public final property modulenode: Doc | none = {
		get() {
			local x = this;
			for (;;) {
				if (x.parent !is none) {
					x = x.parent;
					continue;
				}
				if (x.ismodule)
					return x;
				break;
			}
			x = this;
			for (;;) {
				if (x.istype && x.object is bound) {
					local mod = deemon.type_.__module__(x.object);
					if (mod !is none)
						return Doc(mod);
				}
				if (x.parent is none)
					break;
			}
			return none;
		}
	}

	@@Returns the module (i.e the path-base) of this node
	@@If the module could not be determined, return :none instead
	public final property module: deemon.module | none = {
		get() {
			local x = this;
			for (;;) {
				if (x.parent !is none) {
					x = x.parent;
					continue;
				}
				if (x.ismodule)
					return x.object;
				break;
			}
			x = this;
			for (;;) {
				if (x.istype && x.object is bound) {
					local mod = deemon.type_.__module__(x.object);
					if (mod !is none)
						return mod;
				}
				if (x.parent is none)
					break;
			}
			return none;
		}
	}

	@@Enable support for sorting of doc-nodes
	operator < (other: Doc): bool {
		local my_kind = kind;
		local ot_kind = other.kind;
		if (my_kind != ot_kind) {
			return
				kind_sorting_weights.get(my_kind,0) <
				kind_sorting_weights.get(ot_kind,0);
		}
		if (my_kind == "operator") {
			return
				operator_sorting_weights.get(name,0) <
				operator_sorting_weights.get(other.name,0);
		}
		return name < other.name;
	}

	@@Returns the type of the base class of @this node, or :none if @this node isn't a type, or if that type doesn't have a base.
	public final property objectbase: deemon.type_ | none = {
		get(): deemon.type_ | none {
			if (object !is bound ||
				object !is deemon.type_)
				return none;
			return deemon.type_.__base__(object);
		}
	}

	@@Returns the doc-node for #objectbase
	public final property objectbasenode: Doc | none = {
		get(): Doc | none {
			local base = objectbase;
			if (base is none)
				return none;
			return Doc(base);
		}
	}

	@@Returns a set of all the declarations known for this node
	@@For type nodes, this is always an empty sequence, as operator
	@@declarations must be accessed via their individual nodes.
	public final property decls: {Declaration...} = {
		get(): {Declaration...} {
			for (local sect: docsections) {
				for (local seg: sect.segments) {
					if (seg is Declaration)
						yield seg;
				}
			}
		}
	}

	@@Return a function-like declaration found in the documenation
	@@of @this Doc node that matches the given argument list.
	@@If no such declaration could be found, return :none instead.
	public final declfor(args...: object): Declaration | none {
		for (local d: decls)
			if (d.isaccepted(args...))
				return d;
		return none;
	}


	@@Check if one of @this doc's declarations accepts the given argument list.
	@@>function foo(x: int | string, y: int | float) {
	@@>}
	@@>print Doc(foo).isaccepted(10,20);      /* true */
	@@>print Doc(foo).isaccepted(10,1.0);     /* true */
	@@>print Doc(foo).isaccepted(10,"foo");   /* false */
	@@>print Doc(foo).isaccepted("bar",20);   /* true */
	@@>print Doc(foo).isaccepted("bar",1.0);  /* true */
	@@>print Doc(foo).isaccepted();           /* false */
	public final isaccepted(args...: object): bool {
		return declfor(args...) !is none;
	}

	@@Similar to @isaccepted, but return the type expression
	@@what gets returned by the declaration capable of accepting
	@@the given argument list.
	@@NOTE: This function does not actually perform a call!
	@@      It merely emulates the call and returns the type
	@@      expression describing the set of types possibly
	@@      returned by it.
	@@>import * from deemon;
	@@>import * from doc;
	@@>function foo(x: int, y: float): string | int {
	@@> if (y == 0)
	@@>  return x;
	@@> return str(x + y);
	@@>}
	@@>print repr Doc(foo).callwith(10,1.0).types; /* { int, string } */
	public final callwith(args...: object): TypeExpr | none {
		return declfor(args...).ret;
	}


	@@Returns a sequence of all sections found on the documenation of #docstring
	public final property allsections: {DocSection...} = {
		get(): {DocSection...} {
			if (m_allsections !is bound) {
				m_allsections = [];
				for (local x: split_doc_sections(docstring))
					m_allsections.append(DocSection(this,x));
			}
			return m_allsections;
		}
	}
	private member m_allsections: {DocSection...};

	@@Auto-generate declaration information for an operator `opname'
	private final autogenerate_opdecl(opname: string): {DocSection...} {
		local defl = operator_defaults.get(opname);
		if (defl !is none)
			yield DocSection(this,opname + defl);
	}

	@@Autogenerate declarations for @this Doc node
	private autogenerate_decls(): {DocSection...} {
		if (isoperator) {
			yield parent.autogenerate_opdecl(name)...;
		} else if (object is bound && object is deemon.function_) {
			file.writer resdoc;
			generate_function_params(resdoc,object);
			if (object.__code__.isconstructor) {
				/* Constructors always return :none */
			} else {
				resdoc << "->";
			}
			yield DocSection(this,resdoc.string);
		} else {
			local at = attr;
			if (at !is none) {
				local attr_type = at.attrtype;
				if (at.cancall || callable.baseof(attr_type))
					yield DocSection(this,"(args!)->"); /* Some kind of function... */
				else if (attr_type !is none)
					yield DocSection(this,"->" + encode_type(attr_type));
				else {
					yield DocSection(this,"->");
				}
			} else {
				yield DocSection(this,"->");
			}
		}
	}

	@@Returns a sequence of split documentation sections, as found within #docstring
	@@The sections returned by this function are those that should be listed to give
	@@an overview of the object being documented, essentially meaning that for types,
	@@documentation concerning operators is left omitted, while also adding automatic
	@@documentation for anything that doesn't already offer anything, auto-creating
	@@docs for functions and members.
	public final property docsections: {DocSection...} = {
		get(): {DocSection...} {
			if (m_docsections !is bound) {
				local result = allsections;
				if (istype) {
					local new_result = [];
					/* Filter out operator docs. (aka: any section containing declarations) */
					for (local sect: result) {
						if (!sect.hasdeclarations)
							new_result.append(sect);
					}
					result = new_result;
				} else {
					local has_desc = false;
					for (local sect: result) {
						if (sect.hasdeclarations) {
							has_desc = true;
							break;
						}
					}
					if (!has_desc) {
						/* Without any pre-defined declaration, autogenerate some. */
						local new_result;
						new_result = list(autogenerate_decls());
						new_result.extend(result);
						result = new_result;
					}
				}
				m_docsections = result;
			}
			return m_docsections;
		}
	}
	private member m_docsections: {DocSection...};

	@@Automatically generate documentation for native type constructors.
	private autogenerate_native_constructor_desc(): {DocSection...} {
		if (deemon.type_.__issuperconstructible__(object)) {
			yield DocSection(this,"constructor->!S");
		} else {
			local hasany = false;
			if (deemon.type_.__isnoargconstructible__(object)) {
				yield DocSection(this,"constructor()->");
				hasany = true;
			}
			if (deemon.type_.__isvarargconstructible__(object)) {
				yield DocSection(this,"constructor->");
				hasany = true;
			}
			if (!hasany)
				yield DocSection(this,"constructor->!D");
		}
	}


	@@Returns the DocSection associated with a given @opname, which
	@@must be the operator's real name (e.g. $"eq", and not $"==")
	@@If the operator is implemented, but doesn't have an explicit
	@@section defined within the associated type's doc string, a
	@@documenation string for the operator will be generated automatically,
	@@including specific information about deleted operators.
	public final getopdoc(opname: string): {DocSection...} {
		if (!istype)
			return;
		local found_sections = false;
		for (local sect: allsections) {
			for (local os: sect.getopsection(opname)) {
				yield os;
				found_sections = true;
			}
		}
		if (!found_sections) {
			/* If the type implements or explicitly deletes the
			 * specified operator, auto-generate a doc for it. */
			if (object !is bound)
				return;
			if (deemon.type_.__isclass__(object)) {
				local cls = deemon.type_.__class__(object);
				/* Check if `cls' makes any mention of the operator
				 * For example: `operator str = del;' */
				local opaddr = cls.operators.get(opname);
				if (opaddr !is none) {
					/* The operator does indeed get overwritten by this class */
					local ctab = deemon.type_.__ctable__(object);
					if (ctab[opaddr] is bound) {
						local fun = ctab[opaddr];
						if (fun is deemon.function_) {
							file.writer resdoc;
							resdoc << opname;
							generate_function_params(resdoc,fun);
							resdoc << "->";
							local defl = operator_defaults.get(opname);
							if (defl !is none) {
								local rt = find_nonescaped(defl,"->");
								resdoc << defl.substr(rt + 2);
							}
							yield DocSection(this,resdoc.string);
						} else {
							yield autogenerate_opdecl(opname)...;
						}
					} else {
						/* Deleted operator */
						yield DocSection(this,opname + "->!D");
					}
				}
			} else {
				if (deemon.type_.hasprivateoperator(object,opname))
					yield autogenerate_opdecl(opname)...;
				else if (opname == "constructor") {
					yield autogenerate_native_constructor_desc()...;
				}
			}
		}
	}

	@@Enumerate all of the child operators of a type-like object
	private enumerate_operators_sections(): {(string,{DocSection...})...} {
		local result = dict();
		for (local s: allsections) {
			for (local name,opsec: s.enumerate_opsections()) {
				local lst = result.get(name);
				if (lst is none)
					result[name] = lst = [];
				lst.append(opsec);
			}
		}
		/* Enumerate operators overwritten, but not documented */
		if (object is bound && istype) {
			if (deemon.type_.__isclass__(object)) {
				local ctab = deemon.type_.__ctable__(object);
				local cls = deemon.type_.__class__(object);
				local ops = cls.operators;
				if (cls.hassuperconstructor && "constructor" !in result)
					result["constructor"] = (DocSection(this,"constructor->!S"),);
				for (local name,addr: ops) {
					if (name !in result) {
						if (ctab[addr] is bound) {
							local fun = ctab[addr];
							if (fun is deemon.function_) {
								file.writer resdoc;
								resdoc << name;
								generate_function_params(resdoc,fun);
								resdoc << "->";
								local defl = operator_defaults.get(name);
								if (defl !is none) {
									local rt = find_nonescaped(defl,"->");
									resdoc << defl.substr(rt + 2);
								}
								result[name] = (DocSection(this,resdoc.string),);
							} else {
								result[name] = tuple(autogenerate_opdecl(name));
							}
						} else {
							result[name] = (DocSection(this,name + "->!D"),);
						}
					}
				}
			} else {
				if ("constructor" !in result)
					result["constructor"] = tuple(autogenerate_native_constructor_desc());
				for (local name: deemon.type_.__operators__(object)) {
					if (name !is string)
						continue;
					/* Don't implicitly generate documentation for destructors of native classes
					 * Since these classes pretty much always require the presence of a destructor
					 * in order to allow them to clean up pointed-to objects, there really isn't
					 * any point in documenting them unless the type does so explicitly.
					 * -> So just skip them if we encounter them as part of the list of operators
					 *    that have been overwritten by the type. */
					if (name == "destructor")
						continue;
					if (name !in result)
						result[name] = tuple(autogenerate_opdecl(name));
				}
			}
		}
		return result;
	}
	private member m_operator_sections: {(string,{DocSection...})...};

	@@Enumerate the child nodes used to represent operators of @this when #istype is :true
	private enumerate_operators(): {Doc...} {
		if (m_operator_sections !is bound)
			m_operator_sections = enumerate_operators_sections();
		for (local name,sect: m_operator_sections)
			yield Doc(this,"op:" + name,sect);
		/* TODO: Enumerate operators implemented by the type,
		 *       but not included in documentation strings
		 *      (aka `x !in m_operator_sections.keys()') */
	}

	@@Check if @this doc node has a child attribute @name
	public final function haschild(name: string): bool {
		if (!this.haschildren)
			return false;
		if (this.istype && name.startswith("op:"))
			return !!getopdoc(name[3:]);
		if (object !is bound)
			return false;
		local my_object = object;
		local decl_object = my_object;
		if (decl_object !is deemon.type_ &&
		    decl_object !is deemon.module)
			decl_object = type decl_object;
		if (name.startswith("i:"))
			return attribute.exists(my_object,name[2:],"i",decl: decl_object);
		if (name.startswith("c:"))
			return attribute.exists(my_object,name[2:],"i","",decl: decl_object);
		return attribute.exists(my_object,name,decl: decl_object);
	}

	@@Enumerate all child nodes of @this documentation node
	operator for(): {Doc...} {
		if (!haschildren)
			return;
		if (istype)
			yield enumerate_operators()...;
		if (object !is bound)
			return;
		local my_object = object;
		local decl_object = my_object;
		if (decl_object !is deemon.type_ &&
		    decl_object !is deemon.module)
			decl_object = type decl_object;
		for (local x: enumattr(my_object)) {
			if (x.decl !== decl_object)
				break;
			yield Doc(this,x);
		}
	}

	@@Convenience interface for printing documentation information
	@@in a basic, but neat (and human-readable) format
	operator str(): string {
		file.writer fp;
		print fp: "-"*80;
		print fp: "| Documentation for `{}'".format({ prettypath });
		for (local sec: docsections) {
			print fp: "-"*80;
			for (local seg: sec.segments) {
				if (seg is Declaration) {
					print fp: ">>",kind,"",;
				}
				print fp: seg;
			}
		}
		print fp: "-"*80;
		if (ismodule) {
			local children = list(this);
			children.sort();
			for (local child: children) {
				fp << child;
			}
		}
		return fp.string;
	}

}









