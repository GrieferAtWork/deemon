/* Copyright (c) 2018-2023 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2018-2023 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

import util;
import deemon;
import * from deemon;

global Declaration;
global Doc;
global DocSection;
global Expression;
global Parameter;
global TextSegment;
global TypeExpr;
global TypeRef;



local function decodeNameContent(name: string): string {
	name = name.substr(1, #name - 1);
	name = name.replace("\\\n", "\n");
	name = name.replace(r"-\>", r"->");
	for (local x: r"\?!{}|,()<>[]=")
		name = name.replace(r"\" + x, x);
	return name;
}

@@Decode a <NAME>-like documentation name
local function decodeName(name: string): string {
	if (name.startswith("{") && name.endswith("}"))
		return decodeNameContent(name);
	return name;
}

@@Encode a <NAME>-like documentation name
local function encodeName(name: string): string {
	local result = name;
	if (!result.issymbol()) {
		for (local x: r"\?!{}|,()<>[]=")
			result = result.replace(x, r"\" + x);
		result = result.replace(r"->", r"-\>");
		result = result.replace("\n", "\\\n");
		result = f"\{{
			result
		}\}";
	}
	return result;
}

@@Decode the contents of a custom user-text section
local function decodeText(text: string): string {
	text = text.replace("\\\n", "\n");
	text = text.replace("\n\\(", "\n(");
	text = text.replace(r"-\>", r"->");
	text = text.replace(r"\\", r"\");
	return text;
}

@@Search for a given @ob within the export table of @mod, returning its name or @none if not found
local function findObjectNameInModule(mod: Module, ob: Object): string | none {
	/* Search the export table of this module! */
	for (local name, obj: Module.__exports__(mod)) {
		if (obj === ob)
			return name;
	}
	return none;
}

@@Try to determine the declaring module of a given type and return
@@a string in the form of @"?E<MODULE>:<NAME>" if this applies.
@@Otherwise, when the module could not be determined, return a
@@string in the form of @"?U<NAME>"
local function encodeType(tp: Type): string {
	if (tp === Object)
		return "?O";
	local mod = Type.__module__(tp);
	if (mod is none) /* Module could not be determined */
		return "?U" + encodeName(tp.__name__);
	local name = findObjectNameInModule(mod, tp);
	if (name is none)
		name = Type.__name__(tp);
	if (mod === deemon)
		return "?D" + encodeName(name);
	return f"?E{
		/* TODO: This only works for global modules! */
		encodeName(Module.__name__(mod))
	}:{
		encodeName(name)
	}";
}

@@Given a Doc-path in the form of @"<MODULE>/<ITEM>/<ATTR>/...", convert
@@that path into the form of @"?A<ATTR>?A<ATTR>?E<MODULE>:<ITEM>"
local function encodeTypeFromPath(path: string): string {
	local a, none, b = path.strip("/").rpartition("/")...;
	if (!b)
		return "?M" + encodeName(a);
	if ("/" !in a) {
		return f"?E{
			encodeName(a)
		}:{
			encodeName(b)
		}";
	}
	return f"?A{
		encodeName(b)
	}{
		encodeTypeFromPath(a)
	}";
}


@@Encode an arbitrary object expression @ob as a function default argument
@@If the given @ob cannot be encoded as such, return @none instead
local function encodeExpression(ob: Object): string | none {
	if (ob is int || ob is float)
		return "!" + ob;
	if (ob is string)
		return "!P" + encodeName(ob);
	if (ob is none)
		return "!N";
	if (ob is bool)
		return ob ? "!t" : "!f";
	if (ob is Type) {
		if (ob === Object)
			return "!Dobject";
		return "!" + encodeType(ob)[1:];
	}
	if (ob is Module)
		return "!M" + encodeName(Module.__name__(ob));
	return none;
}

@@Generate the @n'th generic argument name, following the rules layed
@@out for generating names for unknown arguments:
@@Start by using each of @"abcdefghijklmnopqrstuvwxyz", then continue
@@by generating names aa ab ac, etc.
@@Additionally, when @d is given, try to extract argument name information
@@from keyword information meta-data taken from the Doc node's bound object.
local function getGenericArgumentName(n: int, d: Doc | none = none): string {
	if (d !is none && d.object is bound) {
		local ob = d.object;
		if (hasattr(ob, "__kwds__")) {
			local kwds = ob.__kwds__;
			if (n < #kwds)
				return kwds[n];
		}
	}
	local pat = "abcdefghijklmnopqrstuvwxyz";
	local result = "";
	do {
		result = pat[n % #pat] + result;
		n /= #pat;
	} while (n);
	return result;
}



@@Split a given @text documentation string into its individual sections
@@Note that the segments returned will have already had escaped line-feeds expanded
local function splitDocSections(text: string): {string...} {
	return text.unifylines().split("\n\n");
}

@@Check if a backslash at @pos in @text is non-escaped, meaning
@@that in a text @r"a\\b", the backslash is ecaped, but isn't in @r"a\b"
local function isBackslashAtPosEscaped(text: string, pos: int): bool {
	local result = true;
	while (pos > 0) {
		--pos;
		if (text[pos] != "\\")
			break;
		result = !result;
	}
	return result;
}

@@Try to find @tofind in @text, but ensure that it isn't prefixed by an
@@unmatched backslash. If @tofind could not be found, return @-1 instead.
local function findNonEscaped(
		text: string, tofind: string, start: int = 0, end: int = -1): int {
	for (;;) {
		local result = text.find(tofind, start, end);
		if (result < 0)
			break;
		if (result && text[result - 1] == "\\" &&
		    isBackslashAtPosEscaped(text, result - 1)) {
			start = result + 1;
			continue;
		}
		return result;
	}
	return -1;
}

@@Similar to @findNonEscaped, but search from the right
local function rfindNonEscaped(
		text: string, tofind: string, start: int = 0, end: int = -1): int {
	for (;;) {
		local result = text.rfind(tofind, start, end);
		if (result < 0)
			break;
		if (result && text[result - 1] == "\\") {
			local is_escaped = true;
			local pos = result - 1;
			while (pos > 0) {
				--pos;
				if (text[pos] != "\\")
					break;
				is_escaped = !is_escaped;
			}
			if (is_escaped) {
				end = pos;
				continue;
			}
		}
		return result + 1;
	}
	return -1;
}

@@Split a given @text at each non-escaped instance of @tofind
local function splitNonEscaped(text: string, tofind: string): {string...} {
	if (!text)
		return;
	local i = 0;
	for (;;) {
		local pos = findNonEscaped(text, tofind, i);
		if (pos < 0) {
			yield text.substr(i);
			break;
		}
		yield text.substr(i, pos);
		i = pos + #tofind;
	}
}


@@Decode a <NAME>-like documentation name
local function decodeNameEnd(name: string, start: int = 0): int {
	local result;
	if (name.startswith("{", start)) {
		result = findNonEscaped(name, "}", start + 1);
		if (result < 0)
			result = #name;
		return result;
	}
	result = start;
	while (result < #name && name.issymcont(result))
		++result;
	return result;
}



@@Lookup table to determine default prototypes for operators, given their names
local final OPERATOR_DEFAULTS: {string: string} = {
	"constructor" : "?*", /* Special handling... */
	"copy"        : "(other:?.)->?N",
	"deepcopy"    : "(other:?.)->?N",
	"destructor"  : "()->?N",
	"assign"      : "(other:?.)->?N",
	"moveassign"  : "(other:?.)->?N",
	"str"         : "()->?Dstring",
	"repr"        : "()->?Dstring",
	"bool"        : "()->?Dbool",
	"next"        : "()->?*",
	"call"        : "(args!)->",
	"int"         : "()->?Dint",
	"hash"        : "()->?Dint",
	"size"        : "()->?Dint",
	"float"       : "()->?Dfloat",
	"inv"         : "()->?.",
	"pos"         : "()->?.",
	"neg"         : "()->?.",
	"add"         : "(other:?.)->?.",
	"sub"         : "(other:?.)->?.",
	"mul"         : "(other:?.)->?.",
	"div"         : "(other:?.)->?.",
	"mod"         : "(other:?.)->?.",
	"shl"         : "(shift:?Dint)->?.",
	"shr"         : "(shift:?Dint)->?.",
	"pow"         : "(other:?.)->?.",
	"and"         : "(other:?.)->?.",
	"or"          : "(other:?.)->?.",
	"xor"         : "(other:?.)->?.",
	"inc"         : "()->?.",
	"dec"         : "()->?.",
	"iadd"        : "(other:?.)->?.",
	"isub"        : "(other:?.)->?.",
	"imul"        : "(other:?.)->?.",
	"idiv"        : "(other:?.)->?.",
	"imod"        : "(other:?.)->?.",
	"ishl"        : "(shift:?Dint)->?.",
	"ishr"        : "(shift:?Dint)->?.",
	"ipow"        : "(other:?.)->?.",
	"iand"        : "(other:?.)->?.",
	"ior"         : "(other:?.)->?.",
	"ixor"        : "(other:?.)->?.",
	"eq"          : "(other:?.)->?Dbool",
	"ne"          : "(other:?.)->?Dbool",
	"lo"          : "(other:?.)->?Dbool",
	"le"          : "(other:?.)->?Dbool",
	"gr"          : "(other:?.)->?Dbool",
	"ge"          : "(other:?.)->?Dbool",
	"iter"        : "()->?AIterator?.",
	"contains"    : "(item:?*)->?Dbool",
	"getitem"     : "(index:?Dint)->?*",
	"delitem"     : "(index:?Dint)->?N",
	"setitem"     : "(index:?Dint,value:?*)->?N",
	"getrange"    : "(start:?Dint,end:?Dint)->?S?*",
	"delrange"    : "(start:?Dint,end:?Dint)->?N",
	"setrange"    : "(start:?Dint,end:?Dint,values:?S?*)->?N",
	"getattr"     : "(attr:?Dstring)->",
	"delattr"     : "(attr:?Dstring)->?N",
	"setattr"     : "(attr:?Dstring,value)->?N",
	"enumattr"    : "()->?S?DAttribute",
	"enter"       : "()->?N",
	"leave"       : "()->?N",
};

local _knownIteratorSequenceTypes: {Type: string} = Dict();
local function getIteratorSequenceTypeDoc(typ: Type): string {
	local result = _knownIteratorSequenceTypes.get(typ);
	if (result is none) {
		/* Check for a member `seq' and have the constructor
		 * take 1 argument that matches that element's typing. */
		local doc = try typ.seq.__doc__ catch (...) none;
		if (doc) {
			local loc = doc.find("\n\n->");
			if (loc != -1) {
				loc += 4;
			} else if (doc.startswith("->")) {
				loc = 2;
			}
			if (loc != -1) {
				local end = doc.find("\n", loc);
				if (end < 0)
					end = #doc;
				result = doc[loc:end];
			}
		}
		if (!result)
			result = "?DSequence";
		_knownIteratorSequenceTypes[typ] = result;
	}
	return result;
}

local _knownSequenceElementTypes: {Type: string} = Dict();
local function getIteratorElementTypeDoc(typ: Type): string {
	local result = _knownSequenceElementTypes.get(typ);
	if (result is none) {
		/* (try to) Extract generic iterator element type.
		 * For this purpose, we look at the return type of
		 * the iterator's `next' operator. If explicitly
		 * defined, then use that type as the sequence type. */
		local doc = Type.__doc__(typ);
		local loc = doc.find("\n\nnext->");
		if (loc != -1) {
			loc += 8;
		} else if (doc.startswith("next->")) {
			loc = 6;
		}
		if (loc != -1) {
			local end = doc.find("\n", loc);
			if (end < 0)
				end = #doc;
			result = doc[loc:end];
		}
		if (!result)
			result = "?O";
		_knownSequenceElementTypes[typ] = result;
	}
	return result;
}

local function getNextTyperefStart(typeref: string, start: int): int {
	assert typeref[start] == "?";
	++start;
	if (start >= #typeref)
		return -1;
	switch (typeref[start]) {

	case "C":
	case "M":
		start = findNonEscaped(typeref, "?", start);
		if (start != -1)
			start = getNextTyperefStart(typeref, start);
		break;

	case "T":
	case "X": {
		++start;
		local nStart = start;
		while (start < #typeref && typeref.isdigit(start))
			++start;
		local n;
		try {
			n = int(typeref[nStart:start]);
		} catch (...) {
			return -1;
		}
		for (none: [:n]) {
			start = getNextTyperefStart(typeref, start);
			if (start == -1)
				break;
		}
	}	break;

	case "R":
	case "Q":
		start = findNonEscaped(typeref, "]", start);
		if (start != -1)
			++start;
		break;

	default:
		start = findNonEscaped(typeref, "?", start);
		break;
	}
	return start;
}

local function getDefaultOperatorWithType(typ: Type, name: string): string | none {
	local result = OPERATOR_DEFAULTS.get(name);
	if (result !is none && "?*" in result) {
		if (name == "constructor") {
			if (Iterator.baseof(typ)) {
				return f"(seq:{getIteratorSequenceTypeDoc(typ)})->?N";
			}
			if (Sequence.baseof(typ)) {
				typ = try typ.Iterator catch (...) none;
				if (Iterator.baseof(typ)) {
					return f"(seq:?S{getIteratorElementTypeDoc(typ)})->?N";
				}
			}
			return "(args!)->?N";
		}
		if (Mapping.baseof(typ)) {
			/* Special handling for mappings. */
			result = {
				"contains" : "(key:?K*)->?Dbool",
				"getitem"  : "(key:?K*)->?V*",
				"delitem"  : "(key:?K*)->?N",
				"setitem"  : "(key:?K*,value:?V*)->?N",
			}.get(name, result);
			typ = try typ.Iterator catch (...) none;
			local repl = "?O";
			if (Iterator.baseof(typ))
				repl = getIteratorElementTypeDoc(typ);
			result = result.replace("?*", repl);
			if ("?K*" in result || "?V*" in result) {
				local k_repl = "?O";
				local v_repl = "?O";
				if (repl.startswith("?T2?")) {
					local p;
					if (repl.count("?") == 3) {
						p = repl.rindex("?");
					} else {
						p = getNextTyperefStart(repl, 3);
					}
					if (p != -1) {
						k_repl = repl[3:p];
						v_repl = repl[p:];
					}
				}
				result = result
					.replace("?K*", k_repl)
					.replace("?V*", v_repl);
			}
			return result;
		}
		if (Sequence.baseof(typ))
			typ = try typ.Iterator catch (...) none;
		local repl = "?O";
		if (Iterator.baseof(typ))
			repl = getIteratorElementTypeDoc(typ);
		result = result.replace("?*", repl);
	}
	return result;
}


@@Lookup table to convert pretty operator names to their real counterparts
global final OPERATOR_NAMES: {string: string} = {
	"this" : "constructor", "~this" : "destructor", ":=" : "assign",
	"move:=" : "moveassign", ":=move" : "moveassign", "++" : "inc",
	"--" : "dec", "#" : "size", "~" : "inv", "+" : none, "-" : none,
	"*" : "mul", "/" : "div", "%" : "mod", "<<" : "shl",
	">>" : "shr", "&" : "and", "|" : "or", "^" : "xor",
	"**" : "pow", "+=" : "iadd", "-=" : "isub", "*=" : "imul",
	"/=" : "idiv", "%=" : "imod", "<<=" : "ishl", ">>=" : "ishr",
	"&=" : "iand", "|=" : "ior", "^=" : "ixor", "**=" : "ipow",
	"<" : "lo", "<=" : "le", ">" : "gr", ">=" : "ge", "==" : "eq",
	"!=" : "ne", "[]" : "getitem", "del[]" : "delitem",
	"[]=" : "setitem", "[:]" : "getrange", "del[:]" : "delrange",
	"[:]=" : "setrange", "." : "getattr", ".=" : "setattr",
	"del." : "delattr",
};

@@Lookup table for converting from real operator names to pretty names
global final PRETTY_OPERATOR_NAMES: {string: string} = {
	"assign" : " :=", "moveassign" : "move :=", "size" : "#",
	"inv" : "~", "add" : "+", "sub" : "-", "pos" : "+", "neg" : "-",
	"mul" : "*", "div" : "/", "mod" : "%", "shl" : "<<",
	"shr" : ">>", "and" : "&", "or" : "|", "xor" : "^",
	"delitem" : "del[]", "ne" : "!=", "getitem" : "[]", "iand" : "&=",
	"ishr" : ">>=", "isub" : "-=", "eq" : "==", "ishl" : "<<=",
	"setitem" : "[]=", "delrange" : "del[:]", "iadd" : "+=",
	"setrange" : "[:]=", "ior" : "|=", "ixor" : "^=", "imul" : "*=",
	"idiv" : "/=", "getrange" : "[:]", "ipow" : "**=", "imod" : "%=",
	"le" : "<=", "pow" : "**", "ge" : ">="
};

@@Weight of different node types when being sorted
local final KIND_SORTING_WEIGHTS: {string: int} = {
	"module" : 0x0000, "operator" : 0x0100,
	"type" : 0x0101, "singleton" : 0x0102,
	"function" : 0x0200, "property" : 0x0201, "member" : 0x0202,
	"class_function" : 0x0300, "class_property" : 0x0301,
	"class_member" : 0x0302,
};

@@Weight of different operators when being sorted
local final OPERATOR_SORTING_WEIGHTS: {string: int} = {
	"constructor" : 0x0000, "copy" : 0x0001, "deepcopy" : 0x0002,
	"destructor" : 0x0003, "assign" : 0x0004, "moveassign" : 0x0005,
	"str" : 0x0100, "repr" : 0x0101, "bool" : 0x0102, "int" : 0x0103,
	"call" : 0x0200, "eq" : 0x0300, "ne" : 0x0301, "lo" : 0x0302,
	"le" : 0x0303, "gr" : 0x0304, "ge" : 0x0305, "inv" : 0x0400,
	"pos" : 0x0401, "neg" : 0x0402, "add" : 0x0403, "sub" : 0x0404,
	"mul" : 0x0405, "div" : 0x0406, "mod" : 0x0407, "shl" : 0x0408,
	"shr" : 0x0409, "and" : 0x040a, "or" : 0x040b, "xor" : 0x040c,
	"pow" : 0x040d, "iadd" : 0x040e, "isub" : 0x040f, "imul" : 0x0410,
	"idiv" : 0x0411, "imod" : 0x0412, "ishl" : 0x0413, "ishr" : 0x0414,
	"iand" : 0x0415, "ior" : 0x0416, "ixor" : 0x0417, "ipow" : 0x0418,
	"iter" : 0x0500, "size" : 0x0501, "contains" : 0x0502, "getitem" : 0x0503,
	"delitem" : 0x0504, "setitem" : 0x0505, "getrange" : 0x0506,
	"delrange" : 0x0507, "setrange" : 0x0508, "next" : 0x0600,
	"enter" : 0x0700, "leave" : 0x0701, "getattr" : 0x0800,
	"delattr" : 0x0801, "setattr" : 0x0802, "enumattr" : 0x0803,
};


@@Return the real name of a given operator name @name
@@This function translates names such as @"#" to @"size"
@@When the real operator cannot be unambiguosly deduced without
@@known the associated argument count, return @none, in which case
@@the caller must determine the argument count and re-attempt the
@@call while passing @argc as a value other than @none.
local function getRealOperatorName(name: string, argc: int | none = none): string | none {
	local result = OPERATOR_NAMES.get(name, name);
	if (result is none && argc !is none) {
		switch (name) {
		case "+":
			return argc == 0 ? "pos" : "add";
		case "-":
			return argc == 0 ? "neg" : "sub";
		default: break;
		}
		result = name.strip("_");
	}
	return result;
}

@@Returns the Doc-like path for a given fully qualified type
@@If no such path exists, return @none instead
@@NOTE: The returned path includes a leading @"/"
local function getQualifiedTypePath(
		docnode: WeakRef with Doc, qual: string): string | none {
	if (#qual >= 2) {
		switch (qual[1]) {

		case "G": {
			local mod = docnode.value.module;
			if (mod is none)
				return none;
			return f"/{
				Module.__name__(mod)
			}/{
				decodeName(qual.substr(2))
			}";
		}	break;

		case "E": {
			local modend = findNonEscaped(qual, ":", 2);
			return f"/{
				decodeName(qual.substr(2, modend))
			}/{
				decodeName(qual.substr(modend + 1))
			}";
		}	break;

		case "A": {
			local nameend = decodeNameEnd(qual, 2);
			local base = getQualifiedTypePath(docnode, qual.substr(nameend));
			if (base is none)
				return none;
			return f"{base}/c:{decodeName(qual.substr(2, nameend))}";
		}	break;

		default:
			break;
		}
	}
	return none;
}

local function findErrorByName(t: Type, qual: string, s: string): string | none {
	if (t.__name__ == s)
		return qual;
	for (local attr: enumattr(t)) {
		if (attr.decl != t) break;
		if (attr.attrtype != type Object) break;
		if (!attr.isclass) continue;
		local result = findErrorByName(
			t.operator . (attr.name),
			f"?A{attr.name}{qual}",
			s);
		if (result !is none)
			return result;
	}
}

local function qualifyLegacyTyperef(docnode: WeakRef with Doc, s: string): string {
	/* Search for a legacy-like type reference */
	local node = docnode.value;
	if (!node.istype && node.parent !is none)
		node = node.parent;
	do {
		if (node.haschild(s))
			return f"?A{encodeName(s)}{node.qualpath}";
		node = node.parent;
	} while (node !is none);

	/* Search for known sub-classes of `Error' */
	local result = findErrorByName(Error, "?DError", s);
	if (result !is none)
		return result;

	/* Search the deemon module itself. */
	if (hasattr(deemon, s))
		return "?D" + encodeName(s);

	/* Fallback: Invalid encoding -> Encode an unknown */
	return "?U" + encodeName(s);
}

@@Turn @s into a fully qualified type reference string
local function qualifyTyperefString(docnode: WeakRef with Doc, s: string): string {
	if (s.startswith("?") && #s >= 2) {
		switch (s[1]) {

		case ".": {
			local node = docnode.value;
			if (!node.istype && node.parent !is none)
				node = node.parent;
			return node.qualpath;
		}	break;

		case "#": {
			local node = docnode.value;
			local len = decodeNameEnd(s, 2);
			if (node.ismodule) {
				local mod = node.module;
				return f"?E{
					/* TODO: This only works for global modules! */
					encodeName(Module.__name__(mod))
				}:{
					s.substr(2, len)
				}";
			}
			if (!node.istype && node.parent !is none)
				node = node.parent;
			return f"?A{s.substr(2, len)}{node.qualpath}";
		}	break;

		case "N":
			return "?Edeemon:none";

		case "O":
			return "?Edeemon:Object";

		case "D":
			return "?Edeemon:" + decodeName(s.substr(2));

		case "U":
		case "E":
		case "G":
			return s;

		case "A": {
			local attr_end;
			attr_end = findNonEscaped(s, "?", 2);
			if (attr_end < 0)
				break;
			local tail = s.substr(attr_end);
			local newtail = qualifyTyperefString(docnode, tail);
			if (tail === newtail)
				return s;
			return s.substr(0, attr_end) + newtail;
		}	break;

		default: break;
		}
	}
	return qualifyLegacyTyperef(docnode, s);
}

@@Return the type associated with a given fully qualified path
@@If the type could not be accessed, return @none or throw an
@@exception.
local function getTypeFromQualPath(docnode: WeakRef with Doc, qual: string): Type | none {
	if (#qual < 2)
		return none;
	switch (qual[1]) {

	case "A": {
		local attrend = decodeNameEnd(qual, 2);
		local base = getTypeFromQualPath(docnode, qual.substr(attrend));
		local result = base.operator . (qual.substr(2, attrend));
		if (result is none)
			result = type none;
		return result;
	}	break;

	case "E": {
		local modend = findNonEscaped(qual, ":");
		if (modend < 0)
			break;
		local modnam = decodeName(qual.substr(2, modend));
		local symnam = decodeName(qual.substr(modend + 1));
		local mod;
		if (modnam.startswith(".")) {
			/* Import the module relatively to the one calling */
			mod = import(modnam, base: docnode.value.module);
		} else {
			mod = import(modnam);
		}
		local result = mod.operator . (symnam);
		if (result is none)
			result = type none;
		return result;
	}	break;

	case "G": {
		local basemod = docnode.value.module;
		local result = basemod.operator . (qual.substr(2));
		if (result is none)
			result = type none;
		return result;
	}	break;

	default: break;
	}
	return none;
}


@@Abstract representation of a type reference, using either
@@the new-style ?... encoding, or the direct naming of types
@@seen in old-style documentation strings
class TypeRef: WeakRefAble {

	@@The fully qualified documentation string for this type
	@@Example: $"?Edeemon:int"
	@@This type reference always has one of the following forms
	@@ - @"?A<NAME><TYPE>" (Allowing for attribute-lookup recursion)
	@@ - @"?E<NAME>:<NAME>" (For types with a known resident location)
	@@ - @"?G<NAME>" (For types with a known resident location in the associated module)
	@@ - @"?U<NAME>" (For types with an unknown resident location)
	public final property docstring: string = {
		get(): string {
			if (m_docstring !is string)
				m_docstring = qualifyTyperefString(docnode, encodeType(m_docstring));
			return m_docstring;
		}
	}
	public final member m_docstring: string | Type;

	@@The doc node that contains a reference to @this TypeRef
	public final member docnode: WeakRef with Doc;

	this(d: Doc | WeakRef with Doc, ds: string | Type)
		: docnode(d is WeakRef ? d : WeakRef(d))
	{
		if (ds is string) {
			m_docstring = qualifyTyperefString(docnode, ds);
		} else {
			m_docstring = ds;
			m_typ = ds;
		}
	}

	@@Returns a string representation of how @this TypeRef can be created
	operator repr(): string {
		return f"TypeRef({
			repr docnode.lock(none)
		}, {
			repr docstring
		})";
	}

	@@The actual type object represented by @this TypeRef
	public final property typ: Type = {
		get(): Type {
			if (m_typ !is bound) {
				m_typ = getTypeFromQualPath(docnode, m_docstring);
				if (m_typ !is Type)
					throw Error(f"Qualified path {repr m_docstring} does not name a type");
			}
			return m_typ;
		}
	}
	private member m_typ: Type;


	@@Returns the Doc path associated with the type referenced by @this
	@@If no such path exists, return @none instead
	@@NOTE: The returned path includes a leading @"/"
	public final property path: string | none = {
		get(): string | none {
			if (m_path !is bound)
				m_path = getQualifiedTypePath(docnode, docstring);
			return m_path;
		}
	}
	private member m_path: string | none;

	@@Similar to @path, but return the associated Doc node instead
	public final property node: Doc | none = {
		get(): Doc | none {
			if (m_node !is bound) {
				local p = path;
				if (p is none) {
					m_node = none;
					return none;
				}
				local result = Doc(p);
				m_node = WeakRef();
				return result;
			} else {
				local result = m_node.lock(none);
				if (result is none) {
					local p = path;
					if (p is none) {
						m_node = none;
						return none;
					}
					m_node.value = result = Doc(p);
				}
				return result;
			}
		}
	}
	private member m_node: WeakRef with Doc | none;

	@@Get the human-readable name of the type Referneced by @this
	@@The returned string does not retain all available information,
	@@and ishas 2 different forms:
	@@ - When the type is found to be apart of the same module as the referencing
	@@   doc node, then the module prefix is omitted, and the returned string is
	@@   structured in the form of @"MyType.Iterator" (for @((MyType from mymodule).Iterator))
	@@ - When the type is apart of a different module, then that module's name is
	@@   prefixed, resulting in the form of @"mymodule.MyType.Iterator"
	@@   When that other module is the builtin @deemon module, the module prefix
	@@   will be attempted to be omitted, however if the current module also contains
	@@   an export with the same name, the prefix is retained.
	public final property prettyname: string = {
		get() {
			if (m_prettyname !is bound) {
				if (docstring.startswith("?G")) {
					m_prettyname = decodeName(docstring.substr(2));
				} else {
					m_prettyname = getprettyname(docstring);
				}
			}
			return m_prettyname;
		}
	}
	private member m_prettyname: string;

	private getprettyname(qual): string {
		if (#qual >= 2) {
			switch (qual[1]) {

			case "E": {
				local modend = findNonEscaped(qual, ":", 2);
				local modname = decodeName(qual.substr(2, modend));
				local modexp = decodeName(qual.substr(modend + 1));
				local mymod = docnode.lock(none).module;
				if (mymod !is none) {
					if (modname == Module.__name__(mymod))
						return modexp;
					if (modname == "deemon" && modexp !in Module.__exports__(mymod))
						return modexp;
				}
				return f"{modname}.{modexp}";
			}	break;

			case "U":
				return decodeName(qual.substr(2));

			case "A": {
				local namelen = decodeNameEnd(qual, 2);
				return f"{
					getprettyname(qual.substr(namelen))
				}.{
					decodeName(qual.substr(2, namelen))
				}";
			}

			default:
				break;
			}
		}
		return decodeName(qual.substr(2));
	}

	operator str(): string {
		return prettyname;
	}
}

@@Returns the character index where a type expression starting at @start ends
local function typeExprEnd(s: string, start: int): int {
	local len = #s;
	local result = start;
again:
	if (result >= len)
		return result;
	if (s[result] != "?") {
		result = s.find("?");
		if (result < 0)
			result = len;
		return result;
	}
	++result;
	if (result >= len)
		return result;
	switch (s[result]) {

	case "#":
	case "D":
	case "U":
	case "G":
		++result;
		result = decodeNameEnd(s, result);
		break;

	case "E":
		++result;
		result = decodeNameEnd(s, result);
		if (s[result] == ":") {
			++result;
			result = decodeNameEnd(s, result);
		}
		break;

	case "A":
		++result;
		result = decodeNameEnd(s, result);
		goto again;

	case "C":
	case "M":
		++result;
		result = typeExprEnd(s, result);
		goto again;

	case "T":
	case "X": {
		++result;
		local n_start = result;
		while (result < len && s.isdigit(result))
			++result;
		local n = try int(s[n_start:result]) catch (...) 0;
		for (none: [:n])
			result = typeExprEnd(s, result);
	}	break;

	case "S":
		++result;
		goto again;

	case "Q": {
		local end = findNonEscaped(s, "]", result + 1);
		if (end < 0)
			end = len - 1;
		result = end + 1;
	}	break;

	default:
		++result;
		break;
	}
	return result;
}


@@Returns the character index where a default expression starting at @start ends
local function deflexpr_end(s: string, start: int): int {
	local len = #s;
	local result = start;
again:
	if (result >= len)
		return result;
	if (s[result] != "!") {
		result = s.find("!");
		if (result < 0)
			result = len;
		return result;
	}
	++result;
	if (result >= len)
		return result;
	switch (s[result]) {

	case "V":
		++result; /* VA */
		/* FALLTHRU */
	case "P":
	case "#":
	case "D":
	case "U":
	case "G":
	case "M":
		++result;
		result = decodeNameEnd(s, result);
		break;

	case "E":
		++result;
		result = decodeNameEnd(s, result);
		if (s[result] == ":") {
			++result;
			result = decodeNameEnd(s, result);
		}
		break;

	case "T":
	case "L":
	case "S":
	case "H": {
		++result;
		local n_start = result;
		while (result < len && s.isdigit(result))
			++result;
		local n = try int(s[n_start:result]) catch (...) 0;
		for (none: [:n])
			result = deflexpr_end(s, result);
	}	break;

	case "!":
		++result;
		if (result >= len)
			break;
		switch (s[result]) {
		case "!":
			++result;
			if (result >= len)
				break;
			switch (s[result]) {
			case "!": /* NOT */
				++result;
				goto again;
			case "<": /* shl */
			case ">": /* shr */
				++result;
				result = deflexpr_end(s, result);
				goto again;
			default: break;
			}
			break;
		case "+":
		case "-":
		case "*":
		case "=":
		case "<":
		case ">":
		case "C":
			++result;
			result = deflexpr_end(s, result);
			goto again;
		case "[":
			++result;
			result = deflexpr_end(s, result);
			result = deflexpr_end(s, result);
			goto again;
		default:
			break;
		}
		++result;
		goto again;

	case "C":
	case "X":
	case "W":
	case "O":
	case "K":
	case "R":
	case "Q":
	case "+":
	case "~":
		++result;
		goto again;

	case "*":
	case "/":
	case "%":
	case "&":
	case "|":
	case "^":
	case "=":
	case "<":
	case ">":
	case "[":
		++result;
		result = deflexpr_end(s, result);
		goto again;

	case "I": /* conditional expression */
		++result;
		result = deflexpr_end(s, result);
		result = deflexpr_end(s, result);
		goto again;

	case "-":
		++result;
		/* FALLTHRU */
	default:
		if (result < len && s.isdigit(result)) {
			for (;;) {
				++result;
				if (result >= len)
					break;
				if (!s.isdigit(result) && s[result] != ".")
					break;
			}
			break;
		} else {
			++result;
		}
		break;
	}
	return result;
}




@@Abstract representation of a type expression, including
@@support for generic sequence expressions, alternative
@@representations, as well as container expressions.
@@Example:
@@>import * from deemon;
@@>import * from doc;
@@>function foo(x: int | float): string {
@@>    return str x;
@@>}
@@>
@@>local d = Doc(foo);
@@>print d.decls[0].parameters[0].typ.Xtypes[0].Etyperef.typ; /* int */
@@>print d.decls[0].parameters[0].typ.Xtypes[1].Etyperef.typ; /* float */
@@>print d.decls[0].ret.Etyperef.typ;                         /* string */
@@>print d.decls[0].parameters[0].isaccepted(1234);  /* true */
@@>print d.decls[0].parameters[0].isaccepted(1.0);   /* true */
@@>print d.decls[0].parameters[0].isaccepted("foo"); /* false */
class TypeExpr: WeakRefAble {

	@@The raw documentation string for this type
	@@Example: @"?T2?Dint?Dint"
	public final property docstring: string = {
		get(): string {
			if (m_docstring !is string)
				m_docstring = encodeType(m_docstring);
			return m_docstring;
		}
	}
	private member m_docstring: string | Type;

	@@The doc node that contains a reference to @this TypeExpr
	public final property docnode: WeakRef with Doc = {
		get(): WeakRef with Doc {
			return docdecl.value.docsect.value.docnode;
		}
	}

	@@The doc Declaration that uses @this TypeExpr
	public final member docdecl: WeakRef with Declaration;

	this(d: Declaration | WeakRef with Declaration, ds: string | Type)
		: docdecl(d is WeakRef ? d : WeakRef(d))
		, m_docstring(ds)
	{
		if (m_docstring !is string) {
			m_kind = "E";
			m_cache = TypeRef(docnode, m_docstring);
			m_types = (m_docstring,);
		}
	}

	@@Returns a string representation of how @this TypeExpr can be created
	operator repr(): string {
		return f"TypeExpr({
			repr docdecl.lock(none)
		}, {
			repr docstring
		})";
	}

	@@Returns true if @this Type expression refers to @none
	public final property isnone: bool = {
		get(): bool {
			if (m_docstring is string)
				return m_docstring in ["?N", "?Dnone", "?Edeemon:none"];
			return m_docstring === type none;
		}
	}

	@@Returns @true if the type referred to by @this TypeExpr
	@@accepts any kind of input (aka. refers to @Object)
	@@Seperately, a X-expression with at least one element
	@@accepting anything, also accepts anything itself.
	public final property acceptsany: bool = {
		get(): bool {
			if (m_acceptsany !is bound) {
				if (m_docstring !is string) {
					m_acceptsany = m_docstring === Object;
				} else if (m_docstring in ["?O", "?Dobject", "?Edeemon:Object"]) {
					m_acceptsany = true;
				} else {
					m_acceptsany = false;
					if (kind == "X") {
						for (local x: Xtypes) {
							if (x.acceptsany) {
								m_acceptsany = true;
								break;
							}
						}
					}
				}
			}
			return m_acceptsany;
		}
	}
	private member m_acceptsany: bool;


	@@Check if a given @Object @ob can be accepted as argument for @this @TypeExpr
	public final isaccepted(ob: Object): bool {
		switch (kind) {

		case "E":
			return ob is Etyperef.typ;

		case "C": {
			if (ob !is Ccelltype.typ)
				return false;
			local itemtype = Citemtype;
			if (itemtype.typ === Object)
				return true;
			try {
				for (local v: ob) {
					if (!itemtype.isaccepted(v))
						return false;
				}
				return true;
			} catch (...) {
			}
		}	break;

		case "M": {
			if (ob !is Mapping)
				return false;
			local keytype = Mkeytype;
			local valuetype = Mvaluetype;
			try {
				for (local key, value: ob) {
					if (!keytype.isaccepted(key))
						return false;
					if (!valuetype.isaccepted(value))
						return false;
				}
				return true;
			} catch (...) {
			}
		}	break;

		case "T": {
			local items;
			try {
				items = Tuple(ob);
			} catch (...) {
				return false;
			}
			local ttypes = Ttypes;
			if (#items != #ttypes)
				return false;
			for (local i: [:#items]) {
				if (!ttypes[i].isaccepted(items[i]))
					return false;
			}
			return true;
		}	break;

		case "X":
			for (local alt: Xtypes) {
				if (alt.isaccepted(ob))
					return true;
			}
			break;

		case "S": {
			local it;
			try {
				it = ob.operator iter();
			} catch (...) {
				return false;
			}
			local st = Stype;
			if (st.acceptsany)
				return true;
			for (;;) {
				local elem;
				try {
					foreach(elem: it)
						goto check_elem;
					return true;
				} catch (...) {
					return false;
				}
check_elem:
				if (!st.isaccepted(ob))
					return false;
			}
			return true;
		}	break;

		default:
			break;
		}
		return false;
	}

	@@Enumerate the (simplified) set of types which @this TypeExpr accepts
	@@For this purpose, contained-information for Cell-like objects is removed, and
	@@any kind of sequence-like type is interpreted as one of @Sequence or @Mapping
	public final property types: {Type...} = {
		get(): {Type...} {
			if (m_types !is bound)
				m_types = HashSet(enumtypes());
			return m_types;
		}
	}
	private member m_types: {Type...};

	private enumtypes(): {Type...} {
		switch (kind) {

		case "E":
			yield Etyperef.typ;
			break;

		case "C":
			yield Ccelltype.enumtypes()...;
			break;

		case "T":
			yield Tuple;
			break;

		case "X":
			for (local x: Xtypes)
				yield x.enumtypes()...;
			break;

		case "S":
			yield Sequence;
			break;

		case "M":
			yield Mapping;
			break;

		case "Q":
			yield Qexpr.exprtypes...;
			break;

		default:
			yield Object;
			break;
		}
	}

	@@Returns the kind of type expression represented by @this node
	@@This is a single character, which is one of:
	@@ - @"E": Fully qualifyable type; s.a. @Etyperef
	@@ - @"C": Container-like type (s.a. @Ccelltype and @Citemtype)
	@@ - @"T": Tuple consisting of multiple child-elements (s.a. @Ttypes)
	@@ - @"X": A set of multiple, alternatively accepted types (s.a. @Xtypes)
	@@ - @"M": A key-value mapping type (s.a. @Mkeytype and @Mvaluetype)
	@@ - @"S": A sequence containing elements of a specific type (s.a. @Stype)
	@@ - @"Q": The type of an expression (s.a. @Qexpr)
	public final property kind: string = {
		get(): string {
			if (m_kind !is bound) {
				if (#m_docstring < 2 || !m_docstring.startswith("?")) {
					m_kind = "E"; /* Legacy-like type name */
				} else {
					m_kind = m_docstring[1];
					if (m_kind in [".", "N", "O", "#", "D", "U", "G" /*, "E"*/, "A"])
						m_kind = "E"; /* Fully qualifyable */
				}
			}
			return m_kind;
		}
	}
	private member m_kind: string;


	@@Cache of child-expressions / references
	private member m_cache: TypeRef | TypeExpr | {TypeExpr...} | (TypeExpr, TypeExpr) | Expression;
	private loadCM() {
		local end = typeExprEnd(m_docstring, 2);
		m_cache = (
			TypeExpr(docdecl, m_docstring.substr(2, end)),
			TypeExpr(docdecl, m_docstring.substr(end)),
		);
	}
	private loadTX() {
		local pos = 2;
		while (pos < #m_docstring && m_docstring.isdigit(pos))
			++pos;
		local n = try int(m_docstring[2:pos]) catch (...) 0;
		local result = List(n, none);
		for (local i: [:n]) {
			local end = typeExprEnd(m_docstring, pos);
			result[i] = TypeExpr(docdecl, m_docstring.substr(pos, end));
			pos = end;
		}
		m_cache = Tuple(result);
	}
	private loadS() {
		m_cache = TypeExpr(docdecl, m_docstring.substr(2));
	}
	private loadQ() {
		m_cache = Expression(docdecl, m_docstring[2:-1]);
	}


	@@Returns a fully qualified type reference for @this
	@@WARNING: This property must only be used when @kind is equal to @"E"
	public final property Etyperef: TypeRef = {
		get(): TypeRef {
			if (m_cache !is bound)
				m_cache = TypeRef(docnode, m_docstring);
			return m_cache;
		}
	}

	@@Returns the cell container type for @this
	@@WARNING: This property must only be used when @kind is equal to @"C"
	public final property Ccelltype: TypeExpr = {
		get(): TypeExpr {
			if (m_cache !is bound)
				loadCM();
			return m_cache[0];
		}
	}

	@@Returns the cell item type for @this
	@@WARNING: This property must only be used when @kind is equal to @"C"
	public final property Citemtype: TypeExpr = {
		get(): TypeExpr {
			if (m_cache !is bound)
				loadCM();
			return m_cache[1];
		}
	}

	@@Returns the sequence of Tuple element types
	@@WARNING: This property must only be used when @kind is equal to @"T"
	public final property Ttypes: {TypeExpr...} = {
		get(): {TypeExpr...} {
			if (m_cache !is bound)
				loadTX();
			return m_cache;
		}
	}

	@@Returns the sequence of alternative type expressions
	@@WARNING: This property must only be used when @kind is equal to @"X"
	public final property Xtypes: {TypeExpr...} = {
		get(): {TypeExpr...} {
			if (m_cache !is bound)
				loadTX();
			return m_cache;
		}
	}

	@@Returns the element type of @this sequence expression
	@@WARNING: This property must only be used when @kind is equal to @"S"
	public final property Stype: TypeExpr = {
		get(): TypeExpr {
			if (m_cache !is bound)
				loadS();
			return m_cache;
		}
	}

	@@Returns the key type for @this
	@@WARNING: This property must only be used when @kind is equal to @"M"
	public final property Mkeytype: TypeExpr = {
		get(): TypeExpr {
			if (m_cache !is bound)
				loadCM();
			return m_cache[0];
		}
	}

	@@Returns the value type for @this
	@@WARNING: This property must only be used when @kind is equal to @"M"
	public final property Mvaluetype: TypeExpr = {
		get(): TypeExpr {
			if (m_cache !is bound)
				loadCM();
			return m_cache[1];
		}
	}

	@@Returns the key/value tuple type (== item type) for @this
	@@WARNING: This property must only be used when @kind is equal to @"M"
	public final property Mitemtype: TypeExpr = {
		get(): TypeExpr {
			if (m_cache !is bound)
				loadCM();
			return TypeExpr(docdecl, f"?T2{
				m_cache[0].docstring}{
				m_cache[1].docstring}");
		}
	}

	@@Returns the expression who's type is referenced by @this TypeExpr
	@@WARNING: This property must only be used when @kind is equal to @"Q"
	public final property Qexpr: Expression = {
		get(): Expression {
			if (m_cache !is bound)
				loadQ();
			return m_cache;
		}
	}

	@@Return @this type in a way in which the user may have originally written it
	operator str(): string {
		switch (kind) {

		case "E":
			return str Etyperef;

		case "C":
			return f"{Ccelltype} with {Citemtype}";

		case "T":
			return #Ttypes == 1
				? f"({Ttypes[0]},)"
				: f"({', '.join(Ttypes)})";

		case "X":
			return " | ".join(Xtypes);

		case "S":
			return f"\{{Stype}...\}";

		case "M":
			return f"\{{Mkeytype}: {Mvaluetype}\}";

		case "Q":
			return f"type({Qexpr})";

		default: break;
		}
		return docstring;
	}
}


@@Abstract representation of documentation expressions,
@@as used to encode parameter default values
class Expression: WeakRefAble {

	@@The raw documentation string for this expression
	@@Example: @"!Edeemon:none"
	public final property docstring: string = {
		get(): string {
			if (m_docstring === false)
				m_docstring = encodeExpression(m_cache);
			return m_docstring;
		}
	}
	private member m_docstring: string | bool;

	@@The doc Declaration that contains a reference to @this Expression
	public final member docdecl: WeakRef with Declaration;

	@@The doc node associated with @this Expression
	public final property docnode: WeakRef with Doc = {
		get(): WeakRef with Doc {
			return docdecl.value.docsect.value.docnode;
		}
	}

	this(d: Declaration | WeakRef with Declaration, ds: string | bool, cval?: Object)
		: docdecl(d is WeakRef ? d : WeakRef(d))
		, m_docstring(ds)
	{
		if (cval is bound) {
			m_kind = "C";
			m_cache = cval;
		}
	}

	@@Returns a string representation of how @this Expression can be created
	operator repr(): string {
		return f"Expression({
			repr docdecl.lock(none)
		}, {
			repr docstring
		})";
	}

	@@Enumerate a sequence of all the possible types that @this expression can take
	public final property exprtypes: {TypeExpr...} = {
		get(): {TypeExpr...} {
			switch (kind) {

			case "C":
				yield TypeExpr(docdecl, type Cvalue);
				break;

			case "A":
				/* Alias the same types as seen in another argument. */
				yield Aparam.typ.types...;
				break;

			case "S":
				yield StypeExpr;
				break;

			default:
				yield TypeExpr(docdecl, "?O");
				break;
			}
		}
	}

	@@Helper function to try and optimize an expression into a constant
	private try_optimize_expression() {
		/* TODO */
	}

	@@The kind of expression, which is one of
	@@  - @"C": A constant expression (s.a. @Cvalue)
	@@  - @"E": An fully qualified location within a reachable module (s.a. @Epath, @Emodule, @Evalue)
	@@  - @"A": Another argument (s.a. @Aparam)
	@@  - @"U": An undefined/private symbol (s.a. @Uname)
	@@  - @"S": A sequence expression (s.a. @Sitems, @Stype)
	@@  - @"O": An operator being invoked on another expression (s.a. @Ooperator and @Ooperands)
	public final property kind: string = {
		get(): string {
			if (m_kind !is bound) {
				if (!m_docstring.startswith("!")) {
					/* Raw, constant expression */
					m_kind = "C";
					if (!m_docstring) {
						m_cache = none;
					} else if (m_docstring.startswith("\"")) {
						m_cache = try m_docstring.decode("c-escape") catch (...) m_docstring;
					} else if (m_docstring.startswith("r\"")) {
						m_cache = m_docstring[2:-1];
					} else if (m_docstring.isdigit(0)) {
						m_cache = try
							"." in m_docstring
								? float(m_docstring)
								: int(m_docstring)
							catch (...)
								m_docstring;
					} else if (":" in m_docstring) {
						/* Assume external symbol. */
						local mod, none, path = m_docstring.partition(":")...;
						m_docstring = f"!E{encodeName(mod)}:{encodeName(path)}";
						m_kind = "E";
					} else {
						local defl = {
							"none" : none,
							"true" : true,
							"false" : false,
						};
						m_cache = defl.get(m_docstring, m_docstring);
					}
				} else if (#m_docstring < 2) {
					m_kind = "C";
					m_cache = none;
				} else {
					/* New-style default expression. */
					local id = m_docstring[1];
					if (id == "P" || id.isdigit()) {
						m_kind = "C";
					} else if (id == "-" && #m_docstring >= 2 &&
					           (m_docstring.isdigit(2) || m_docstring[2] == ".")) {
						m_kind = "C";
					} else if (id in ["N", "t", "f"]) {
						local map = { "N" : none, "t" : true, "f" : false };
						m_kind = "C";
						m_cache = map[id];
					} else if (id in ["D", "U", "G", "E", "M"]) {
						m_kind = "E";
					} else if (id in ["T", "L", "S", "H"]) {
						m_kind = "S";
					} else if (id == "V" && #m_docstring >= 3 && m_docstring[2] == "A") {
						m_kind = "A";
					} else {
						if (id == "!" && #m_docstring >= 4) {
							id = m_docstring[2];
							if (id == "+" && m_docstring.isdigit(3)) {
								local ds = m_docstring.substr(3);
								m_kind = "C";
								m_cache = try
									"." in ds
										? int(ds)
										: float(ds)
									catch (...)
										ds;
								goto done;
							} else if (id == "-" && m_docstring.isdigit(3)) {
								local ds = m_docstring.substr(3);
								m_kind = "C";
								m_cache = try
									"." in ds
										? -int(ds)
										: -float(ds)
									catch (...)
										ds;
								goto done;
							}
						}
						m_kind = "O";
						try_optimize_expression();
					}
				}
			}
done:
			return m_kind;
		}
	}
	private member m_kind: string;
	private member m_cache;


	@@Returns the constant default value when @kind is @"C"
	public final property Cvalue: Object = {
		get(): Object {
			if (m_cache !is bound) {
				if (m_docstring[1] == "P") {
					m_cache = decodeName(m_docstring.substr(2));
				} else {
					local ds = m_docstring.substr(1);
					m_cache = try
						"." in ds
							? float(ds)
							: int(ds)
						catch (...)
							ds;
				}
			}
			return m_cache;
		}
	}

	@@Initialize @m_cache as @(module_name: string | module | none, module_attr: string | none)
	@@When @module_name is set to @".", refer to the current module.
	private Edecode() {
		switch (m_docstring[1]) {

		case "D":
			m_cache = (deemon, m_docstring.substr(2));
			break;

		case "U":
			m_cache = (none, m_docstring.substr(2));
			break;

		case "G":
			m_cache = (".", m_docstring.substr(2));
			break;

		case "E": {
			local sep = findNonEscaped(m_docstring, ":", 2);
			if (sep < 0) {
				m_cache = (m_docstring.substr(2), none);
			} else {
				m_cache = (m_docstring.substr(sep), m_docstring.substr(sep + 1));
			}
		}	break;

		case "M":
			m_cache = (m_docstring.substr(2), none);
			break;

		default:
			m_cache = (none, m_docstring);
			break;
		}
	}

	@@Returns the doc-path for the externally referenced
	@@object, or @none if that path is unavailable.
	public final property Epath: string | none = {
		get(): string | none {
			local modnam = Emodulename;
			if (modnam is none)
				return none;
			local att = Emoduleattr;
			if (att is none)
				return "/" + modnam;
			return f"/{modnam}/{att}";
		}
	}

	@@Return the doc node for the externally referenced
	@@object, or @none if that object cannot be traced.
	public final property Enode: Doc | none = {
		get(): Doc | none {
			local mod = Emodule;
			if (mod is none)
				return none;
			return Doc(mod, Emoduleattr);
		}
	}

	@@The module that is being imported
	public final property Emodule: Module | none = {
		get(): Module | none {
			if (m_cache !is bound)
				Edecode();
			local result = m_cache[0];
			if (result !is Module && result !is none) {
				if (result.startswith(".")) {
					local base = docnode.value.module;
					result = result == "."
						? base
						: import(result, base: base)
						;
				} else {
					result = import(result);
				}
			}
			return result;
		}
	}

	@@The name of the module that is being imported
	public final property Emodulename: string | none = {
		get(): string | none {
			if (m_cache !is bound)
				Edecode();
			local result = m_cache[0];
			if (result is Module)
				result = Module.__name__(result);
			return result;
		}
	}

	@@The name of the attribute that is being imported from the @Emodule
	@@If the external reference applies directly to a module, evaluate to @none
	public final property Emoduleattr: string | none = {
		get(): string {
			if (m_cache !is bound)
				Edecode();
			return m_cache[1];
		}
	}

	@@The external object that is being referenced
	public final property Evalue: Object | none = {
		get(): Object | none {
			local mod = Emodule;
			local att = m_cache[1];
			if (mod !is none && att !is none)
				mod = mod.operator . (att);
			return mod;
		}
	}

	@@Returns the referenced parameter when @kind is @"A"
	public final property Aparam: Parameter | none = {
		get(): Parameter {
			if (m_cache !is bound) {
				/* HINT: If this line causes a ReferenceError to be thrown, then
				 *       you must store the Doc node used to access parameters in
				 *       a temporary variable.
				 * >> import * from deemon;
				 * >> import * from doc;
				 * >> function foo(x: string = "foo"): type(x) {
				 * >> 	return x;
				 * >> }
				 * >>
				 * >> print Doc(foo).decls[0].ret.types...; // Wrong!
				 * >>
				 * >> local d = Doc(foo);
				 * >> print d.decls[0].ret.types...; // OK
				 * >>
				 * This is required, because in the later case, the compiler is
				 * required to keep `d' alive for the duration of enumeration of
				 * the function's return types.
				 * In the first variant, the compiler isn't required to do this,
				 * leading to the weak references we use to point back to the
				 * original doc node to have become stale, causing the `value'
				 * dereference in the following line to read a dead WeakRef.
				 */
				m_cache = docdecl.value.getparambyname(
					decodeName(m_docstring.substr(3)));
			}
			return m_cache;
		}
	}

	@@Returns the name of the undefined object referenced
	public final property Uname: string = {
		get(): string {
			if (m_cache !is bound)
				m_cache = decodeName(m_docstring.substr(2));
			return m_cache;
		}
	}

	@@Returns the sequence element expression of @this
	public final property Sitems: {Expression...} = {
		get(): {Expression...} {
			if (m_cache !is bound) {
				local pos = 3;
				while (pos < #m_docstring && m_docstring.isdigit(pos))
					++pos;
				local count = try int(m_docstring.substr(2, pos)) catch (...) 0;
				local items = List(count);
				for (local i: [:count]) {
					local start = pos;
					pos = deflexpr_end(m_docstring, pos);
					items[i] = Expression(docdecl, m_docstring.substr(start, pos));
				}
				m_cache = Tuple(items);
			}
			return m_cache;
		}
	}

	@@Returns the sequence type of @this, which is one of:
	@@ - @List
	@@ - @Tuple
	@@ - @Dict
	@@ - @HashSet
	public final property Stype: Type = {
		get(): Type {
			local map = {
				"L" : List,
				"T" : Tuple,
				"D" : Dict,
				"S" : HashSet,
			};
			return map[m_docstring[1]];
		}
	}

	@@Similar to @Stype, but return the associated type expression
	public final property StypeExpr: TypeExpr = {
		get(): TypeExpr {
			local map = {
				"L" : "?DList",
				"T" : "?DTuple",
				"D" : "?Ddict",
				"S" : "?Dhashset",
			};
			return TypeExpr(docdecl, map[m_docstring[1]]);
		}
	}

	@@Returns the real-name (e.g. @"add") of the operator being invoked
	public final property Ooperator: string = {
		get(): string {
			/* TODO */
			return "add";
		}
	}

	@@Return the operands of @this Expression
	public final property Ooperands: {Expression...} = {
		get(): {Expression...} {
			/* TODO */
			return {};
		}
	}

	operator str(): string {
		/* TODO: Should instead return a human-readable representation of the expression.
		 *  !t -> true
		 *  !C!Umy_instance -> copy(my_instance)
		 */
		switch (kind) {

		case "C":
			return repr Cvalue;

		case "A":
			return Aparam.name;

		case "E": {
			local mod = Emodulename;
			local att = Emoduleattr;
			if (mod is none)
				return str att;
			if (att is none)
				return mod;
			return f"{mod}.{att}";
		}

		case "U":
			return Uname;

		case "S":
			switch (m_docstring[1]) {

			case "L":
				return f"[{','.join(Sitems)}]";

			case "T": {
				local t = Tuple(Sitems);
				if (!t) return "()";
				if (#t == 1)
					return f"({t[0]},)";
				return f"({','.join(t)})";
			}

			case "D": {
				File.Writer result;
				result << "{ ";
				local is_first = true;
				for (local a, b: Sitems.segments(2)) {
					if (!is_first)
						result << ", ";
					is_first = false;
					result << a << " : " << b;
				}
				result << (is_first ? "}" : " }");
				return result.string;
			}

			case "S":
				return f"\{ {', '.join(Sitems)} \}";

			default:
				break;
			}
			break;

		case "O":
			/* TODO: Operator */
			return "TODO:operator:" + docstring;

		default:
			break;
		}
		return docstring;
	}
}


class Parameter: WeakRefAble {

	@@The raw documentation string for this parameter
	@@Example: @"x:?Dint"
	public final member docstring: string;

	@@The declaration that @this parameter is apart of
	public final member docdecl: WeakRef with Declaration;

	@@The argument index of this parameter
	public final member docargi: int;

	this(d: Declaration | WeakRef with Declaration, argi: int, ds: string)
		: docdecl(d is WeakRef ? d : WeakRef(d))
		, docargi(argi)
		, docstring(ds)
	{}

	private member m_namstring: string; /* Already decoded (using decodeName) */
	private member m_typstring: string | none; /* in <TYPE> encoding */
	private member m_defstring: string | none; /* in <EXPR> encoding */
	private member m_isoptional: bool;
	private member m_isvarargs: bool;
	private member m_iskwargs: bool;

	@@Decode @docstring to extract information
	private decode_docstring() {
		m_isoptional = m_isvarargs = m_iskwargs = false;
		m_typstring = m_defstring = none;
		local doclen = #docstring;
#if 0 /* Disabled, as this breaks for stuff like `filler=!P{ }' */
		/* For backwards-compatibility, check for old-type parameter
		 * declarations in the form of `int x', something that we
		 * identify by searching for a non-escaped space-character,
		 * which we then interpret as the delimiter between name & type */
		local type_end = findNonEscaped(docstring, " ");
		if (type_end >= 0) {
			/* Since old-style declarations were sometimes also written
			 * as `int x, int y', meaning we'd end up with " int y", we
			 * must repeat the check after stripping whitespace.
			 * However, since non-escaped whitespace isn't actually
			 * allowed as part of the new system, it should already
			 * be clear that we're dealing with a new-style parameter. */
			docstring = docstring.strip();
			doclen = #docstring;
			type_end = findNonEscaped(docstring, " ");
			if (type_end >= 0) {
				m_typstring = docstring.substr(0, type_end);
				m_namstring = docstring.substr(type_end + 1).lstrip();
				/* Also check for a default argument. */
				if ("=" in m_namstring) {
					m_namstring, none, m_defstring = m_namstring.partition("=")...;
					m_namstring = m_namstring.strip();
					m_defstring = m_defstring.strip();
				}
				for (;;) {
					if (m_namstring.endswith("...")) {
						/* Old-style, typed varargs argument */
						m_namstring = m_namstring.substr(0, #m_namstring - 3).rstrip();
						m_isvarargs = true;
						m_iskwargs = m_isoptional = false;
						continue;
					}
					if (m_namstring.startswith("...")) {
						/* Old-style, typed varargs argument */
						m_namstring = m_namstring.substr(3).lstrip();
						m_isvarargs = true;
						m_iskwargs = m_isoptional = false;
						continue;
					}
					if (m_namstring.endswith("?")) {
						/* Old-style, typed optional argument */
						m_namstring = m_namstring.substr(0, #m_namstring - 1).rstrip();
						m_isoptional = true;
						m_iskwargs = m_isvarargs = false;
						continue;
					}
					if (m_namstring.startswith("?")) {
						/* Old-style, typed optional argument */
						m_namstring = m_namstring.substr(1).lstrip();
						m_isoptional = true;
						m_iskwargs = m_isvarargs = false;
						continue;
					}
					if (m_namstring.startswith("**")) {
						/* Old-style, typed optional argument */
						m_namstring = m_namstring.substr(2).lstrip();
						m_iskwargs = true;
						m_isvarargs = m_isoptional = false;
						continue;
					}
					break;
				}
				for (;;) {
					/* Old-style conventions also allowed
					 * the ... to appear as part of the type. */
					if (m_typstring.endswith("...")) {
						m_typstring = m_typstring.substr(0, #m_typstring - 3).rstrip();
						m_isvarargs = true;
						m_iskwargs = m_isoptional = false;
						continue;
					}
					if (m_typstring.endswith("**")) {
						m_typstring = m_typstring.substr(0, #m_typstring - 2).rstrip();
						m_iskwargs = true;
						m_isvarargs = m_isoptional = false;
						continue;
					}
					break;
				}
				return;
			}
		}
#endif
		if (!doclen) {
			/* Try to extract the argument name from varkwds information */
			m_namstring = getGenericArgumentName(
				docargi, docdecl.value.docsect.value.docnode.value);
			return;
		}
		/* Decode the parameter string new-style. */
		local name_end;
		if (docstring.issymstrt(0)) {
			/* Non-escaped argument name. */
			for (name_end = 1; name_end < doclen; ++name_end) {
				if (!docstring.issymcont(name_end))
					break;
			}
			m_namstring = docstring.substr(0, name_end);
		} else if (docstring[0] == "{") {
			/* Escaped argument name. */
			name_end = findNonEscaped(docstring, "}", 1);
			if (name_end < 0)
				name_end = doclen;
			m_namstring = decodeNameContent(docstring.substr(1, name_end));
			if (name_end < doclen)
				++name_end;
		} else {
			/* Parameter is unnamed. */
			m_namstring = getGenericArgumentName(
				docargi, docdecl.value.docsect.value.docnode.value);
			name_end = 0;
		}
		if (name_end >= doclen)
			return;
		switch (docstring[name_end]) {

		case "?":
			m_isoptional = true;
			++name_end;
			break;

		case "!":
			++name_end;
			if (name_end < doclen && docstring[name_end] == "!") {
				++name_end;
				m_iskwargs = true;
			} else {
				m_isvarargs = true;
			}
			break;

		default: break;
		}
		if (name_end >= doclen)
			return;
		if (docstring[name_end] == ":") {
			/* Argument type */
			++name_end;
			local typend = findNonEscaped(docstring, "=", name_end);
			if (typend >= 0) {
				/* Default expression */
				m_typstring = docstring.substr(name_end, typend);
				m_defstring = docstring.substr(typend + 1);
			} else {
				m_typstring = docstring.substr(name_end);
			}
			return;
		}
		if (docstring[name_end] == "=") {
			m_defstring = docstring.substr(name_end + 1);
			/* Try to determine the default value of the Parameter */
			if (m_typstring is none) {
				local types = Tuple(defexpr.exprtypes);
				if (types) {
					if (#types == 1) {
						m_typ = types[0];
						/* An implicit non-argument should not be interpreted
						 * as the argument requiring to be typed as `none' */
						if (m_typ.isnone) {
							m_typstring = "?O";
							del m_typ;
						} else {
							m_typstring = m_typ.docstring;
						}
					} else {
						m_typstring = f"?X{#types}{
							(for (local x: types) x.docstring) + ...
						}";
					}
				}
			}
			return;
		}
		if (docstring.startswith("...", name_end)) {
			/* Old-style varargs suffing without explicit typing */
			m_isvarargs = true;
			m_iskwargs = m_isoptional = false;
			name_end += 3;
		}
		/* Undefined suffix... */
	}

	@@The decoded name of @this Parameter
	public final property name: string = {
		get(): string {
			if (m_namstring !is bound)
				decode_docstring();
			return m_namstring;
		}
	}

	@@The <TYPE>-encoded typing of @this Parameter
	@@When unspecified, evaluates to @none instead
	public final property typstring: string | none = {
		get(): string | none {
			if (m_typstring !is bound)
				decode_docstring();
			return m_typstring;
		}
	}

	@@A descriptor for the typing of @this parameter
	public final property typ: TypeExpr = {
		get(): TypeExpr {
			if (m_typ !is bound) {
				local typstr = typstring;
				if (typstr is none)
					typstr = "?O";
				m_typ = TypeExpr(docdecl, typstr);
			}
			return m_typ;
		}
	}
	private member m_typ: TypeExpr;

	@@Alias for @this.typ.isaccepted(ob)
	public final isaccepted(ob: Object): bool {
		return typ.isaccepted(ob);
	}

	@@The <EXPR>-encoded default value of @this Parameter
	@@When unspecified, evaluates to @none instead
	public final property defstring: string | none = {
		get(): string | none {
			if (m_defstring !is bound)
				decode_docstring();
			return m_defstring;
		}
	}

	@@A descriptor for the default value of @this parameter
	@@When not given, default to @none
	public final property defexpr: Expression | none = {
		get(): Expression | none {
			if (m_defexpr !is bound) {
				local defstr = defstring;
				if (defstr is none) {
					m_defexpr = none;
				} else {
					if (!defstr) {
						/* Try to load the default value from the documented object. */
						local node = docdecl.lock(none)
							.docsect.lock(none)
							.docnode.lock(none);
						if (node !is none && node.object is bound) {
							local ob = node.object;
							if (ob is Function) {
								/* Extract from default argument list of user-level function */
								local code = ob.__code__;
								local argc_min = code.__argc_min__;
								if (docargi >= argc_min &&
								    docargi <  code.__argc_max__) {
									/* Default argument is available. */
									local val = code.__default__[docargi - argc_min];
									m_defexpr = Expression(docdecl, false, val);
									goto done;
								}
							}
						}
					}
					m_defexpr = Expression(docdecl, defstr);
				}
			}
done:
			return m_defexpr;
		}
	}
	private member m_defexpr: Expression | none;


	@@Evaluates to @true if @this Parameter is an optional argument
	public final property isoptional: bool = {
		get(): string | none {
			if (m_isoptional !is bound)
				decode_docstring();
			return m_isoptional;
		}
	}

	@@Evaluates to @true if @this Parameter is a varargs argument
	public final property isvarargs: bool = {
		get(): bool {
			if (m_isvarargs !is bound)
				decode_docstring();
			return m_isvarargs;
		}
	}

	@@Evaluates to @true if @this Parameter is a varkwds argument
	public final property isvarkwds: bool = {
		get(): bool {
			if (m_iskwargs !is bound)
				decode_docstring();
			return m_iskwargs;
		}
	}

	@@Returns A pretty, human-readable representation of this parameter
	operator str(): string {
		File.Writer fp;
		if (isvarkwds)
			fp << "**";
		fp << name;
		if (isoptional) {
			fp << "?";
		} else if (isvarargs) {
			fp << "...";
		}
		fp << ": ";
		fp << typ;
		local def = defexpr;
		if (def !is none) {
			fp << " = " << def;
		}
		return fp.string;
	}

	@@Returns a string representation of how @this Parameter can be created
	operator repr(): string {
		return f"Parameter({
			repr docdecl.lock(none)
		}, {
			repr docargi
		}, {
			repr docstring
		})";
	}
}



@@Declaration descriptor for a function or field
class Declaration: WeakRefAble {

	@@The raw documentation string for this declaration
	@@Example: @"(x:?Dint)->?Dint"
	public final member docstring: string;

	@@The Doc section containing @this declaration
	public final member docsect: WeakRef with DocSection;

	@@True if @this Declaration is for an operator
	@@This is the case when the associated doc-node is a type,
	@@as operator declarations are made as part of the doc string
	@@of a type, rather than have their own storage locations.
	public final property isoperator: bool = {
		get(): bool {
			return docsect.value.docnode.value.istype;
		}
	}

	this(s: DocSection | WeakRef with DocSection, ds: string)
		: docsect(s is WeakRef ? s : WeakRef(s))
		, docstring(ds)
	{}

	private member m_parstring: string | none; /* Argument List */
	private member m_namstring: string | none;
	private member m_retstring: string | none;
	private member m_opname: string | none;
	private member m_isdeleted: bool;
	private member m_isinherited: bool;
	private member m_explittype: bool;

	private defaultOperatorImpl(opname: string): string | none {
		return getDefaultOperatorWithType(
			docsect.lock(none).docnode.lock(none).object, opname);
	}

	@@Split @docstring into its individual segments
	private splitDeclString() {
		local ds = docstring;
		local par_start = findNonEscaped(ds, "(");
		local ret_start = ds.rfind("->");
		m_parstring = m_namstring = m_retstring = none;
		m_isdeleted = m_isinherited = m_explittype = false;
		if (par_start >= 0) {
			if (ret_start > 0 && ds[ret_start - 1] == ")") {
				m_parstring = ds.substr(par_start + 1, ret_start - 1);
			} else if (ds[#ds - 1] == ")") {
				m_parstring = ds.substr(par_start + 1, #ds - 1);
			}
		}
		if (par_start >= 0) {
			if (par_start > 0)
				m_namstring = ds.substr(0, par_start);
		} else if (ret_start > 0) {
			m_namstring = ds.substr(0, ret_start);
		}
		if (ret_start >= 0) {
			m_retstring = ds.substr(ret_start + 2);
			if (m_parstring is none) {
				if (m_retstring == "!D") { /* Deleted operator. */
					m_retstring = none;
					m_isdeleted = true;
					return;
				}
				if (m_retstring == "!S") { /* Inherited operator. */
					m_retstring = none;
					m_isinherited = true;
					return;
				}
				if (isoperator) {
					/* Generate default parameter information for operators */
					m_parstring = "";
					local defl = defaultOperatorImpl(opname);
					if (defl !is none) {
						local rt = defl.rfind("->");
						if (rt >= 0) {
							m_parstring = defl.substr(1, rt - 1);
							if (!m_retstring)
								m_retstring = defl.substr(rt + 2);
						}
					}
				} else if (docsect.value.docnode.value.isfunction) {
					m_parstring = ""; /* Default to an empty argument list for functions */
				}
			}
			m_explittype = true;
			if (!m_retstring) {
				m_explittype = false;
				if (isoperator) {
					local defl = defaultOperatorImpl(opname);
					if (defl !is none) {
						local rt = defl.rfind("->");
						if (rt >= 0) {
							/* Generate default declaration information for operators */
							m_retstring = defl.substr(rt + 2);
						}
					}
				}
			}
		} else if (m_parstring is none) {
			/* Default to returning `Object' when the parameter List was omitted. */
			m_retstring = "";
			if (isoperator) {
				local defl = defaultOperatorImpl(opname);
				if (defl !is none) {
					local rt = defl.rfind("->");
					if (rt >= 0) {
						/* Generate default declaration information for operators */
						m_retstring = defl.substr(rt + 2);
						m_parstring = defl.substr(1, rt - 1);
					}
				}
			}
		}
	}

	@@Returns the (paren-stripped) string associated with the argument list
	@@portion of @this Declaration. - If the declaration doesn't include an
	@@explicit argument list, @none is returned instead.
	public final property parstring: string | none = {
		get(): string | none {
			if (m_parstring !is bound)
				splitDeclString();
			return m_parstring;
		}
	}

	@@Returns the name of the declaration (as used to describe the name
	@@of an operator when encountered inside of a type-expression)
	@@If no such name has been defined, return @none instead.
	public final property namstring: string | none = {
		get(): string | none {
			if (m_namstring !is bound)
				splitDeclString();
			return m_namstring;
		}
	}

	@@Evaluates to @true if @this declaration refers to a member/operator
	@@that has been explicitly deleted and will throw a @Error.RuntimeError.NotImplemented
	@@error, should the user attempt to invoke it.
	public final property isdeleted: bool = {
		get(): bool {
			if (m_isdeleted !is bound)
				splitDeclString();
			return m_isdeleted;
		}
	}

	@@Evaluates to @true if @this declaration refers to an member/operator
	@@that has explicitly been inherited from a base-class.
	@@The most notable example of this is an inherited constructor, as
	@@can easily be achieved by user-code writing @(this = super;)
	public final property isinherited: bool = {
		get(): bool {
			if (m_isinherited !is bound)
				splitDeclString();
			return m_isinherited;
		}
	}

	@@Evaluates to @true if the return type of @this declaration has been
	@@explicitly defined. When @false, the return type was either implied
	@@as @Object (when a return arrow was present, but no return type), or
	@@as automatically deduced (as done for operators, as well as for function
	@@prototypes implying a none-return type when a parameter List is given,
	@@but no return arrow was found)
	public final property istypeexplicit: bool = {
		get(): bool {
			if (m_explittype !is bound)
				splitDeclString();
			return m_explittype;
		}
	}

	@@Similar to @namstring, however automatically translate operator names
	public final property opname: string | none = {
		get(): string | none {
			if (m_opname !is bound) {
				local name = namstring;
				if (name is none) {
					m_opname = "constructor";
				} else {
					m_opname = getRealOperatorName(name);
					/* Check if also need argument count to deduce the real operator name */
					if (m_opname is none)
						m_opname = getRealOperatorName(name, #parameters);
				}
			}
			return m_opname;
		}
	}

	@@Returns the name of @this Declaration
	public final property name: string = {
		get(): string {
			local node = docsect.value.docnode.value;
			if (node.istype)
				return opname;
			return node.name;
		}
	}

	@@Returns the return expression string (as used to describe the typing
	@@of a member-like declaration, or the return type of a function-like one)
	@@If no type expression has been defined, return @none instead.
	@@Note when this evaluates to an empty string, @\"deemon.Object\" is returned.
	public final property retstring: string | none = {
		get(): string | none {
			if (m_retstring !is bound)
				splitDeclString();
			return m_retstring;
		}
	}

	@@Returns @true if the return type of @this declaration is always @none
	public final property returnsnone: bool = {
		get(): bool {
			local retstr = m_retstring;
			return retstr is none || retstr in ["?N", "?Dnone", "?Edeemon:none"];
		}
	}

	@@The return type of @this Declaration (i.e. the
	@@type expression found after the @"->" arrow)
	@@When @isdeleted is @true, this property evaluates
	@@to @(TypeExpr(..., "?N")) (aka. @none)
	public final property ret: TypeExpr = {
		get(): TypeExpr {
			if (m_typ !is bound) {
				local retstr = retstring;
				if (retstr is none) {
					m_typ = TypeExpr(this, "?N");
				} else if (!retstr) {
					m_typ = TypeExpr(this, "?O");
				} else {
					m_typ = TypeExpr(this, retstr);
				}
			}
			return m_typ;
		}
	}
	private member m_typ: TypeExpr;

	@@Split @parstring into the individual parameters described by it
	public final property parameters: {Parameter...} | none = {
		get(): {Parameter...} | none {
			if (m_parameters !is bound) {
				local parstr = parstring;
				if (parstr is none) {
					local doc = docsect.value.docnode.value;
					if (doc.isfunction) {
						m_parameters = [Parameter(this, 0, "args!")];
					} else {
						m_parameters = none; /* No parameters */
					}
				} else {
					m_parameters = Tuple(
						for (local i, part: util.enumerate(splitNonEscaped(parstr, ",")))
							Parameter(this, i, part));
				}
			}
			return m_parameters;
		}
	}
	private member m_parameters: {Parameter...} | none;

	@@Return a function parameter, given its name
	public final getparambyname(name: string): Parameter | none {
		for (local p: parameters) {
			if (p.name == name)
				return p;
		}
		return none;
	}

	@@If @this declaration is that of a function or operator, check if the
	@@type specifications of that function allow the given @args to be used
	@@in a call to the function or operator
	public final isaccepted(args...: Object): bool {
		local par = parameters;
		if (par is none)
			return false;
		if (#args != #par) /* TODO: Varargs, optional, default, ... */
			return false;
		for (local i: [:#args]) {
			if (!par[i].isaccepted(args[i]))
				return false;
		}
		return true;
	}

	@@Returns @this declaration as a pretty, human-readable string
	operator str(): string {
		local name = this.name;
		if (isdeleted)
			return f"{name} = del";
		if (isinherited)
			return f"{name} = super";
		local par = this.parameters;
		if (par !is none) {
			if (returnsnone) {
				return f"{name}({', '.join(par)})";
			} else {
				return f"{name}({', '.join(par)}): {ret}";
			}
		}
		return f"{name}: {ret}";
	}

	@@Returns a string representation of how @this Declaration can be created
	operator repr(): string {
		return f"Declaration({
			repr docsect.lock(none)
		}, {
			repr docstring
		})";
	}
}

class TextSegment: WeakRefAble {

	@@The raw documentation string for this text segment
	@@Example for @"(x:?Dint,y:?Dint)->?Dint\nAdd together 2 numbers":
	@@            @"Add together 2 numbers"
	public final member docstring: string;

	@@The Doc section containing @this text segment
	public final member docsect: WeakRef with DocSection;

	this(s: DocSection | WeakRef with DocSection, ds: string)
		: docsect(s is WeakRef ? s : WeakRef(s))
		, docstring(ds)
	{}

	@@Enumerate all of different parts that make up this text segment
	operator for(): {(string | Object)...} {
		local dc = import("doctext");
		local doc = this.docsect.lock(none).docnode.lock(none);
		return dc.splitTextSegment(
			docstring: this.docstring,
			mypath: (doc.path, doc.istype)
		);
	}

	function printConsoleString(p /*: ConsolePrinter*/) {
		for (local part: this)
			p << part;
	}

	@@Returns the formated documentation string of this text segment
	operator str(): string {
		local dc = import("doctext");
		local p = dc.ConsolePrinter();
		printConsoleString(p);
		return p.fp.string;
	}

	@@Returns a string representation of how @this TextSegment can be created
	operator repr(): string {
		return f"TextSegment({
			repr docsect.lock(none)
		}, {
			repr docstring
		})";
	}

}


@@Split the text of a @DocSection into a sequence of @(Declaration)s and @(TextSegment)s
local function splitSegments(sect: DocSection, docstring: string): {Declaration | TextSegment...} {
	local start = 0;
	while (docstring.startswith("(", start)) {
		/* The first line is already is one that is special */
		local newstart = findNonEscaped(docstring, "\n", start);
		if (newstart < 0) newstart = #docstring;
		yield Declaration(sect, docstring.substr(start, newstart));
		start = newstart + 1;
	}
	for (;;) {
		local i = docstring.find("\n(", start);
		local j = docstring.find("->", start);
		if (i < 0) {
			if (j < 0)
				break;
			i = rfindNonEscaped(docstring, "\n", start, j);
			if (i < 0) i = start;
		} else {
			++i;
			if (j >= 0 && j < i) {
				i = rfindNonEscaped(docstring, "\n", start, j);
				if (i < 0) i = start;
			}
		}
		if (i - 1 > start)
			yield TextSegment(sect, decodeText(docstring.substr(start, i - 1)));
		local line_end = findNonEscaped(docstring, "\n", i);
		if (line_end < 0) line_end = #docstring;
		yield Declaration(sect, docstring.substr(i, line_end));
		start = line_end + 1;
	}
	if (start < #docstring)
		yield TextSegment(sect, decodeText(docstring.substr(start)));
}


class DocSection: WeakRefAble {

	@@The raw documentation string for this doc section
	public final member docstring: string;

	@@The Doc node of which this is a section.
	@@NOTE: For operator DocSections, this refers to the type node, not the operator node!
	public final member docnode: WeakRef with Doc;

	this(d: Doc | WeakRef with Doc, ds: string)
		: docnode(d is WeakRef ? d : WeakRef(d))
		, docstring(ds)
	{}

	@@Enumerate all operator sections contained within this DocSection
	@@as tuples of @(operatorName: string, section: DocSection)
	public final enumerateOperatorSections(): {string: DocSection} {
		local seg = segments;
		for (local i = 0; i < #seg; ++i) {
			local s = seg[i];
			if (s !is Declaration)
				continue;
			local opname = s.opname;
			if (opname is none)
				continue;
			local result_segments = [s];
			for (local j = i + 1; j < #seg; ++j) {
				s = seg[j];
				if (s is Declaration /*&& s.opname != opname*/)
					continue;
				result_segments.append(s);
			}
			if (#result_segments == #m_segments) {
				yield (opname, this);
				return;
			}
			local result = DocSection(
				docnode,
				"\n".join(
					for (local x: result_segments)
						x.docstring));
			result.m_hasdecls = true;
			result.m_segments = result_segments;
			yield (opname, result);
		}
	}


	@@Check if @this DocSection contains a declaration for a given operator @name
	@@If it does, return a new DocSection containing all of the associated
	@@sub-segments containing information about that operator.
	public final getopsection(name: string): {DocSection...} | none {
		local seg = segments;
		for (local i = 0; i < #seg; ++i) {
			local s = seg[i];
			if (s !is Declaration)
				continue;
			if (s.opname != name)
				continue;
			local result_segments = [s];
			for (local j = i + 1; j < #seg; ++j) {
				s = seg[j];
				if (s is Declaration /*&& s.opname != opname*/)
					continue;
				result_segments.append(s);
			}
			if (#result_segments == #m_segments) {
				yield this;
				return;
			}
			local result = DocSection(
				docnode,
				"\n".join(
					for (local x: result_segments)
						x.docstring));
			result.m_hasdecls = true;
			result.m_segments = result_segments;
			yield result;
		}
	}

	@@Returns @docstring
	operator str(): string {
		return docstring;
	}

	@@Returns a string representation of how @this DocSection can be created
	operator repr(): string {
		return f"DocSection({
			repr docnode.lock(none)
		}, {
			repr docstring
		})";
	}

	@@Evalues to @true if @this DocSection contains declaration segments
	public final property hasdeclarations: bool = {
		get() {
			if (m_hasdecls !is bound) {
				for (local seg: segments) {
					if (seg !is Declaration)
						continue;
					m_hasdecls = true;
					return true;
				}
				m_hasdecls = false;
			}
			return m_hasdecls;
		}
	}
	private member m_hasdecls: bool;

	@@Split @this DocSection into segments of special doc-strings & human-text
	@@The returned Tuple is (is_declaration, content), where is_declaration is
	@@a line applicable to contain either the "->" or the "<START_OF_LINE>("
	@@pattern.
	public final property segments: {Declaration | TextSegment...} = {
		get() {
			if (m_segments !is bound)
				m_segments = Tuple(splitSegments(this, docstring));
			return m_segments;
		}
	}
	private member m_segments: {Declaration | TextSegment...};
}



@@Automatically generate documentation for a given @fun
local function generateFunctionParams(fp: File, fun: Function) {
	/* We can actually figure out a lot about this function! */
	local code = fun.__code__;
	local argc_min = code.__argc_min__;
	local argc_max = code.__argc_max__;
	local kwds = code.__kwds__;
	local n_kwds = #kwds;
	fp << "(";
	for (local i: [:argc_min]) {
		if (i != 0)
			fp << ",";
		if (i < n_kwds) {
			fp << kwds[i];
		} else {
			fp << getGenericArgumentName(i);
		}
	}
	if (argc_max > argc_min) {
		local defl = code.__default__;
		if (argc_min)
			fp << ",";
		for (local i: [:argc_max - argc_min]) {
			if (i != 0)
				fp << ",";
			if (i < n_kwds) {
				fp << kwds[i];
			} else {
				fp << getGenericArgumentName(i);
			}
			if (defl[i] !is bound) {
				fp << "?";
			} else {
				local default_value = defl[i];
				/* Only emit type information when the default value isn't none
				 * Since `none' is usually used as a placeholder, the user probably
				 * doesn't expect the user of this function to pass `none' intentionally. */
				if (default_value !is none)
					fp << ":" << encodeType(type(default_value));
				local defl = encodeExpression(default_value);
				if (defl !is none)
					fp << "=" << defl;
			}
		}
	}
	if (code.hasvarargs) {
		if (argc_max)
			fp << ",";
		fp << (argc_max < n_kwds
			? kwds[argc_max]
			: getGenericArgumentName(argc_max))
			<< "!";
	}
	fp << ")";
}



@@The main interface for accessing the documentation API provided by deemon
@@Documentation text is addressed using unambiguos paths structures as follows:
@@ - The string is split into segments separated by @"/"
@@ - Dangling leading and trailing slashes are ignored.
@@ - The first segment is a module name that describes which module to search
@@   for the documenation strings. If no slash follows, the Doc node will refer
@@   to that module as a whole
@@ - Otherwise, the remaining segment are walked left-to-right and used to dereference
@@   attribute names of their respective object.
@@
@@These attributes can optionally be prefixed with one of the following
@@modifiers in order to address different attributes namespaces:
@@
@@+--------+---------------------------------------------------+
@@| Prefix | Description                                       |
@@+--------+---------------------------------------------------+
@@| @""    | Either class-attribute, or instance-attribute     |
@@|        | (may lead to ambiguity when a name is re-used)    |
@@|        |                                                   |
@@| @"c:"  | Class-attribute (e.g. @string.chr)                |
@@|        |                                                   |
@@| @"i:"  | Instance-attribute (e.g. @string.find)            |
@@|        |                                                   |
@@| @"op:" | Real operator name (e.g. @"eq" instead of @"==")  |
@@+--------+---------------------------------------------------+
@@
@@Furthermore, child-nodes (attributes) can be reached using @child, and all existing
@@child nodes can be enumerated by using the doc-node as a sequence-like object.
@@
@@Some restrictions apply to Doc-nodes, most notably the restriction that the object
@@being documented must somehow by addressible as a module export, meaning that private
@@(local) functions or classes usually cannot be addressed, and that builtin objects
@@used by the deemon core, which aren't actually exported from the builtin deemon
@@module cannot be addressed without the use of the :rt module.
class Doc: WeakRefAble {

	@@A universally, unique path that can be used to address this Doc item
	@@NOTE: If the path cannot be determined, return @none instead
	@@NOTE: The returned path includes a leading @"/"
	public final property path: string | none = {
		get(): string {
			if (m_path !is bound) {
				if (name is none) {
					m_path = none;
				} else {
					local par = parent;
					if (par is none) {
						m_path = ismodule ? "/" + name : none;
					} else {
						par = parent.path;
						m_path = par is none
							? none
							: f"{par}/{name}";
					}
				}
			}
			return m_path;
		}
	}
	private member m_path: string | none;

	@@Similar to @path, but return the qualified path in <TYPE> encoding
	@@NOTE: Because <TYPE> encoding includes support for untracable components,
	@@      this property always evaluates to a string and simply uses
	@@      the @"?U" encoding when the qualified path cannot be determined.
	public final property qualpath: string = {
		get(): string {
			if (m_qualified_path !is bound) {
				if (name is none) {
					m_qualified_path = "?Uunknown";
				} else {
					local par = parent;
					if (par is none) {
						m_qualified_path = "?U" + encodeName(name);
					} else if (par.ismodule) {
						m_qualified_path = f"?E{
							/* TODO: This only works for global modules! */
							encodeName(par.name)
						}:{
							encodeName(name)
						}";
					} else {
						m_qualified_path = f"?A{encodeName(name)}{par.qualpath}";
					}
				}
			}
			return m_qualified_path;
		}
	}
	private member m_qualified_path: string;

	@@The name of this documentation object (last component of @path, stripped of its namespace prefix)
	@@Note the namespace prefix will have already been stripped from this string, though
	@@its typing can be recreated with the attributes @isclassattr and @isoperator
	@@
	@@May be set to @none when the name is unknown or not available (e.g. if @object is an anonymous function)
	public final member name: string | none;

	@@Returns the name of type, or @name if @istype is @false, or if the type is anonymous
	public final property typename: string | none = {
		get(): string {
			local result = none;
			if (istype && object is bound)
				result = Type.__name__(object);
			return result is none ? name : result;
		}
	}

	@@Similar to @name, but if @this Doc node is an operator, return
	@@that operator's name in the form of @"==", rather than @"eq"
	public final property prettyname: string | none = {
		get(): string {
			if (isoperator) {
				local res = PRETTY_OPERATOR_NAMES.get(name);
				if (res !is none)
					return res;
			}
			return name;
		}
	}

	@@Similar to @prettyname, but include an @"operator"
	@@prefix when @this Doc node describes an operator.
	public final property prettypathname: string | none = {
		get(): string {
			if (isoperator) {
				local res = PRETTY_OPERATOR_NAMES.get(name);
				if (res !is none)
					return "operator " + res;
			}
			return name;
		}
	}

	@@Similar to @prettyname, but also include the node kind,
	@@resulting in the form of @"operator ==" or @"function foo"
	public final property prettydesc: string = {
		get(): string {
			return f"{kind} {prettyname}";
		}
	}

	@@Similar to @path, but return in a form akin to @"deemon.string.operator =="
	@@Additionally, this name representation still provides good-looking results
	@@when @path would evaluate to @none
	public final property prettypath: string | none = {
		get(): string {
			local result = path;
			if (result is none) {
				local par = parent;
				if (par is none) {
					result = name;
					if (isoperator)
						result = "operator " + PRETTY_OPERATOR_NAMES.get(name, name);
					return result;
				}
				result = par.prettypath;
				if (isoperator) {
					result = f"{result}.operator {
						PRETTY_OPERATOR_NAMES.get(name, name)
					}";
				} else {
					result = f"{result}.{name}";
				}
				return result;
			}
			result = result.lstrip("/").replace("i:", "").replace("c:", "");
			if (isoperator) {
				result = result.rpartition("/")[0];
				result = f"{result}.operator {
					PRETTY_OPERATOR_NAMES.get(name, name)
				}";
			}
			return result.replace("/", ".");
		}
	}

	@@The object represented by @this Doc node (May be unbound)
	public final member object: Object;
	public final property attr: Attribute | none = {
		get(): Attribute | none {
			if (m_attr !is bound) {
				if (isoperator || parent is none || name is none) {
					m_attr = none;
				} else {
					m_attr = Attribute(parent.object, name);
				}
			}
			return m_attr;
		}
	}
	private member m_attr: Attribute | none;

	@@The parent doc, or @none when unknown or @this
	@@Doc node is already a top-level module node
	public property parent: Doc | none = {
		get(): Doc | none {
			if (m_parent !is Doc && m_parent !is none)
				m_parent = Doc(m_parent);
			return m_parent;
		}
	}
	private member m_parent: Doc | none;

	@@The raw documentation text associated with this node
	@@If no documentation string could be located, this is an empty string
	public final member docstring: string;

	@[optional.gatw.doc("(path:?Dstring)")]
	@[optional.gatw.doc("Lookup a given @path in the form $\"/<module>/<x>/<y>/<z>\"")]
	@[optional.gatw.doc("")]
	@[optional.gatw.doc("(mod:?DModule)")]
	@[optional.gatw.doc("Lookup the Doc node for a given module")]
	@[optional.gatw.doc("")]
	@[optional.gatw.doc("(tp:?DType)")]
	@[optional.gatw.doc("Lookup the Doc node for a given type")]
	@[optional.gatw.doc("")]
	@[optional.gatw.doc("(attr:?DAttribute)")]
	@[optional.gatw.doc("Lookup the Doc node for a given attribute")]
	@[optional.gatw.doc("")]
	@[optional.gatw.doc("(wrapper)")]
	@[optional.gatw.doc("Lookup the Doc node for a wrapper, as produced by expressions such as ${string.lower}")]
	@[optional.gatw.doc("")]
	@[optional.gatw.doc("(base:?DModule,attrname:?Dstring)")]
	@[optional.gatw.doc("(base:?DType,attrname:?Dstring)")]
	@[optional.gatw.doc("(base:?GDoc,attrname:?Dstring)")]
	@[optional.gatw.doc("(base,attrname:?Dstring)")]
	@[optional.gatw.doc("Lookup a given @attrname as a child of a given @base")]
	this(doc_parent_or_path, attribute_name?: Attribute | string, operator_doc?: {DocSection...}) {
		if (attribute_name !is bound) {
			if (doc_parent_or_path is Module) {
				/* Doc(module) */
				object    = doc_parent_or_path;
				m_attr    = none;
				docstring = "";
				m_parent  = none;
				name = Module.__name__(doc_parent_or_path);
				return;
			}
			if (doc_parent_or_path is Type) {
				/* Doc(Type) */
				local type_module;
load_type_input:
				object = doc_parent_or_path;
				m_parent = type_module = Type.__module__(doc_parent_or_path);
				docstring = Type.__doc__(doc_parent_or_path).rstrip();
				istype = true;
				name = Type.__name__(doc_parent_or_path);
				if (type_module is none) {
					m_attr = none;
					m_path = none;
				} else {
					m_attr = Attribute.lookup(type_module, name);
					if (m_attr is none) {
						module; /* ??? */
						m_parent = none;
						m_path = none;
					} else {
						m_path = f"/{Module.__name__(type_module)}/{name}";
					}
				}
				return;
			}
			if (doc_parent_or_path is Attribute) {
				/* Doc(Attribute) */
				name = doc_parent_or_path.name;
				local ds = doc_parent_or_path.doc;
				if (ds is none)
					ds = "";
				docstring = ds.rstrip();
				local decl = m_parent = doc_parent_or_path.decl;
				if (doc_parent_or_path.isclass) {
					local parob = decl;
					if (doc_parent_or_path.isinstance) {
						/* Use `type.getinstanceattr' to prevent ambiguity
						 * between stuff like `foo.c:field' and `foo.i:field' */
						object = Type.getinstanceattr(parob, name);
					} else {
						object = parob.operator . (name);
					}
				}
				m_attr = doc_parent_or_path;
				return;
			}
			/* Support for attribute wrappers */
			if (doc_parent_or_path !is string) {
				/* Check for singleton-like object instances. */
				local tp = type doc_parent_or_path;
				if (Type.__issingleton__(tp)) {
					doc_parent_or_path = tp;
					goto load_type_input;
				}
				name = doc_parent_or_path.__name__; /* NOTE: This may return `none'! */
				local ds = doc_parent_or_path.__doc__;
				if (ds is none)
					ds = "";
				docstring = ds.rstrip();
				object = doc_parent_or_path;
				if (hasattr(doc_parent_or_path, "__type__")) {
					local doc_type;
					try {
						doc_type = doc_parent_or_path.__type__;
					} catch (Error.AttributeError) {
						goto do_load_wrapper_module;
					}
					if (doc_type is none)
						goto do_load_wrapper_module;
					m_parent = doc_type;
				} else {
do_load_wrapper_module:
					local mod;
					try {
						mod = doc_parent_or_path.__module__;
					} catch (Error.AttributeError) {
						goto do_throw_unknown_object_origin;
					}
					if (mod is none) {
do_throw_unknown_object_origin:
						throw Error.AttributeError(
							f"Failed to determine the declaring type "
							f"or module of {repr doc_parent_or_path}");
					}
					m_parent = mod;
				}
				return;
			}
			local head, none, tail = doc_parent_or_path.strip("/ ").rpartition("/")...;
			if (!tail) {
				/* Module documentation */
				if (head.startswith(".")) {
					throw Error.ValueError(
						f"Module name {repr head} is not absolute");
				}
				object    = import(head);
				m_parent  = none;
				m_attr    = none;
				docstring = ""; /* XXX: Module documentation texts? */
				m_path    = "/" + head;
				name      = head;
				return;
			}
			doc_parent_or_path = Doc(head);
			attribute_name     = tail;
		}
		if (doc_parent_or_path !is Doc)
			doc_parent_or_path = Doc(doc_parent_or_path);
		local fixed_attribute_name;
		if (!doc_parent_or_path.haschildren) {
			if (attribute_name.startswith("op:")) {
				attribute_name = attribute_name[3:];
err_unknown_operator:
				throw Error.AttributeError(
					f"Unknown operator {repr attribute_name} in {repr doc_parent_or_path.path}");
			}
			fixed_attribute_name = attribute_name.lsstrip("i:").lsstrip("c:");
err_unknown_attribute:
			throw Error.AttributeError(
				f"Unknown attribute {repr fixed_attribute_name} in {repr doc_parent_or_path.path}");
		}
		m_parent = doc_parent_or_path;
		local my_attr;
		if (attribute_name is Attribute) {
			my_attr = attribute_name;
			fixed_attribute_name = attribute_name.name;
			attribute_name = f"{
				attribute_name.isinstance ? 'i:' :
				attribute_name.isclass ? 'c:' : ''
			}{fixed_attribute_name}";
		} else if (attribute_name.startswith("op:")) {
			/* Operator node. */
			local parpath = doc_parent_or_path.path;
			if (parpath is none) {
				m_path = none;
			} else {
				m_path = f"{parpath}/{attribute_name}";
			}
			attribute_name = name = attribute_name[3:];
			isoperator = true;
			local sect;
			if (operator_doc is bound) {
				/* Caller-provided documentation string */
				sect = Tuple(operator_doc);
			} else {
				/* Manually lookup the doc section associated with this operaotr. */
				sect = Tuple(doc_parent_or_path.getopdoc(attribute_name));
				if (!sect)
					goto err_unknown_operator;
			}
			m_docsections = m_allsections = sect;
			docstring = "\n\n".join(
				for (local s: sect)
					s.docstring
			).rstrip();
			return;
		} else {
			try {
				if (attribute_name.startswith("i:")) {
					fixed_attribute_name = attribute_name[2:];
					my_attr = Attribute(doc_parent_or_path.object, fixed_attribute_name, "i");
				} else if (attribute_name.startswith("c:")) {
					fixed_attribute_name = attribute_name[2:];
					my_attr = Attribute(doc_parent_or_path.object, fixed_attribute_name, "i", "");
				} else {
					fixed_attribute_name = attribute_name;
					my_attr = Attribute(doc_parent_or_path.object, fixed_attribute_name);
				}
			} catch (Error.AttributeError) {
				goto err_unknown_attribute;
			}
		}
		assert operator_doc !is bound;
		assert my_attr is bound;
		assert my_attr is Attribute;
		if (!my_attr.isprivate && !my_attr.isproperty) {
			local parob = doc_parent_or_path.object;
			if (parob is Type) {
				if (my_attr.isclass) {
					if (my_attr.isinstance) {
						/* Use `type.getinstanceattr' to prevent ambiguity
						 * between stuff like `foo.c:field' and `foo.i:field' */
						object = Type.getinstanceattr(parob, fixed_attribute_name);
					} else {
						try {
							object = parob.operator . (fixed_attribute_name);
						} catch (Error.AttributeError) {
						}
					}
				}
			} else if (my_attr.isinstance && fixed_attribute_name is bound) {
				object = parob.operator . (fixed_attribute_name);
			}
		}
		/* Types implement their own documentation strings. */
		if (object is bound) {
			if (object is Type) {
set_is_type:
				docstring = Type.__doc__(object).rstrip();
				istype = true;
			} else if (Type.__issingleton__(type(object))) {
				/* When accessing the documentation of a singleton object instance
				 * (as indicated by us having an instance of that singleton, when its
				 * type offers no way of being constructed; `this = del'), display
				 * documentation for the type instead of the singleton */
				object = type(object);
				issingleton = true;
				goto set_is_type;
			}
		}
		local tp = my_attr.attrtype;
		if (tp !is none && Type.derivedfrom(tp, Type))
			istype = true;
		/* If we couldn't load a non-empty doc string from other places,
		 * try to load the doc string from the attribute descriptor. */
		if (docstring !is bound || !docstring)
			docstring = my_attr.doc.rstrip();
		m_attr = my_attr;
		name = fixed_attribute_name;
		local parpath = doc_parent_or_path.path;
		if (parpath is none) {
			m_path = none;
		} else {
			m_path = f"{parpath}/{attribute_name}";
		}
	}

	@@Returns a string representation of how @this Doc node can be constructed
	operator repr(): string {
		return f"Doc({ repr path })";
	}

	@@Returns @true if @this doc node has allowed to refer to child nodes
	public final property haschildren: bool = {
		get() {
			if (object is bound) {
				if (object is Module)
					return true;
				if (object is Type)
					return true;
			}
			return false;
		}
	}

	@@Evaluates to @true if the object is function-like
	public final property isfunction: bool = {
		get() {
			if (isoperator)
				return true;
			local at = attr;
			if (at !is none && (at.cancall || Callable.baseof(at.attrtype)))
				return true;
			return object is bound && object is Callable;
		}
	}

	@@Evaluates to @true if the object is private to its class
	public final property isprivate: bool = {
		get() {
			local at = attr;
			return at !is none && at.isprivate;
		}
	}

	@@Evaluates to @true if the object is a class-attribute
	public final property isclassattr: bool = {
		get() {
			local at = attr;
			return at !is none && !attr.isinstance;
		}
	}

	@@Evaluates to @true if the object is a module
	public final property ismodule: bool = {
		get() {
			return object is bound && object is Module;
		}
	}

	@@Evaluates to @true if the object is a type
	public final member istype: bool = false;

	@@Evaluates to @true if the object is a type, but was accessed via a singleton
	@@An example of this is @gc or @none, which are both singleton objects
	@@that, when accessed via Doc, should display the documentation of their
	@@respective type, rather than what little text may be available for the
	@@single instance itself.
	@@Since such Doc nodes would otherwise be indistinguishable from nodes created
	@@for the actual types, nodes create via a singleton instance have this field
	@@set to @true
	public final member issingleton: bool = false;

	@@Evaluates to @true if the object is an operator
	public final member isoperator: bool = false;

	@@Evaluates to @true if the object can be read from
	public final property canget: bool = {
		get() {
			local at = attr;
			if (at !is none)
				return at.canget;
			return true;
		}
	}

	@@Evaluates to @true if the object can be deleted
	public final property candel: bool = {
		get() {
			local at = attr;
			if (at !is none)
				return at.candel;
			return true;
		}
	}

	@@Evaluates to @true if the object can be written to
	public final property canset: bool = {
		get() {
			local at = attr;
			if (at !is none)
				return at.canset;
			return true;
		}
	}



	@@Returns the kind of node, which is one of the following
	@@+-------------------+----------------------------------------+
	@@| Name              | Description (The node refers to a ...) |
	@@+-------------------+----------------------------------------+
	@@| @"module"         | module                                 |
	@@|                   |                                        |
	@@| @"type"           | type                                   |
	@@|                   |                                        |
	@@| @"singleton"      | type accessed via a singleton          |
	@@|                   |                                        |
	@@| @"function"       | function                               |
	@@|                   |                                        |
	@@| @"class_function" | class-function                         |
	@@|                   |                                        |
	@@| @"member"         | member or global module-variable       |
	@@|                   |                                        |
	@@| @"class_member"   | class-member                           |
	@@|                   |                                        |
	@@| @"property"       | property                               |
	@@|                   |                                        |
	@@| @"class_property" | class-property                         |
	@@|                   |                                        |
	@@| @"operator"       | operator                               |
	@@|                   |                                        |
	@@| @none             | The node kind could not be determined  |
	@@+-------------------+----------------------------------------+
	public final property kind: string | none = {
		get(): string | none {
			local at;
			if (istype)
				return issingleton ? "singleton" : "type";
			if (object !is bound) {
				at = attr;
				if (at is none)
					return "operator";
			} else {
				if (object is Module)
					return "module";
			}
			if (at !is bound)
				at = attr;
			if (at !is none) {
				if (at.isproperty)
					return at.isinstance ? "property" : "class_property";
				if (at.cancall || Callable.baseof(at.attrtype))
					return at.isinstance ? "function" : "class_function";
				return at.isinstance ? "member" : "class_member";
			}
			return none;
		}
	}

	@@Returns the module-node (i.e the path-base-node) of this node
	@@If the module could not be determined, return @none instead
	public final property modulenode: Doc | none = {
		get() {
			local x = this;
			for (;;) {
				if (x.parent !is none) {
					x = x.parent;
					continue;
				}
				if (x.ismodule)
					return x;
				break;
			}
			x = this;
			for (;;) {
				if (x.istype && x.object is bound) {
					local mod = Type.__module__(x.object);
					if (mod !is none)
						return Doc(mod);
				}
				if (x.parent is none)
					break;
			}
			return none;
		}
	}

	@@Returns the module (i.e the path-base) of this node
	@@If the module could not be determined, return @none instead
	public final property module: Module | none = {
		get() {
			local x = this;
			for (;;) {
				if (x.parent !is none) {
					x = x.parent;
					continue;
				}
				if (x.ismodule)
					return x.object;
				break;
			}
			x = this;
			for (;;) {
				if (x.istype && x.object is bound) {
					local mod = Type.__module__(x.object);
					if (mod !is none)
						return mod;
				}
				x = x.parent;
				if (x is none)
					break;
			}
			return none;
		}
	}

	@@Enable support for sorting of doc-nodes
	operator < (other: Doc): bool {
		local my_kind = kind;
		local ot_kind = other.kind;
		if (my_kind != ot_kind) {
			return
				KIND_SORTING_WEIGHTS.get(my_kind, 0) <
				KIND_SORTING_WEIGHTS.get(ot_kind, 0);
		}
		if (my_kind == "operator") {
			return
				OPERATOR_SORTING_WEIGHTS.get(name, 0) <
				OPERATOR_SORTING_WEIGHTS.get(other.name, 0);
		}
		return name < other.name;
	}

	@@Returns the type of the base class of @this node, or @none
	@@if @this node isn't a type, or if that type doesn't have a base.
	public final property objectbase: Type | none = {
		get(): Type | none {
			if (object !is bound || object !is Type)
				return none;
			return Type.__base__(object);
		}
	}

	@@Returns the doc-node for @objectbase
	public final property objectbasenode: Doc | none = {
		get(): Doc | none {
			local base = objectbase;
			if (base is none)
				return none;
			return Doc(base);
		}
	}

	@@Returns a set of all the declarations known for this node
	@@For type nodes, this is always an empty sequence, as operator
	@@declarations must be accessed via their individual nodes.
	public final property decls: {Declaration...} = {
		get(): {Declaration...} {
			for (local sect: docsections) {
				for (local seg: sect.segments) {
					if (seg is Declaration)
						yield seg;
				}
			}
		}
	}

	@@Return a function-like declaration found in the documenation
	@@of @this Doc node that matches the given argument list.
	@@If no such declaration could be found, return @none instead.
	public final declfor(args...: Object): Declaration | none {
		for (local d: decls)
			if (d.isaccepted(args...))
				return d;
		return none;
	}


	@@Check if one of @this doc's declarations accepts the given argument list.
	@@>function foo(x: int | string, y: int | float) {
	@@>    ...
	@@>}
	@@>print Doc(foo).isaccepted(10, 20);     /* true */
	@@>print Doc(foo).isaccepted(10, 1.0);    /* true */
	@@>print Doc(foo).isaccepted(10, "foo");  /* false */
	@@>print Doc(foo).isaccepted("bar", 20);  /* true */
	@@>print Doc(foo).isaccepted("bar", 1.0); /* true */
	@@>print Doc(foo).isaccepted();           /* false */
	public final isaccepted(args...: Object): bool {
		return declfor(args...) !is none;
	}

	@@Similar to @isaccepted, but return the type expression
	@@what gets returned by the declaration capable of accepting
	@@the given argument list.
	@@NOTE: This function does not actually perform a call!
	@@      It merely emulates the call and returns the type
	@@      expression describing the set of types possibly
	@@      returned by it.
	@@>import * from deemon;
	@@>import * from doc;
	@@>function foo(x: int, y: float): string | int {
	@@>    if (y == 0)
	@@>        return x;
	@@>    return str(x + y);
	@@>}
	@@>/* { int, string } */
	@@>print repr Doc(foo).callwith(10, 1.0).types;
	public final callwith(args...: Object): TypeExpr | none {
		return declfor(args...).ret;
	}

	@@Returns a sequence of all sections found on the documenation of @docstring
	public final property allsections: {DocSection...} = {
		get(): {DocSection...} {
			if (m_allsections !is bound) {
				m_allsections = [];
				for (local x: splitDocSections(docstring))
					m_allsections.append(DocSection(this, x));
			}
			return m_allsections;
		}
	}
	private member m_allsections: {DocSection...};

	@@Auto-generate declaration information for an operator @opname
	private final autogenerateOperatorDecl(opname: string): {DocSection...} {
		local defl = getDefaultOperatorWithType(
			object is bound ? object : none, opname);
		if (defl !is none)
			yield DocSection(this, opname + defl);
	}

	@@Autogenerate declarations for @this Doc node
	private autogenerateDecls(): {DocSection...} {
		if (isoperator) {
			yield parent.autogenerateOperatorDecl(name)...;
		} else if (object is bound && object is Function) {
			File.Writer resdoc;
			generateFunctionParams(resdoc, object);
			if (object.__code__.isconstructor) {
				/* Constructors always return @none */
			} else {
				resdoc << "->";
			}
			yield DocSection(this, resdoc.string);
		} else {
			local at = attr;
			if (at !is none) {
				local attr_type = at.attrtype;
				if (at.cancall || Callable.baseof(attr_type)) {
					yield DocSection(this, "(args!)->"); /* Some kind of function... */
				} else if (attr_type !is none) {
					yield DocSection(this, "->" + encodeType(attr_type));
				} else {
					yield DocSection(this, "->");
				}
			} else {
				yield DocSection(this, "->");
			}
		}
	}

	@@Returns a sequence of split documentation sections, as found within @docstring
	@@The sections returned by this function are those that should be listed to give
	@@an overview of the object being documented, essentially meaning that for types,
	@@documentation concerning operators is left omitted, while also adding automatic
	@@documentation for anything that doesn't already offer anything, auto-creating
	@@docs for functions and members.
	public final property docsections: {DocSection...} = {
		get(): {DocSection...} {
			if (m_docsections !is bound) {
				local result = allsections;
				if (istype) {
					local new_result = [];
					/* Filter out operator docs. (aka: any section containing declarations) */
					for (local sect: result) {
						if (!sect.hasdeclarations)
							new_result.append(sect);
					}
					result = new_result;
				} else {
					local has_desc = false;
					for (local sect: result) {
						if (sect.hasdeclarations) {
							has_desc = true;
							break;
						}
					}
					if (!has_desc) {
						/* Without any pre-defined declaration, autogenerate some. */
						local new_result;
						new_result = List(autogenerateDecls());
						new_result.extend(result);
						result = new_result;
					}
				}
				m_docsections = result;
			}
			return m_docsections;
		}
	}
	private member m_docsections: {DocSection...};

	@@Automatically generate documentation for native type constructors.
	private autogenerateNativeConstructorSections(): {DocSection...} {
		if (Type.__issuperconstructible__(object)) {
			yield DocSection(this, "constructor->!S");
		} else {
			local hasany = false;
			if (Type.__isnoargconstructible__(object)) {
				yield DocSection(this, "constructor()->");
				hasany = true;
			}
			if (Type.__isvarargconstructible__(object)) {
				yield DocSection(this, "constructor->");
				hasany = true;
			}
			if (!hasany)
				yield DocSection(this, "constructor->!D");
		}
	}


	@@Returns the DocSection(s) associated with a given @opname, which
	@@must be the operator's real name (e.g. @"eq", and not @"==")
	@@If the operator is implemented, but doesn't have an explicit
	@@section defined within the associated type's doc string, a
	@@documenation string for the operator will be generated automatically,
	@@including specific information about deleted operators.
	public final getopdoc(opname: string): {DocSection...} {
		if (!istype)
			return;
		local found_sections = false;
		for (local sect: allsections) {
			for (local os: sect.getopsection(opname)) {
				yield os;
				found_sections = true;
			}
		}
		if (!found_sections) {
			/* If the type implements or explicitly deletes the
			 * specified operator, auto-generate a doc for it. */
			if (object !is bound)
				return;
			if (Type.__isclass__(object)) {
				local cls = Type.__class__(object);
				/* Check if `cls' makes any mention of the operator
				 * For example: `operator str = del;' */
				local opaddr = cls.operators.get(opname);
				if (opaddr !is none) {
					/* The operator does indeed get overwritten by this class */
					local ctab = Type.__ctable__(object);
					if (ctab[opaddr] is bound) {
						local fun = ctab[opaddr];
						if (fun is Function) {
							File.Writer resdoc;
							resdoc << opname;
							generateFunctionParams(resdoc, fun);
							resdoc << "->";
							local defl = getDefaultOperatorWithType(object, opname);
							if (defl !is none) {
								local rt = findNonEscaped(defl, "->");
								resdoc << defl.substr(rt + 2);
							}
							yield DocSection(this, resdoc.string);
						} else {
							yield autogenerateOperatorDecl(opname)...;
						}
					} else {
						/* Deleted operator */
						yield DocSection(this, opname + "->!D");
					}
				}
			} else {
				if (Type.hasprivateoperator(object, opname)) {
					yield autogenerateOperatorDecl(opname)...;
				} else if (opname == "constructor") {
					yield autogenerateNativeConstructorSections()...;
				}
			}
		}
	}

	@@Enumerate all of the child operators of a type-like object
	private enumerateOperatorSections(): {string: {DocSection...}} {
		local result: {string: {DocSection...}} = Dict();
		for (local s: allsections) {
			for (local name, opsec: s.enumerateOperatorSections()) {
				local lst: {DocSection...} = result.get(name);
				if (lst is none)
					result[name] = lst = [];
				lst.append(opsec);
			}
		}
		/* Enumerate operators overwritten, but not documented */
		if (object is bound && istype) {
			if (Type.__isclass__(object)) {
				local ctab = Type.__ctable__(object);
				local cls = Type.__class__(object);
				local ops = cls.operators;
				if (cls.hassuperconstructor && "constructor" !in result)
					result["constructor"] = (DocSection(this, "constructor->!S"),);
				for (local name, addr: ops) {
					if (name !in result) {
						if (ctab[addr] is bound) {
							local fun = ctab[addr];
							if (fun is Function) {
								File.Writer resdoc;
								resdoc << name;
								generateFunctionParams(resdoc, fun);
								resdoc << "->";
								local defl = getDefaultOperatorWithType(object, name);
								if (defl !is none) {
									local rt = findNonEscaped(defl, "->");
									resdoc << defl.substr(rt + 2);
								}
								result[name] = (DocSection(this, resdoc.string),);
							} else {
								result[name] = Tuple(autogenerateOperatorDecl(name));
							}
						} else {
							result[name] = (DocSection(this, name + "->!D"),);
						}
					}
				}
			} else {
				if ("constructor" !in result)
					result["constructor"] = Tuple(autogenerateNativeConstructorSections());
				for (local name: Type.__operators__(object)) {
					if (name !is string)
						continue;
					/* Don't implicitly generate documentation for destructors of native classes
					 * Since these classes pretty much always require the presence of a destructor
					 * in order to allow them to clean up pointed-to objects, there really isn't
					 * any point in documenting them unless the type does so explicitly.
					 * -> So just skip them if we encounter them as part of the List of operators
					 *    that have been overwritten by the type. */
					if (name == "destructor")
						continue;
					if (name !in result)
						result[name] = Tuple(autogenerateOperatorDecl(name));
				}
			}
		}
		return result;
	}
	private member m_operator_sections: {string: {DocSection...}};

	@@Enumerate the child nodes used to represent operators of @this when @istype is @true
	private enumerateOperators(): {Doc...} {
		if (m_operator_sections !is bound)
			m_operator_sections = enumerateOperatorSections();
		for (local name, sect: m_operator_sections)
			yield Doc(this, "op:" + name, sect);
	}

	@@Check if @this doc node has a child attribute @name
	public final function haschild(name: string): bool {
		if (!this.haschildren)
			return false;
		if (this.istype && name.startswith("op:"))
			return !!getopdoc(name[3:]);
		if (object !is bound)
			return false;
		local my_object = object;
		local decl_object = my_object;
		if (decl_object !is Type &&
		    decl_object !is Module)
			decl_object = type decl_object;
		if (name.startswith("i:"))
			return Attribute.exists(my_object, name[2:], "i", decl: decl_object);
		if (name.startswith("c:"))
			return Attribute.exists(my_object, name[2:], "i", "", decl: decl_object);
		return Attribute.exists(my_object, name, decl: decl_object);
	}

	@@Enumerate all child nodes of @this documentation node
	operator for(): {Doc...} {
		if (!haschildren)
			return;
		if (istype)
			yield enumerateOperators()...;
		if (object !is bound)
			return;
		local my_object = object;
		local decl_object = my_object;
		if (decl_object !is Type &&
		    decl_object !is Module)
			decl_object = type decl_object;
		for (local x: enumattr(my_object)) {
			if (x.decl !== decl_object)
				break;
			yield Doc(this, x);
		}
	}

	@@Convenience interface for printing documentation information
	@@in a basic, but neat (and human-readable) format
	operator str(): string {
		File.Writer fp;
		print fp: ("-" * 80);
		print fp: ("| Documentation for `", prettypath, "'");
		for (local sec: docsections) {
			print fp: "-" * 80;
			for (local seg: sec.segments) {
				if (seg is Declaration) {
					print fp: ">>", kind, "",;
				}
				print fp: seg;
			}
		}
		print fp: "-" * 80;
		if (ismodule) {
			local children = List(this);
			children.sort();
			for (local child: children) {
				fp << child;
			}
		}
		return fp.string;
	}

}
