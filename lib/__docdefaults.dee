/* Copyright (c) 2018 Griefer@Work                                            *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement in the product documentation would be  *
 *    appreciated but is not required.                                        *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

/* !!! THIS MODULE IS NON-STANDARD and used to define a database
 *     for fallback-prototypes of undocumented function. */


@"Database of guessed standard prototypes (for when all else fails)"
local default_proto = {
	"__sizeof__"    : { "", "int" },
	"__name__"      : { none, "string" },
	"__doc__"       : { none, "string" },
	"__base__"      : { none, "type" },
	"equals"        : { "other", "bool" },
	"next"          : { "", "object" },
	"sum"           : { "", "object" },
	"seq"           : { none, "sequence" },
	"length"        : { none, "int" },
	"empty"         : { "", "bool" },
	"nonempty"      : { "", "bool" },
	"non_empty"     : { "", "bool" },
	"any"           : { "", "bool" },
	"all"           : { "", "bool" },
	"non"           : { "", "bool" },
	"parity"        : { "", "bool" },
	"min"           : { "callable pred_lo=none", "bool" },
	"max"           : { "callable pred_lo=none", "bool" },
	"count"         : { "elem,callable pred_eq=none", "int" },
	"find"          : { "elem,callable pred_eq=none", "int" },
	"rfind"         : { "elem,callable pred_eq=none", "int" },
	"index"         : { "elem,callable pred_eq=none", "int" },
	"rindex"        : { "elem,callable pred_eq=none", "int" },
	"contains"      : { "elem,callable pred_eq=none", "bool" },
	"locate"        : { "elem,callable pred_eq=none", "object" },
	"rlocate"       : { "elem,callable pred_eq=none", "object" },
	"locateall"     : { "elem,callable pred_eq=none", "sequence" },
	"transform"     : { "callable transformation", "sequence" },
	"startswith"    : { "elem,callable pred_eq=none", "bool" },
	"endswith"      : { "elem,callable pred_eq=none", "bool" },
	"reversed"      : { "", "sequence" },
	"sorted"        : { "callable pred_lo=none", "sequence" },
	"segments"      : { "int segment_size", "sequence" },
	"distribute"    : { "int bucket_count", "sequence" },
	"join"          : { "sequence items,callable pred_eq=none", "sequence" },
	"strip"         : { "sequence items,callable pred_eq=none", "sequence" },
	"lstrip"        : { "sequence items,callable pred_eq=none", "sequence" },
	"rstrip"        : { "sequence items,callable pred_eq=none", "sequence" },
	"split"         : { "sequence items,callable pred_eq=none", "sequence" },
	"countseq"      : { "sequence seq,callable pred_eq=none", "int" },
	"partition"     : { "ob,callable pred_eq=none", "(sequence,(object,),sequence)" },
	"rpartition"    : { "ob,callable pred_eq=none", "(sequence,(object,),sequence)" },
	"partitionseq"  : { "sequence seq,callable pred_eq=none", "(sequence,sequence,sequence)" },
	"rpartitionseq" : { "sequence seq,callable pred_eq=none", "(sequence,sequence,sequence)" },
	"startswithseq" : { "sequence seq,callable pred_eq=none", "bool" },
	"endswithseq"   : { "sequence seq,callable pred_eq=none", "bool" },
	"findseq"       : { "sequence seq,callable pred_eq=none", "int" },
	"rfindseq"      : { "sequence seq,callable pred_eq=none", "int" },
	"indexseq"      : { "sequence seq,callable pred_eq=none", "int" },
	"rindexseq"     : { "sequence seq,callable pred_eq=none", "int" },
	"stripseq"      : { "sequence items,callable pred_eq=none", "sequence" },
	"lstripseq"     : { "sequence items,callable pred_eq=none", "sequence" },
	"rstripseq"     : { "sequence items,callable pred_eq=none", "sequence" },
	"splitseq"      : { "sequence seq,callable pred_eq=none", "sequence" },
	"reduce"        : { "callable merger,init?", "object" },
	"filter"        : { "callable pred_keep", "sequence" },
	"sum"           : { "callable pred_keep", "sequence" },
	"get"           : { "", "object" },
	"del"           : { "", "none" },
	"set"           : { "value", "none" },
	"clear"         : { "", "none" },
	"front"         : { "", "object" },
	"back"          : { "", "object" },
	"append"        : { "items...", "none" },
	"extend"        : { "sequence items", "none" },
	"insert"        : { "int index,item", "none" },
	"resize"        : { "int new_size,filler=none", "none" },
	"resized"       : { "int new_size,filler=none", "sequence" },
	"insertseq"     : { "int index,sequence seq", "none" },
	"insertiter"    : { "int index,iterator iter", "none" },
	"remove"        : { "item,callable pred_eq=none", "bool" },
	"erase"         : { "int index,int count=1", "int" },
	"pop"           : { "int index=-1", "object" },
	"removeif"      : { "callable pred", "none" },
	"remove_if"     : { "callable pred", "none" },
	"pushfront"     : { "item", "none" },
	"pushback"      : { "item", "none" },
	"popfront"      : { "", "object" },
	"popback"       : { "", "object" },
	"reverse"       : { "", "none" },
	"sort"          : { "callable pred_lo?", "none" },
	"sorted"        : { "callable pred_lo?", "sequence" },
	"reserve"       : { "int size", "none" },
	"shrink"        : { "", "none" },
};


@"(string name,bool ismember)->(string,string)"
global function get_default_proto(name,ismember) {
	/* Strip C++'s `m_' prefix from members. */
	if (ismember)
		name = name.lsstrip("m_");
	local result = default_proto.get(name);
	if (result !is none)
		return result;
	/* Anything starting with is*, or has* is probably a
	 * property-query function/member that returns a boolean. */
	if (name.startswith("is") || name.startswith("has"))
		return pack(ismember ? none : "","bool");
	return pack(ismember ? none : "args...","object");
}















