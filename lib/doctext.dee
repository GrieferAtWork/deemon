/* Copyright (c) 2018-2020 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2018-2020 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

import * from deemon;
import * from doc;

#define DEFAULT_CONSOLE_WIDTH 80

local function unEscapePoundCharacters(text: string): string {
	if ("#" !in text)
		return text;
	local i = 0, len = #text;
	local flushStart = 0;
	File.Writer fp;
	while (i < len) {
		local ch = text[i];
		++i;
		if (ch != "#")
			continue;
		fp << text[flushStart:i - 1];
		flushStart = i;
		++i;
	}
	fp << text[flushStart:];
	return fp.string;
}

@@Find the first unmatched @closeCh after @start
local function findNonEscapedMatch(
		text: string, openCh: string, closeCh: string,
		start: int = 0, end: int = -1): int {
	local recursion = 0;
	local len = #text;
	if (end < 0 || end > len)
		end = len;
	while (start < end) {
		local ch = text[start];
		if (ch == "#") {
			start += 2;
			continue;
		}
		if (ch == "?") {
			++start;
			if (start >= end)
				break;
			/* Special case ?# doesn't escape the next character! */
			if (text[start] == "#")
				++start;
			continue;
		}
		if (ch == openCh)
			++recursion;
		else if (ch == closeCh) {
			if (!recursion)
				return start;
			--recursion;
		}
		++start;
	}
	return -1;
}

@@Find the first instance of one of @findChrs within the same @"[...]" and @"{...}"
@@level as @start, that isn't escaped by a being pre-fixed with "#"
local function findSameLevelNonEscaped(
		text: string, findChrs: string,
		start: int = 0, end: int = -1): int {
	local len = #text;
	if (end < 0 || end > len)
		end = len;
	while (start < end) {
		local ch = text[start];
		if (ch == "#") {
			start += 2;
			continue;
		}
		if (ch == "?") {
			++start;
			if (start >= end)
				break;
			/* Special case ?# doesn't escape the next character! */
			if (text[start] == "#")
				++start;
			continue;
		}
		if (ch in "{[") {
			/* Skip over child levels */
			start = findNonEscapedMatch(text, ch, {
				"{" : "}",
				"[" : "]",
			}[ch], start + 1, end);
			if (start < 0)
				break;
			++start;
			continue;
		}
		if (ch in "}]")
			break; /* The paren't level has ended */
		if (ch in findChrs)
			return start;
		++start;
	}
	return -1;
}

@@Find the first instance of @findCh, that
@@isn't escaped by a being pre-fixed with "\\"
local function findNonBackslashEscaped(
		text: string, findCh: string,
		start: int = 0, end: int = -1): int {
	local len = #text;
	if (end < 0 || end > len)
		end = len;
	while (start < end) {
		local ch = text[start];
		if (ch == "\\") {
			start += 2;
			continue;
		}
		if (ch == findCh)
			return start;
		++start;
	}
	return -1;
}


@@Split string at the nearest whitespace position before @maxSplitPosition,
@@or split it at @(maxSplitPosition - 1) and insert a "-"-character before
@@returning 2 strings for the first and second half around the split
function splitStripBefore(s: string, maxSplitPosition: int): (string, string) {
	if (maxSplitPosition >= #s)
		return (s, ""); /* Shouldn't happen... */
	if (!maxSplitPosition)
		return ("", s); /* Shouldn't happen... */
	local splitPos = maxSplitPosition;
	while (splitPos && !s.isspace(splitPos - 1))
		--splitPos;
	if (!splitPos) {
		splitPos = maxSplitPosition - 1;
		if (!splitPos)
			return ("", s); /* Shouldn't happen... */
		local lo = s[:splitPos];
		if (lo.issymcont(#lo - 1))
			lo = lo + "-";
		return (lo, s[splitPos:].lstrip());
	}
	return (
		s[:splitPos].rstrip(),
		s[splitPos:].lstrip()
	);
}

class ConsolePrinter {
	this = default;

	public member fp: File = File.Writer();
	public member maxWidth: int = DEFAULT_CONSOLE_WIDTH;
	public member currentLineInUse: int = 0;

	public property currentLineAvail: int = {
		get(): int {
			return maxWidth - currentLineInUse;
		}
	}

	public operator << (e: string | Object): ConsolePrinter {
		return append(e);
	}

	public function appendNormal(e: string | Object): ConsolePrinter {
		return append(e, lf: "\n");
	}

	public function append(e: string | Object, lf: string = "\n\n"): ConsolePrinter {
		if (e is string) {
			local isFirst = true;
			for (local l: e.splitlines(false)) {
				if (!isFirst) {
					fp << lf;
					currentLineInUse = 0;
				}
				isFirst = false;
again_handle_l:
				local avail = maxWidth - currentLineInUse;
				local linelen = #l;
				if (linelen <= avail) {
					fp << l;
					currentLineInUse += linelen;
				} else {
					local lo;
					lo, l = splitStripBefore(l, avail)...;
					fp << lo << "\n";
					currentLineInUse = 0;
					goto again_handle_l;
				}
			}
		} else {
			e.printConsoleString(this);
		}
		return this;
	}

	public function appendall(items: {(string | Object)...}): ConsolePrinter {
		for (local e: items)
			append(e);
		return this;
	}

}

function createConsoleString(
		obj: string | Object,
		maxWidth: int = DEFAULT_CONSOLE_WIDTH): string {
	local p = ConsolePrinter();
	p.append(obj);
	return p.fp.string;
}



class Header {
	this = default;

	@@The header type of this header (@1, @2, @3, @4, @5 or @6)
	@@Lower numbers should be rendered bigger than greater numbers
	public member size: int;

	@@The body that is being formatted by this header.
	public member body: {(string | Object)...};

	function printConsoleString(p: ConsolePrinter) {
		p << ("#" * size) << " ";
		p.appendall(body);
	}

	operator str(): string {
		return createConsoleString(this);
	}
}

class Code {
	this = default;

	@@Name of the language for which syntax highlighting should be performed
	@@When no language was specified, set to @"" (empty string) instead.
	public member language: string;

	@@Code body (the text that should be written as the actual code)
	public member body: string;

	@@Indentation of a multi-line inline code block (or @none if single-line)
	public member indentation: int | none;

	function printConsoleString(p: ConsolePrinter) {
		local usedBody = body.rstrip().unifylines();
		if (indentation !is none) {
			local usedIndent = " " * indentation;
			if (language == "deemon") {
				p.appendNormal(usedIndent.join(
					for (local l: usedBody.splitlines(true))
						">> " + l));
			} else {
				p.appendNormal("```{}\n{}\n{}```".format({
					language,
					usedBody.indent(usedIndent),
					usedIndent
				}));
			}
		} else if (usedBody && (usedBody[0] in "\'\"" || usedBody.isdecimal(0))) {
			p.append(usedBody);
		} else {
			p.append("`{}'".format({ usedBody }));
		}
	}

	operator str(): string {
		return createConsoleString(this);
	}
}

class HyperLink {
	this = default;

	@@The text of the actual, clickable link
	public member link: string;

	@@The body of what is the clickable link
	public member body: {(string | Object)...};

	function printConsoleString(p: ConsolePrinter) {
		(p << "[").appendall(body) << "](" << link << ")";
	}

	operator str(): string {
		return createConsoleString(this);
	}

}

class List {
	this = default;

	@@List items @{(prefix: string, body: {(string | Object)...})...}
	public member items: {(string, {(string | Object)...})...};

	function printConsoleString(p: ConsolePrinter) {
		local longestPrefixLength = items.each[0].length > ...;
		local longestPrefixLengthFull = longestPrefixLength  + 2;
		local indentSpaces = " " * longestPrefixLengthFull;
		local isFirst = true;
		for (local prefix, body: items) {
			prefix = prefix.ljust(longestPrefixLength);
			if (!isFirst)
				p.appendNormal("\n");
			p << " " << prefix << " ";
			p.appendNormal(
				ConsolePrinter(maxWidth: p.currentLineAvail)
				.appendall(body)
				.fp
				.string
				.indent(indentSpaces)
				[longestPrefixLengthFull:]);
			isFirst = false;
		}
	}

	operator str(): string {
		return createConsoleString(this);
	}
}


class Emphasis {
	this = default;

	@@The kind of emphasis
	@@+-------+-------------------+
	@@| kind  | Intended behavior |
	@@+-------+-------------------+
	@@| @"B"  | _Bold_            |
	@@|       |                   |
	@@| @"I"  | *Italic*          |
	@@|       |                   |
	@@| @"S"  | ~Strikethrough~   |
	@@+-------+-------------------+
	public member kind: string;

	@@The body that is being formatted
	public member body: {(string | Object)...};

	public function toConsoleString(maxWidth: int): string {
		local usedBody = "".join(body);
		local ekind = { "B" : "_", "I" : "*", "S" : "~" }[kind];
		if (usedBody.isanyspace())
			ekind = ekind + ekind;
		return "{}{}{}".format({ ekind, usedBody, ekind });
	}

	function printConsoleString(p: ConsolePrinter) {
		local usedBody = "".join(body);
		local ekind = { "B" : "_", "I" : "*", "S" : "~" }[kind];
		if (usedBody.isanyspace())
			ekind = ekind + ekind;
		p << ekind << usedBody << ekind;
	}

	operator str(): string {
		return createConsoleString(this);
	}
}


@@Given a @","-seperated list of options @opt, find and return the first
@@of the following options:
@@    @"tl", @"t", @"tr", @"l", @"c", @"r", @"bl", @"b", @"br"
function getOrientationFromTableCellRenderOptions(opt: string): string {
	final local ORIENTATION_OPTIONS = {
		"tl", "t", "tr", "l", "c", "r", "bl", "b", "br" };
	for (local o: opt.split(",")) {
		if (o in ORIENTATION_OPTIONS)
			return o;
	}
	return "tl"; /* Default to top-left */
}

@@Return a set of (hori_orientation, vert_orientation), where
@@both values are integers:
@@  - $0  Align left/up
@@  - $1  Align centered
@@  - $2  Align right/down
function evalTableOrientationOption(opt: string): (int, int) {
	return {
		"tl" : (0, 0),
		"t"  : (1, 0),
		"tr" : (2, 0),
		"l"  : (0, 1),
		"c"  : (1, 1),
		"r"  : (2, 1),
		"bl" : (0, 2),
		"b"  : (1, 2),
		"br" : (2, 2),
	}[opt];
}


class Table {
	this = default;

	@@The table cells
	@@> local renderopt: string, body: {(string | Object)...} = tab.cells[row][column]...;
	public member cells: {{(string, {(string | Object)...})...}...};

	@@Set of row numbers that should be rendered as thick,
	@@where @0 referrs to the bottom of the first row.
	public member thickRows: Set with int;

	@@Return the # of rows of this table (always non-zero)
	public property rows: int = {
		get(): int {
			return #cells;
		}
	}

	@@Return the # of columns of this table (always non-zero)
	public property columns: int = {
		get(): int {
			return #cells.first;
		}
	}

	function createSubTable(
			minRow: int, minColumn: int,
			maxRow: int, maxColumn: int): Table {
		local result = Table();
		result.thickRows = HashSet();
		for (local r: this.thickRows) {
			if (r >= minRow && r <= maxRow)
				result.thickRows.insert(r);
		}
		result.cells = this.cells[minRow:maxRow + 1];
		local rowCount = #result.cells;
		for (local i: [:rowCount]) {
			local row = result.cells[i];
			row = row[minColumn:maxColumn + 1];
			result.cells[i] = row;
		}
		return result;
	}

	@@Return the character-widths for individual columns when a
	@@total horizontal space of @availWidth characters is available.
	public function calculateConsoleColumnWidth(availWidth: int): {int...} {
		local nColumns = this.columns;
		local perColumn = availWidth / nColumns;
		local unused = availWidth % nColumns;
		local result = [perColumn] * nColumns;
		for (local i: [:unused])
			++result[i];
		local nRows = this.rows;
		local truncatedColumns = HashSet();
		local availableSpace = 0;
		for (local i: [:nColumns]) {
			local p = ConsolePrinter(maxWidth: 0xffffffffffffffff);
			for (local j: [:nRows])
				p.appendall(cells[j][i][1]).appendNormal("\n");
			/* Find the length of the longest line. */
			p = p.fp.string.splitlines(false).each.length > ...;
			local currentAssignment = result[i];
			if (currentAssignment > p) {
				availableSpace += currentAssignment - p;
				result[i] = p;
				truncatedColumns.insert(i);
			}
		}
		if (availableSpace) {
			/* Distribute space that became available over all cells */
			local numNonTruncatedColumns = nColumns - #truncatedColumns;
			if (numNonTruncatedColumns) {
				local availableSpacePerColumn =
					availableSpace / numNonTruncatedColumns;
				local availableSpaceOverflow =
					availableSpace % numNonTruncatedColumns;
				for (local i: [:nColumns]) {
					if (i in truncatedColumns)
						continue;
					local width = result[i] + availableSpacePerColumn;
					if (availableSpaceOverflow) {
						++width;
						--availableSpaceOverflow;
					}
					result[i] = width;
				}
			}
		}
		return result;
	}

	function printConsoleString(p: ConsolePrinter) {
		local nColumns = columns;
		local minWidth = 2 + (nColumns * 4);
		local borderWidth = 1 + (nColumns * 3);
		if (p.currentLineAvail < minWidth)
			p.appendNormal("\n");
		if (p.currentLineAvail < minWidth) {
			/* Split the table in the middle. */
			local splitColumn = nColumns / 2;
			if (!splitColumn)
				throw Error("Not enough console space");
			local lhs = createSubTable(0, 0, rows - 1, splitColumn - 1);
			local rhs = createSubTable(0, splitColumn, rows - 1, nColumns - 1);
			lhs.printConsoleString(p);
			p.appendNormal("\n");
			rhs.printConsoleString(p);
			return;
		}
		local columnsWidths = calculateConsoleColumnWidth(
			p.currentLineAvail - borderWidth);
		p.append("\u2554"); /* DOUBLE-DOWN-AND-RIGHT */
		local isFirstColumn = true;
		for (local w: columnsWidths) {
			if (!isFirstColumn)
				p.append("\u2564"); /* DOWN-SINGLE-AND-HORIZONTAL-DOUBLE */
			p.append("\u2550" * (w + 2)); /* DOUBLE-HORIZONTAL */
			isFirstColumn = false;
		}
		p.appendNormal("\u2557\n"); /* DOUBLE-DOWN-AND-LEFT */
		for (local rowNumber: [:rows]) {
			local row: {(string, {(string | Object)...})...} = cells[rowNumber];
			if (rowNumber) {
				local isThick = (rowNumber - 1) in thickRows;
				p.append(
					"\u255F"  /* VERTICAL-DOUBLE-AND-RIGHT-SINGLE */
					"\u2560"  /* DOUBLE-VERTICAL-AND-RIGHT */
					[isThick]);
				local isFirstColumn = true;
				for (local w: columnsWidths) {
					if (!isFirstColumn) {
						p.append(
							"\u253C" /* LIGHT-VERTICAL-AND-HORIZONTAL */
							"\u256A" /* VERTICAL-SINGLE-AND-HORIZONTAL-DOUBLE */
							[isThick]);
					}
					p.append(
						"\u2500" /* LIGHT-HORIZONTAL */
						"\u2550" /* DOUBLE-HORIZONTAL */
						[isThick] * (w + 2));
					isFirstColumn = false;
				}
				p.append(
					"\u2562" /* VERTICAL-DOUBLE-AND-LEFT-SINGLE */
					"\u2563" /* DOUBLE-VERTICAL-AND-LEFT */
					[isThick]);
				p.appendNormal("\n");
			}
			local cellLines = [none] * nColumns;
			local reqLines = 0;
			/* Print the lines for all cells & figure out
			 * how many lines will be needed in total. */
			for (local column: [:nColumns]) {
				local cellPrinter = ConsolePrinter(
					maxWidth: columnsWidths[column]);
				cellPrinter.appendall(row[column][1]);
				local lines = Tuple(cellPrinter.fp.string.splitlines(false));
				cellLines[column] = lines;
				lines = #lines;
				if (reqLines < lines)
					reqLines = lines;
			}
			/* Print cell lines */
			for (local lno: [:reqLines]) {
				p.append("\u2551 "); /* DOUBLE-DOWN */
				local isFirstColumn = true;
				for (local column: [:nColumns]) {
					if (!isFirstColumn)
						p.append(" \u2502 "); /* LIGHT-VERTICAL */
					isFirstColumn = false;
					local opt = row[column][0];
					local orient = evalTableOrientationOption(
						getOrientationFromTableCellRenderOptions(opt));
					local lines = cellLines[column];
					local effectiveLno = lno;
					switch (orient[1]) {
					case 1:
						/* Align to the center */
						effectiveLno = lno - (reqLines - #lines) / 2;
						break;
					case 2:
						/* Align to the bottom */
						effectiveLno = lno - (reqLines - #lines);
						break;
					default: break;
					}
					local line =
						(effectiveLno < 0 || effectiveLno >= #lines)
						? ""
						: lines[effectiveLno];
					line = line.operator . ({
						0 : "ljust",
						1 : "center",
						2 : "rjust",
					}[orient[0]])(columnsWidths[column]);
					p.append(line);
				}
				p.appendNormal(" \u2551\n"); /* DOUBLE-DOWN */
			}
		}
		p.append("\u255A"); /* DOUBLE-UP-AND-RIGHT */
		local isFirstColumn = true;
		for (local w: columnsWidths) {
			if (!isFirstColumn)
				p.append("\u2567"); /* UP-SINGLE-AND-HORIZONTAL-DOUBLE */
			p.append("\u2550" * (w + 2)); /* DOUBLE-HORIZONTAL */
			isFirstColumn = false;
		}
		p.appendNormal("\u255D\n"); /* DOUBLE-UP-AND-LEFT */
	}

	operator str(): string {
		return createConsoleString(this);
	}
}


class ArgumentReference {
	this = default;

	@@The name of the argument that is being referenced
	public member name: string;

	function printConsoleString(p: ConsolePrinter) {
		p.append("@");
		if (name.issymbol()) {
			p.append(name);
		} else {
			p << "(" << name << ")";
		}
	}

	operator str(): string {
		return createConsoleString(this);
	}
}


class ExternalReference {
	this = default;

	@@The doc path of the component that is being referenced
	@@This path is absolute (it starts with @"/"), and has the
	@@same format as what is expected by @(Doc from doc), such
	@@that it can be used to load another Doc object.
	public member path: string;

	@@Returns the name of the reference (i.e. the last part of @path)
	public property name: string = {
		get(): string {
			if (m_name !is bound) {
				local result = path.rfind("/");
				if (result < 0)
					result = path;
				else {
					result = path[result + 1:];
				}
				if (result.startswith("i:") || result.startswith("c:"))
					result = result[2:];
				else if (result.startswith("op:")) {
					local opid = result[3:];
					result = "operator " + PRETTY_OPERATOR_NAMES.get(opid, opid);
				}
				m_name = result;
			}
			return m_name;
		}
	}

	private member m_name: string;

	function printConsoleString(p: ConsolePrinter) {
		p << ">" << name << "<";
	}

	operator str(): string {
		return createConsoleString(this);
	}
}



@@Invoke the `getattr()` operator on the second item from each element from @items
@@with @attr Exceptions during invocation are silently ignored, and result in no
@@object being appended to the resulting sequence
@@The first item of each element from @items is forwarded into the resulting sequence
function resolveGetattrForAll(items: {(Object, Object)...}, attr: string): {(Object, Object)...} {
	for (local tag, e: items) {
		try {
			e = e.operator . (attr);
		} catch (...) {
			continue;
		}
		yield (tag, e);
	}
}

@@Try to resolve a @":"-shortcut reference @name, which is one of:
@@  - @"foo.bar"
@@     - Search for @"/deemon/foo/bar"
@@     - Search for @"/errors/foo/bar"
@@  - @"deemon:foo.bar"
@@     - Search for @"/deemon/foo/bar"
function resolveCollonReferenceShortcut(name: string): string | none {
	if (":" in name) {
		/* Explicit reference */
		local mod, none, attrs = name.partition(":")...;
		local result;
		try {
			result = import(mod);
			for (local a: attrs.split("."))
				result = result.operator . (a);
		} catch (...) {
			return none;
		}
		return "/{}/{}".format({ mod, attrs.replace(".", "/") });
	}
	import errors, deemon;
	local candidates = {
		("/deemon", deemon),
		("/errors", errors),
	};
	for (local a: name.split("."))
		candidates = resolveGetattrForAll(candidates, a);
	candidates = Tuple(candidates);
	if (#candidates == 1) {
		return "{}/{}".format({
			candidates[0][0],
			name.replace(".", "/")
		});
	}
	if (candidates) {
		/* If there are multiple candidates, check if the described
		 * objects match. - If they do, then simply use any one of
		 * of them as path!
		 * This is important for something like `:Error', which can
		 * be resolved both by the deemon- and errors-module, and
		 * it wouldn't matter which module actually gets resolved! */
		local obj, isFirst = true;
		for (local none, c: candidates) {
			if (isFirst) {
				obj = c;
			} else {
				/* Do a same-object-compare here! */
				if (obj !== c)
					goto different_objects;
				isFirst = false;
			}
		}
		return candidates[0][0];
	}
different_objects:
	/* Ambiguous, or undeterminable */
	return none;
}


@@Return the path to the current module of @mypath
function getCurrentModulePath(mypath: (string, bool)): string {
	local result = mypath[0].lstrip("/");
	local moduleEnd = result.find("/");
	if (moduleEnd < 0)
		moduleEnd = #result;
	return "/" + result[:moduleEnd];
}

@@Return the path to the current type of @mypath
function getCurrentTypePath(mypath: (string, bool)): string {
	/* Special case: we're alrady dealing with the current type. */
	if (mypath[1])
		return mypath[0];
	local result = mypath[0].rstrip("/");
	local typeEnd = result.rfind("/");
	if (typeEnd < 0)
		typeEnd = #result;
	return result[:typeEnd];
}


function findStartOfLine(
		docstring: string, start: int, partStart: int): int | none {
	for (;;) {
		if (partStart <= start)
			return start;
		local newpos = partStart - 1;
		if (docstring.islf(newpos))
			return partStart;
		if (!docstring.isspace(newpos))
			break;
		partStart = newpos;
	}
	return false;
}

function appearsAtEndOfLine(
		docstring: string, end: int, partEnd: int): bool {
	for (;;) {
		if (partEnd >= end)
			return true;
		if (docstring.islf(partEnd))
			return true;
		if (!docstring.isspace(partEnd))
			break;
		++partEnd;
	}
	return false;
}

function claculateComponentIndentation(
		docstring: string, start: int, end: int,
		partStart: int, partEnd: int): int | none {
	if (!appearsAtEndOfLine(docstring, end, partEnd))
		return none;
	local result = findStartOfLine(docstring, start, partStart);
	if (result !is none)
		result = partStart - result;
	return result;
}


@@A given @docstring belonging to a @TextSegment such that special formating
@@constructs are replaced with dedicated format representation objects, which
@@can then be used to easily render the actual text.
@@@param: mypath: The doc-path of the component to which @docstring belongs,
@@                followed by @true if the component is referring to a type,
@@                rather than a type member or function.
@@
@@This function yields the raw text parts as @(string)s, seperated from each
@@other by one of the special documentation text component descriptor classes
@@that can also be found in this file:
@@+--------------------------------+----------------------------------------+
@@| Component representation class |  Component syntax                      |
@@+--------------------------------+----------------------------------------+
@@| @Header                        | @"#Hn{BODY}" or @"#HnBODY"             |
@@|                                |                                        |
@@| @Emphasis                      | - @"#B{BODY}" or @"#BBODY"             |
@@|                                | - @"#I{BODY}" or @"#IBODY"             |
@@|                                | - @"#S{BODY}" or @"#SBODY"             |
@@|                                |                                        |
@@| @List                          | - @"#L-{BODY1|BODY2|BODY3}"            |
@@|                                | - @"#L+{BODY1|BODY2|BODY3}"            |
@@|                                | - @"#L*{BODY1|BODY2|BODY3}"            |
@@|                                | - @"#L{{1.}BODY1|{2.}BODY2|{3.}BODY3}" |
@@|                                |                                        |
@@| @HyperLink                     | #A{BODY|LINK}                          |
@@|                                |                                        |
@@| @Code                          | - @"#C{BODY}" or @"#CBODY"             |
@@|                                | - @"#C[deemon]{BODY}" or               |
@@|                                |   @"#C[deemon]BODY"                    |
@@|                                | - @"${BODY}" or @"$BODY"               |
@@|                                |                                        |
@@| @Table                         | @("#T{BODY11|BODY12|BODY13~"           |
@@|                                |      "BODY21|BODY22|BODY23&|"          |
@@|                                |      "BODY31|BODY32|BODY33}")          |
@@|                                |                                        |
@@| @ArgumentReference             | @"@foo" or @"@{foo}"                   |
@@|                                |                                        |
@@| @ExternalReference             | @"?..." (too many to list)             |
@@|                                |                                        |
@@| @string                        | ...                                    |
@@+--------------------------------+----------------------------------------+
function splitTextSegment(
		docstring: string, mypath: (string, bool),
		i: int = 0, end: int = -1)
	: {(string | Object)...}
{
	local flushStart = i;
	{
		local len = #docstring;
		if (end < 0 || end > len)
			end = len;
	}
#define FLUSHTO(pos)                                                  \
	{                                                                 \
		if (flushStart < (pos))                                       \
			yield unEscapePoundCharacters(docstring[flushStart:pos]); \
	}
continue_at_i:
	while (i < end) {
		local ch = docstring[i];
		switch (ch) {

		case "$": {
			local dollarStart = i;
			++i;
			if (i >= end)
				goto done;
			ch = docstring[i];
			local bodyStart, bodyEnd;
			switch (ch) {

			case "{": {
				bodyStart = i + 1;
				bodyEnd = findNonEscapedMatch(docstring, "{", "}", bodyStart, end);
				if (bodyEnd < 0)
					goto continue_at_i;
				i = bodyEnd + 1;
			}	break;

			case "r": {
				/* Raw string literal */
				bodyStart = i;
				++i;
				if (i >= end)
					goto done;
				ch = docstring[i];
				if (ch !in ["\'", "\""])
					goto do_dollar_symcont;
				++i;
				if (i >= end)
					goto continue_at_i;
				bodyEnd = docstring.find(ch, i, end);
				if (bodyEnd < 0)
					goto continue_at_i;
				++bodyEnd;
				i = bodyEnd;
			}	break;

			case "\'":
			case "\"": {
				/* String literal */
				bodyStart = i;
				++i;
				if (i >= end)
					goto done;
				bodyEnd = findNonBackslashEscaped(docstring, ch, i, end);
				if (bodyEnd < 0)
					goto continue_at_i;
				++bodyEnd;
				i = bodyEnd;
			}	break;

			case "+":
			case "-":
				bodyStart = i;
				++i;
				if (i >= end)
					goto done;
				if (docstring.isdecimal(i))
					goto do_dollar_decimal;
				break;

			default:
				if (ch.isdecimal()) {
					bodyStart = i;
do_dollar_decimal:
					for (;;) {
						++i;
						if (i >= end)
							break;
						if (docstring.isdecimal(i))
							continue;
						if (docstring[i] == ".")
							continue;
						break;
					}
					/* Strip trailing .-characters */
					while (i > bodyStart && docstring[i - 1] == ".")
						--i;
					bodyEnd = i;
					break;
				}
				if (ch.issymstrt()) {
					bodyStart = i;
					for (;;) {
						++i;
						if (i >= end)
							break;
do_dollar_symcont:
						if (!docstring.issymcont(i))
							break;
					}
					bodyEnd = i;
					break;
				}
				goto continue_at_i;
			}
			FLUSHTO(dollarStart);
			yield Code(
				language: "deemon",
				body: unEscapePoundCharacters(
					docstring[bodyStart:bodyEnd]),
				indentation: claculateComponentIndentation(
					docstring, flushStart, end, dollarStart, i));
			flushStart = i;
		}	break;

		case "#": {
			local poundStart = i;
			++i;
			if (i >= end) {
continue_after_poundStart:
				i = poundStart + 1;
				goto continue_at_i;
			}
			ch = docstring[i];
			switch (ch) {

			case "B":
			case "I":
			case "S": {
				/* Emphasis */
				local kind = ch;
				++i;
				if (i >= end)
					goto continue_after_poundStart;
				ch = docstring[i];
				local bodyStart, bodyEnd;
				if (ch == "{") {
					bodyStart = i + 1;
					bodyEnd = findNonEscapedMatch(docstring, "{", "}", bodyStart, end);
					if (bodyEnd < 0)
						goto continue_after_poundStart;
					i = bodyEnd + 1;
				} else {
					if (!ch.issymstrt())
						goto continue_after_poundStart;
					bodyStart = i;
					for (;;) {
						++i;
						if (i >= end)
							break;
						if (!docstring.issymcont(i))
							break;
					}
					bodyEnd = i;
				}
				FLUSHTO(poundStart);
				yield Emphasis(
					kind: kind,
					body: splitTextSegment(
						docstring, mypath,
						bodyStart, bodyEnd));
				flushStart = i;
			}	break;

			case "A": {
				/* HyperLink */
				++i;
				if (i >= end)
					goto continue_after_poundStart;
				if (docstring[i] != "{")
					goto continue_after_poundStart;
				++i;
				if (i >= end)
					goto continue_after_poundStart;
				local bodyStart = i;
				local bodyEnd = findSameLevelNonEscaped(docstring, "|", i, end);
				if (bodyEnd < 0)
					goto continue_after_poundStart;
				local linkStart = bodyEnd + 1;
				local linkEnd = findNonEscapedMatch(docstring, "{", "}", linkStart, end);
				if (linkEnd < 0)
					goto continue_after_poundStart;
				FLUSHTO(poundStart);
				yield HyperLink(
					link: unEscapePoundCharacters(
						docstring[linkStart:linkEnd]),
					body: splitTextSegment(
						docstring, mypath,
						bodyStart, bodyEnd));
				i = linkEnd + 1;
				flushStart = i;
			}	break;

			case "C": {
				/* Inlined code */
				++i;
				if (i >= end)
					goto continue_after_poundStart;
				ch = docstring[i];
				local language = "";
				if (ch == "[") {
					local langEnd = findNonEscapedMatch(docstring, "[", "]", i + 1, end);
					if (langEnd < 0)
						goto continue_after_poundStart;
					language = docstring[i + 1:langEnd];
					i = langEnd + 1;
					if (i >= end)
						goto continue_after_poundStart;
					ch = docstring[i];
				}
				local bodyStart, bodyEnd;
				if (ch == "{") {
					bodyStart = i + 1;
					bodyEnd = findNonEscapedMatch(docstring, "{", "}", bodyStart, end);
					if (bodyEnd < 0)
						goto continue_after_poundStart;
					i = bodyEnd + 1;
				} else {
					if (!ch.issymstrt())
						goto continue_after_poundStart;
					bodyStart = i;
					for (;;) {
						++i;
						if (i >= end)
							break;
						if (!docstring.issymcont(i))
							break;
					}
					bodyEnd = i;
				}
				FLUSHTO(poundStart);
				yield Code(
					language: language,
					body: unEscapePoundCharacters(
						docstring[bodyStart:bodyEnd]),
					indentation: claculateComponentIndentation(
						docstring, flushStart, end, poundStart, i)
				);
				flushStart = i;
			}	break;

			case "H": {
				/* Header */
				++i;
				if (i >= end)
					goto continue_after_poundStart;
				local n = docstring[i];
				if (n !in "123456")
					goto continue_after_poundStart;
				n = int(n);
				++i;
				if (i >= end)
					goto continue_after_poundStart;
				ch = docstring[i];
				local bodyStart, bodyEnd;
				if (ch == "{") {
					bodyStart = i + 1;
					bodyEnd = findNonEscapedMatch(docstring, "{", "}", bodyStart, end);
					if (bodyEnd < 0)
						goto continue_after_poundStart;
					i = bodyEnd + 1;
				} else {
					if (!ch.issymstrt())
						goto continue_after_poundStart;
					bodyStart = i;
					for (;;) {
						++i;
						if (i >= end)
							break;
						if (!docstring.issymcont(i))
							break;
					}
					bodyEnd = i;
				}
				FLUSHTO(poundStart);
				yield Header(
					size: n,
					body: splitTextSegment(
						docstring, mypath,
						bodyStart, bodyEnd));
				flushStart = i;
			}	break;

			case "L": {
				/* List */
				++i;
				if (i >= end)
					goto continue_after_poundStart;
				local commonListPrefix = "-";
				ch = docstring[i];
				if (ch in "-+*") {
					commonListPrefix = ch;
					++i;
					if (i >= end)
						goto continue_after_poundStart;
					ch = docstring[i];
				}
				if (ch != "{")
					goto continue_after_poundStart;
				++i;
				local listItems: {(string, {(string | Object)...})...} = [];
				local bodyEnd = findNonEscapedMatch(docstring, "{", "}", i, end);
				if (bodyEnd < 0)
					goto continue_after_poundStart;
				while (i < bodyEnd) {
					local elemStart = i;
					local elemEnd = findSameLevelNonEscaped(
						docstring, "|", elemStart, bodyEnd);
					if (elemEnd < 0)
						elemEnd = bodyEnd;
					local elemPrefix = commonListPrefix;
					if (elemStart < elemEnd && docstring[elemStart] == "{") {
						local prefixStart = elemStart + 1;
						local prefixEnd = findNonEscapedMatch(
							docstring, "{", "}", prefixStart, elemEnd);
						if (prefixEnd < 0)
							goto continue_after_poundStart;
						elemPrefix = docstring[prefixStart:prefixEnd];
						elemStart = prefixEnd + 1;
					}
					listItems.append((
						elemPrefix,
						splitTextSegment(
							docstring, mypath,
							elemStart, elemEnd)
					));
					i = elemEnd + 1;
				}
				FLUSHTO(poundStart);
				yield List(items: listItems);
				i = bodyEnd + 1;
				flushStart = i;
			}	break;

			case "T": {
				/* Table */
				++i;
				if (i >= end)
					goto continue_after_poundStart;
				if (docstring[i] != "{")
					goto continue_after_poundStart;
				++i;
				local tableEnd = findNonEscapedMatch(
					docstring, "{", "}", i, end);
				if (tableEnd < 0)
					goto continue_after_poundStart;
				local rowLength: int = none;
				local row = [];
				local rows = [];
				local thickRows = HashSet();
				while (i < tableEnd) {
					local cellStart = i;
					local cellEnd = findSameLevelNonEscaped(
						docstring, "|~&", cellStart, tableEnd);
					if (cellEnd < 0)
						cellEnd = tableEnd;
					local renderOptions = "";
					if (cellStart < cellEnd) {
						ch = docstring[cellStart];
						if (ch == "{") {
							local optStart = cellStart + 1;
							local optEnd = findNonEscapedMatch(
								docstring, "{", "}", optStart, cellEnd);
							if (optEnd < 0)
								goto continue_after_poundStart;
							renderOptions = unEscapePoundCharacters(
								docstring[optStart:optEnd]);
							cellStart = optEnd + 1;
						}
					}
					/* Append the new cell */
					row.append((
						renderOptions,
						splitTextSegment(
							docstring, mypath,
							cellStart, cellEnd)
					));
					i = cellEnd + 1;
					local marker = docstring[cellEnd];
					if (marker == "|")
						continue;
					/* Complete the current row */
					if (marker == "~")
						thickRows.insert(#rows); /* Thick row */
					if (rowLength is none) {
						rowLength = #row;
					} else if (rowLength != #row) {
						/* The specs require weak undefined behavior
						 * when row counts don't match. And while this
						 * this shouldn't happen, handle this case by
						 * forcing the correct row length. */
						print "WARNING:", repr row;
						row.resize(rowLength, filler: ("", { "" }));
					}
					rows.append(row);
					row = [];
				}
				if (!rows)
					rows = [[("", { "" })]]; /* Shouldn't happen... */
				FLUSHTO(poundStart);
				yield Table(
					cells: rows,
					thickRows: thickRows);
				i = tableEnd + 1;
				flushStart = i;
			}	break;

			default:
				/* Escape one character */
				++i;
				goto continue_at_i;
			}
		}	break;

		case "@": {
			local atStart = i;
			++i;
			if (i >= end) {
continue_after_atStart:
				i = atStart + 1;
				goto continue_at_i;
			}
			local nameEnd;
			local nameStart = i;
			ch = docstring[i];
			++i;
			if (ch == "{") {
				if (i >= end)
					goto continue_after_atStart;
				nameStart = i;
				nameEnd = findNonEscapedMatch(
					docstring, "{", "}", nameStart, end);
				if (nameEnd < 0)
					goto continue_after_atStart;
				i = nameEnd + 1;
			} else {
				if (!ch.issymstrt())
					goto continue_after_atStart;
				while (i < end && docstring.issymcont(i))
					++i;
				nameEnd = i;
			}
			FLUSHTO(atStart);
			yield ArgumentReference(
				name: unEscapePoundCharacters(
					docstring[nameStart:nameEnd]));
			flushStart = i;
		}	break;

		case ":": {
			local collonStart = i;
			++i;
			if (i >= end) {
continue_after_collonStart:
				i = collonStart + 1;
				goto continue_at_i;
			}
			local nameEnd;
			local nameStart = i;
			ch = docstring[i];
			++i;
			if (ch == "{") {
				if (i >= end)
					goto continue_after_collonStart;
				nameStart = i;
				nameEnd = findNonEscapedMatch(
					docstring, "{", "}", nameStart, end);
				if (nameEnd < 0)
					goto continue_after_collonStart;
				i = nameEnd + 1;
			} else {
				if (!ch.issymstrt())
					goto continue_after_collonStart;
				while (i < end && (docstring.issymcont(i) || docstring[i] in ".:"))
					++i;
				nameEnd = i;
			}
			/* Try to resolve the reference */
			local externalPath = resolveCollonReferenceShortcut(
				unEscapePoundCharacters(
					docstring[nameStart:nameEnd]));
			if (externalPath is none)
				goto continue_after_collonStart; /* Cannot be resolved... */
			FLUSHTO(collonStart);
			yield ExternalReference(path: externalPath);
			flushStart = i;
		}	break;

		case "?": {
			local questionStart = i;
			++i;
again_parse_character_after_question:
			if (i >= end)
				goto continue_after_questionStart;
			ch = docstring[i];
			++i;
			local ref;
			local addend = "";
			switch (ch) {

			case ".":
				/* The current component. */
				ref = getCurrentTypePath(mypath);
				break;

			case "M":
			case "A":
			case "E":
			case "#":
			case "G":
			case "D": {
				/* Parse the string operand. */
				if (i >= end)
					goto continue_after_questionStart;
				local nameEnd;
				local nameStart = i;
				local ch2 = docstring[i];
				++i;
				if (ch2 == "{") {
					if (i >= end)
						goto continue_after_questionStart;
					nameStart = i;
					nameEnd = findNonEscapedMatch(
						docstring, "{", "}", nameStart, end);
					if (nameEnd < 0)
						goto continue_after_questionStart;
					i = nameEnd + 1;
				} else {
					if (!ch2.issymstrt())
						goto continue_after_questionStart;
					while (i < end && (docstring.issymcont(i) || docstring[i] in ".:"))
						++i;
					nameEnd = i;
				}
				ref = unEscapePoundCharacters(docstring[nameStart:nameEnd]);
				if ("/" in ref)
					goto continue_after_questionStart; /* Not allowed */
				switch (ch) {

				case "M":
					/* Module name */
					if (ref == ".")
						ref = getCurrentModulePath(mypath); /* Current module */
					ref = "/" + ref;
					break;

				case "A":
					if (i >= end)
						goto continue_after_questionStart;
					if (docstring[i] != "?")
						goto continue_after_questionStart;
					++i;
					addend = "{}/{}".format({ ref, addend.strip("/") });
					goto again_parse_character_after_question;

				case "E": {
					/* External reference (module_name == ref) */
					if (i >= end)
						goto continue_after_questionStart;
					ch2 = docstring[i];
					if (ch2 != ":")
						goto continue_after_questionStart;
					++i;
					nameStart = i;
					ch2 = docstring[i];
					++i;
					if (ch2 == "{") {
						if (i >= end)
							goto continue_after_questionStart;
						nameStart = i;
						nameEnd = findNonEscapedMatch(
							docstring, "{", "}", nameStart, end);
						if (nameEnd < 0)
							goto continue_after_questionStart;
						i = nameEnd + 1;
					} else {
						if (!ch2.issymstrt())
							goto continue_after_questionStart;
						while (i < end && (docstring.issymcont(i) || docstring[i] in ".:"))
							++i;
						nameEnd = i;
					}
					local globalName = unEscapePoundCharacters(
						docstring[nameStart:nameEnd]);
					if ("/" in globalName)
						goto continue_after_questionStart; /* Not allowed */
					ref = "/{}/{}".format({ ref, globalName });
				}	break;

				case "#":
					/* Element in current component */
					ref = "{}/{}".format({
						getCurrentTypePath(mypath),
						ref
					});
					break;

				case "G":
					/* Element of current module */
					ref = "{}/{}".format({
						getCurrentModulePath(mypath),
						ref
					});
					break;

				case "D":
					/* Element from the deemon module */
					ref = "/deemon/" + ref;
					break;

				default:
					break;
				}
			}	break;

			case "O":
				ref = "/deemon/Object";
				break;

			case "N":
				ref = "/deemon/none";
				break;

			case "t":
				ref = "/deemon/true";
				break;

			case "f":
				ref = "/deemon/false";
				break;

			case "R": {
				/* Type-Expression-like aliases & alternatives */
				if (i >= end)
					goto continue_after_questionStart;
				if (docstring[i] != "!")
					goto continue_after_questionStart;
				++i;
				if (i >= end)
					goto continue_after_questionStart;
				ch = docstring[i];
				++i;
				switch (ch) {

				case "A":
				case "D":
				case "E":
				case "G":
				case "M":
				case "#": {
					if (i >= end)
						goto continue_after_questionStart;
					local nameEnd;
					local nameStart = i;
					local ch2 = docstring[i];
					++i;
					if (ch2 == "{") {
						if (i >= end)
							goto continue_after_questionStart;
						nameStart = i;
						nameEnd = findNonEscapedMatch(
							docstring, "{", "}", nameStart, end);
						if (nameEnd < 0)
							goto continue_after_questionStart;
						i = nameEnd + 1;
					} else {
						if (!ch2.issymstrt())
							goto continue_after_questionStart;
						while (i < end && (docstring.issymcont(i) || docstring[i] in ".:"))
							++i;
						nameEnd = i;
					}
					ref = unEscapePoundCharacters(docstring[nameStart:nameEnd]);
					if ("/" in ref)
						goto continue_after_questionStart; /* Not allowed */
					switch (ch) {

					case "A":
						/* Argument reference */
						ref = ArgumentReference(name: ref);
						break;

					case "M":
						/* Module name */
						if (ref == ".")
							ref = getCurrentModulePath(mypath); /* Current module */
						ref = "/" + ref;
						break;

					case "E": {
						/* External reference (module_name == ref) */
						if (i >= end)
							goto continue_after_questionStart;
						ch2 = docstring[i];
						if (ch2 != ":")
							goto continue_after_questionStart;
						++i;
						nameStart = i;
						ch2 = docstring[i];
						++i;
						if (ch2 == "{") {
							if (i >= end)
								goto continue_after_questionStart;
							nameStart = i;
							nameEnd = findNonEscapedMatch(
								docstring, "{", "}", nameStart, end);
							if (nameEnd < 0)
								goto continue_after_questionStart;
							i = nameEnd + 1;
						} else {
							if (!ch2.issymstrt())
								goto continue_after_questionStart;
							while (i < end && (docstring.issymcont(i) || docstring[i] in ".:"))
								++i;
							nameEnd = i;
						}
						local globalName = unEscapePoundCharacters(
							docstring[nameStart:nameEnd]);
						if ("/" in globalName)
							goto continue_after_questionStart; /* Not allowed */
						ref = "/{}/{}".format({ ref, globalName });
					}	break;

					case "#":
						/* Element in current component */
						ref = "{}/{}".format({
							getCurrentTypePath(mypath),
							ref
						});
						break;

					case "G":
						/* Element of current module */
						ref = "{}/{}".format({
							getCurrentModulePath(mypath),
							ref
						});
						break;

					case "D":
						/* Element from the deemon module */
						ref = "/deemon/" + ref;
						break;

					default:
						break;
					}
				}	break;

				case "t":
					ref = "/deemon/true";
					break;

				case "f":
					ref = "/deemon/false";
					break;

				case "N":
					ref = "/deemon/none";
					break;

				default:
					goto continue_after_questionStart;
				}
				if (i >= end)
					goto continue_after_questionStart;
				ch = docstring[i];
				if (ch != "]")
					goto continue_after_questionStart;
				++i;
				if (ref !is string)
					goto do_flush_and_yield_after_questionStart;
			}	break;

			default:
continue_after_questionStart:
				i = questionStart + 1;
				goto continue_at_i;
			}
			ref = ExternalReference(path: ref);
			if (addend) {
				ref.path = "{}/{}".format({
					ref.path.rstrip("/"),
					addend.strip("/")
				});
			}
do_flush_and_yield_after_questionStart:
			FLUSHTO(questionStart);
			yield ref;
			flushStart = i;
		}	break;

		default:
			++i;
			break;
		}
	}
done:
	FLUSHTO(end);
}















